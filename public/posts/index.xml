<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Dmytro&#39;s Blog</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on Dmytro&#39;s Blog</description>
    <image>
      <title>Dmytro&#39;s Blog</title>
      <url>http://localhost:1313/images/papermod-cover.png</url>
      <link>http://localhost:1313/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 26 Apr 2024 06:51:21 +0300</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Testing Xcode project using Github Actions</title>
      <link>http://localhost:1313/posts/testing-xcode-project-using-github-actions/</link>
      <pubDate>Fri, 26 Apr 2024 06:51:21 +0300</pubDate>
      <guid>http://localhost:1313/posts/testing-xcode-project-using-github-actions/</guid>
      <description>Introduction If you&amp;rsquo;re wondering how to test an Xcode project using GitHub Actions, here are a few steps:
First, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.</description>
    </item>
    <item>
      <title>Building Xcode project using Github Actions</title>
      <link>http://localhost:1313/posts/post-15/</link>
      <pubDate>Tue, 23 Apr 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-15/</guid>
      <description>Introduction If you&amp;rsquo;re wondering how to build an Xcode project using GitHub Actions, here are a few steps:
First, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.</description>
    </item>
    <item>
      <title>Delivering iOS app using Fastlane</title>
      <link>http://localhost:1313/posts/post-14/</link>
      <pubDate>Fri, 19 Apr 2024 06:49:13 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-14/</guid>
      <description>Introduction You can easily deliver an iOS app in two ways: through beta and release lanes.
The First Way - TestFlight By creating a beta lane inside the Fastfile. It utilizes:
build_app: To easily build and sign your app (via gym). pilot: Makes it easier to manage your app on Apple’s TestFlight. lane :beta do build_app(scheme: &amp;#34;YourScheme&amp;#34;) pilot end To run Fastlane:
fastlane beta Attention Before proceeding, you need to have the ipa or pkg file generated.</description>
    </item>
    <item>
      <title>Archiving Xcode project using the CLI</title>
      <link>http://localhost:1313/posts/post-6/</link>
      <pubDate>Tue, 16 Apr 2024 13:46:03 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-6/</guid>
      <description>Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to archive a project in the fastest way.
One of such ways is by using the xcodebuild archive command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project.</description>
    </item>
    <item>
      <title>Testing Xcode project using the CLI</title>
      <link>http://localhost:1313/posts/post-3/</link>
      <pubDate>Fri, 12 Apr 2024 03:20:34 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-3/</guid>
      <description>Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to test a project in the fastest way.
One of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you&amp;rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project.</description>
    </item>
    <item>
      <title>Building Xcode project using the CLI</title>
      <link>http://localhost:1313/posts/post-2/</link>
      <pubDate>Fri, 05 Apr 2024 04:59:38 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-2/</guid>
      <description>Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to build a project in the fastest way.
One of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you&amp;rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project.</description>
    </item>
    <item>
      <title>The Visitor Pattern</title>
      <link>http://localhost:1313/posts/post-1/</link>
      <pubDate>Mon, 01 Apr 2024 08:01:22 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-1/</guid>
      <description>In this article: What is a Visitor Pattern? What problems does it solve? Real-world code example What is a Visitor Pattern? The Visitor Pattern helps add new capabilities to a composite of objects.
Source
What problems does it solve? The Visitor Pattern helps solve following problems:
Separation of Concerns: The Visitor Pattern separates algorithms from the objects on which they operate. This allows for clean code organization by keeping algorithms and operations separate from the data structures they operate on.</description>
    </item>
    <item>
      <title>Combine — Basics</title>
      <link>http://localhost:1313/posts/combine-basics/</link>
      <pubDate>Wed, 07 Feb 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/combine-basics/</guid>
      <description>Introduction What is Combine? Combine Framework provides an API for processing async events over time such as user-input, network response, and other dynamic data.
What is the purpose of Combine? The purpose of Combine is to simplify the management of async events and data streams.
Publishers Publisher declares that a type can transit a sequence of values over time. A publisher delivers elements to one or more Subscriber instances.
class PostService { func fetchPosts() -&amp;gt; AnyPublisher&amp;lt;[Post], Error&amp;gt; { guard let url = URL(string: &amp;#34;https://jsonplaceholder.</description>
    </item>
    <item>
      <title>Modern Concurrency</title>
      <link>http://localhost:1313/posts/modern-concurrency/</link>
      <pubDate>Sun, 04 Feb 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/modern-concurrency/</guid>
      <description>Introduction When was it introduced? It was introduced in Swift 5.5 at WWDC 2021.
You can find the more comprehensive info about Modern Concurrency in Swift Concurrency Manifesto.
What are actors? Actors eliminate shared mutable state and explicit synchronization through deep copying of all the data that passed to an actor to a message sent and preventing direct access to actor state. Actors are reference types.
actor DatabaseManager { private var data: [String: String] = [:] func readData(key: String) -&amp;gt; String?</description>
    </item>
    <item>
      <title>What are Threads in Swift?</title>
      <link>http://localhost:1313/posts/what-are-threads-in-swift/</link>
      <pubDate>Sat, 20 Jan 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/what-are-threads-in-swift/</guid>
      <description>Introduction What is the Thread? A Thread is a small set of instructions that can be executed independently from the main program. Threads are often used to improve program performance by allowing multiple tasks to be executed at the same time. The Thread has its own stack, registers, and program counters.
Threads share memory address space, and it is possible to communicate between Threads using shared memory space. How to use it?</description>
    </item>
    <item>
      <title>DispatchGroup in Swift</title>
      <link>http://localhost:1313/posts/post-13/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-13/</guid>
      <description>What is DispatchGroup? DispatchGroup provides a mechanism to track the completion group of tasks.
How DispatchGroup works? DispatchGroup has three main methods, enter, leave and notify, that allow you to control the completion of a specific task.
let dispatchGroup = DispatchGroup() dispatchGroup.enter() dispatchGroup.leave() dispatchGroup.notify(queue: .main) {} Let`s talk about each of these methods. enter — manually indicate a block has entered group. leave — manually indicate a block in the group has been completed.</description>
    </item>
    <item>
      <title>Concurrency in Swift</title>
      <link>http://localhost:1313/posts/post-12/</link>
      <pubDate>Sun, 07 Jan 2024 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-12/</guid>
      <description>What is concurrency? The system can perform multiple tasks simultaneously. By tasks, I mean code or instructions. Modern computer chips have multiple cores that allow developers to create and run various tasks on multiple cores. Even if your chip has one core operating system it will provide context switching mechanism by enabling it to execute multiple tasks concurrently.
Material about processes, threads I will skip explaining concepts about processes and threads because it is a vast topic, and it will take a lot of time to explain it.</description>
    </item>
    <item>
      <title>What are value types in Swift?</title>
      <link>http://localhost:1313/posts/post-8/</link>
      <pubDate>Thu, 28 Dec 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-8/</guid>
      <description>What are value types? Value types play a central role in programming languages by grouping data values.
`Value type” is a type of data copied when assigned to a new variable.
struct Storage { var data: String = &amp;#34;some data&amp;#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` How can you pass value types? You can pass value type by copying value.
struct Storage { var data: String = &amp;#34;some data&amp;#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` copiedStorage.</description>
    </item>
    <item>
      <title>How to prevent memory leaks?</title>
      <link>http://localhost:1313/posts/post-9/</link>
      <pubDate>Sun, 24 Dec 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-9/</guid>
      <description>I was searching for tools that could help me find memory leaks faster and would be simple in implementation without affecting performance and memory size of application.
I found a fantastic fit for this task LifetimeTracker developed by Krzysztof Zabłocki.
All you need is to add LifetimeTracker package to the project, inherit from LifetimeTrackable protocol, and add two lines of code.
class Department: LifetimeTrackable {} trackLifetime method to init of instance that you are going to verify, and lifetimeConfiguration property where you set max number of valid instances.</description>
    </item>
    <item>
      <title>How to find memory leaks?</title>
      <link>http://localhost:1313/posts/post-10/</link>
      <pubDate>Wed, 20 Dec 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-10/</guid>
      <description>The common way to find memory leaks is by using Xcode Instruments. All you need is the following:
Open Xcode Instruments
Choose Leaks option Select Simulator where you are going to test your application Select your installed application When you finish preparation, you can start immediate recoding and check application for leaks. To do that, you need to open Simulator and try some cases that could cause memory leaks.
After you spend some time trying different scenarios, you can see that Instruments found Leaked Objects.</description>
    </item>
    <item>
      <title>ARC in Swift</title>
      <link>http://localhost:1313/posts/post-11/</link>
      <pubDate>Sun, 17 Dec 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-11/</guid>
      <description>What is ARC? Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed. - Apple
ARC In Action In this example, we assign an instance to the reference1 property.</description>
    </item>
    <item>
      <title>What is closure in Swift language?</title>
      <link>http://localhost:1313/posts/post-7/</link>
      <pubDate>Sun, 10 Dec 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-7/</guid>
      <description>Introduction In this article, I’m going to briefly explain what closure is.
Closures is self-conitained blocks of funcionality that can be passed around and used in your code. — Apple
Expression:
{ (params) -&amp;gt; return value in statements } @escaping When closure is marked as escaping, it will outlive or leave the scope you passed.
func response(_ completionHandler: @escaping(Result) -&amp;gt; Void) { completionHandler(.success) } @nonescaping By default, closures are nonescaping, meaning closure will no longer exist in memory after complete execution in the scope you have passed it to.</description>
    </item>
    <item>
      <title>What is “reference type” in Swift?</title>
      <link>http://localhost:1313/posts/post-5/</link>
      <pubDate>Sun, 03 Dec 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-5/</guid>
      <description>Introduction In Swift, classes, closures, and actors all reference types.
&amp;lsquo;Reference type’ is instance that shares a single copy of data.
Assigning a reference type to a constant or variable, or passing it into a function or method, it is always a reference to a shared instance that is assigned or passed in.
Example You can pass your property value by sharing the same address in memory.
// Reference type example class Storage { var data = “data-example” } var storage = Storage() print(&amp;#34;\(storage.</description>
    </item>
    <item>
      <title>Let’s talk about Composable Architecture</title>
      <link>http://localhost:1313/posts/post-4/</link>
      <pubDate>Fri, 11 Aug 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/post-4/</guid>
      <description>Introduction The Composable Architecture (TCA) uses a unidirectional data flow (UDF). UDF is a design pattern where data and events move consistently and predictably. In UDF, data can only be transferred to other application parts in one way.
In TCA, the only way to mutate the state is by sending actions to a runtime store. The runtime store holds the entire app’s business logic and mutates the state inside.
UDF can reduce data inconsistencies because of the single source of truth for the application.</description>
    </item>
  </channel>
</rss>
