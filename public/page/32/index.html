<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.147.0"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Dmytro&#39;s Blog</title>

<meta name="description" content="">
<meta name="author" content="Dmytro Chumakov">
<link rel="canonical" href="http://localhost:1313/">
<meta name="google-site-verification" content="G-HZZ4JTFGDP">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8d4df4fe329d2372424d28ce76581b7279a2220496c292d225bde1c201d0518c.css" integrity="sha256-jU30/jKdI3JCTSjOdlgbcnmiIgSWwpLSJb3hwgHQUYw=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/index.xml">
<link rel="alternate" type="application/json" href="http://localhost:1313/index.json">
<link rel="alternate" hreflang="en" href="http://localhost:1313/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><style>
    @media screen and (min-width: 769px) {
         
        .post-content input[type="checkbox"]:checked ~ label > img {
            transform: scale(1.6);
            cursor: zoom-out;
            position: relative;
            z-index: 999;
        }
    
        .post-content img.zoomCheck {
            transition: transform 0.15s ease;
            z-index: 999;
            cursor: zoom-in;
        }
    }
    </style>
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-HZZ4JTFGDP"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-HZZ4JTFGDP');
        }
      </script><meta property="og:url" content="http://localhost:1313/">
  <meta property="og:site_name" content="Dmytro&#39;s Blog">
  <meta property="og:title" content="Dmytro&#39;s Blog">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">
      <meta property="og:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:title" content="Dmytro&#39;s Blog">
<meta name="twitter:description" content="">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Dmytro's Blog",
  "url": "http://localhost:1313/",
  "description": "",
  "logo": "http://localhost:1313/favicon.ico",
  "sameAs": [
      "https://github.com/dmytrochumakov", "https://leetcode.com/u/dmytrochumakov0/", "https://www.linkedin.com/in/dmytro-chumakov/", "mailto:dmytro.v.chumakov.work@gmail.com"
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Dmytro&#39;s Blog (Alt + H)">Dmytro&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>

        
        <button id="menu-trigger" aria-haspopup="menu" aria-label="Menu Button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
            </svg>
        </button>
        <ul class="menu hidden">
            <li>
                <a href="http://localhost:1313/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">The Visitor Pattern
    </h2>
  </header>
  <div class="entry-content">
    <p>What is a Visitor Pattern? The Visitor Pattern helps add new capabilities to a composite of objects.
Source
What problems does it solve? The Visitor Pattern helps solve following problems:
Separation of Concerns: The Visitor Pattern separates algorithms from the objects on which they operate. This allows for clean code organization by keeping algorithms and operations separate from the data structures they operate on. Extensibility: It allows you to add new operations to existing object structures without modifying those structures. This is especially useful when dealing with complex object hierarchies where adding new functionality directly to the classes would lead to code bloat and tight coupling. Traversal of Object Structures: It provides a way to traverse complex object structures while performing some action on each element of the structure. This is particularly useful in scenarios where you need to process every element of a data structure in a specific order or with a specific algorithm. Real-world code example // Element protocol representing the items on the menu protocol MenuItem { func accept(visitor: OrderVisitor) } // Concrete item types class Coffee: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } class Tea: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } class Pastry: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } // Visitor protocol defining the operations to be performed on menu items protocol OrderVisitor { func visit(_ item: Coffee) func visit(_ item: Tea) func visit(_ item: Pastry) } // Concrete visitor implementing operations on menu items class TotalCostVisitor: OrderVisitor { var totalCost = 0.0 func visit(_ item: Coffee) { totalCost &#43;= item.price } func visit(_ item: Tea) { totalCost &#43;= item.price } func visit(_ item: Pastry) { totalCost &#43;= item.price } } class ItemDetailsVisitor: OrderVisitor { var details = &#34;&#34; func visit(_ item: Coffee) { details &#43;= &#34;Coffee: \(item.name), Price: $\(item.price)\n&#34; } func visit(_ item: Tea) { details &#43;= &#34;Tea: \(item.name), Price: $\(item.price)\n&#34; } func visit(_ item: Pastry) { details &#43;= &#34;Pastry: \(item.name), Price: $\(item.price)\n&#34; } } // Example usage let items: [MenuItem] = [Coffee(name: &#34;Espresso&#34;, price: 2.5), Tea(name: &#34;Green Tea&#34;, price: 2.0), Pastry(name: &#34;Croissant&#34;, price: 3.0)] let totalCostVisitor = TotalCostVisitor() for item in items { item.accept(visitor: totalCostVisitor) } print(&#34;Total cost of the order: $\(totalCostVisitor.totalCost)&#34;) let itemDetailsVisitor = ItemDetailsVisitor() for item in items { item.accept(visitor: itemDetailsVisitor) } print(&#34;Order details:&#34;) print(itemDetailsVisitor.details) </p>
  </div>
  <footer class="entry-footer"><span title='2024-04-01 08:01:22 +0300 EEST'>April 1, 2024</span>&nbsp;¬∑&nbsp;3 min&nbsp;¬∑&nbsp;Dmytro Chumakov</footer>
  <a class="entry-link" aria-label="post link to The Visitor Pattern" href="http://localhost:1313/posts/the-visitor-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">The Memento Pattern
    </h2>
  </header>
  <div class="entry-content">
    <p>What is a Memento Pattern? The Memento Pattern helps return an object to one of its previous states; for instance, if the user requests an ‚Äúundo‚Äù operation.
Source
What problems does it solve? The Memento Pattern helps solve following problems:
Undo/Redo Functionality: Memento allows you to capture an object‚Äôs state at a specific point in time and store it externally. This enables you to implement undo/redo functionality by restoring the object to its previous state. Checkpointing: In applications where users need to save progress or create checkpoints (such as in games or long processes), the Memento Pattern allows you to save the state of an object at various intervals so that users can return to those points later. Real-world code example // Memento: Represents the state of the TextEditor struct TextEditorMemento { let text: String } // Originator: Creates and stores states in Memento objects class TextEditor { private var text: String = &#34;&#34; func setText(_ text: String) { self.text = text } func getText() -&gt; String { return text } func save() -&gt; TextEditorMemento { return TextEditorMemento(text: text) } func restore(fromMemento memento: TextEditorMemento) { self.text = memento.text } } // Caretaker: Manages the mementos class TextEditorHistory { private var history: [TextEditorMemento] = [] private let editor: TextEditor init(editor: TextEditor) { self.editor = editor } func save() { let snapshot = editor.save() history.append(snapshot) } func undo() { guard let lastSnapshot = history.popLast() else { print(&#34;Nothing to undo.&#34;) return } editor.restore(fromMemento: lastSnapshot) } func printHistory() { print(&#34;Text Editor History:&#34;) for (index, snapshot) in history.enumerated() { print(&#34;Step \(index &#43; 1): \(snapshot.text)&#34;) } print(&#34;Current text: \(editor.getText())&#34;) } } // Example usage let textEditor = TextEditor() let history = TextEditorHistory(editor: textEditor) textEditor.setText(&#34;Hello, World!&#34;) history.save() textEditor.setText(&#34;This is a Swift example.&#34;) history.save() textEditor.setText(&#34;Using Memento Pattern.&#34;) history.save() history.printHistory() history.undo() print(&#34;After Undo:&#34;) history.printHistory() Thank you for reading! üòä</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-22 08:29:30 +0300 +0300'>March 22, 2024</span>&nbsp;¬∑&nbsp;2 min&nbsp;¬∑&nbsp;Dmytro Chumakov</footer>
  <a class="entry-link" aria-label="post link to The Memento Pattern" href="http://localhost:1313/posts/the-memento-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">The Interpreter Pattern
    </h2>
  </header>
  <div class="entry-content">
    <p>What is an Interpreter Pattern? The Interpreter Pattern helps implement a simple language and defines a class based representation for its grammar along with an interpreter to interpret its sentences.
Source
What problems does it solve? The Interpreter Pattern helps solve following problems:
Language Interpretation: When you have a language or syntax that needs to be interpreted, such as mathematical expressions, regular expressions, or domain-specific languages (DSLs), the Interpreter Pattern helps in implementing the logic to interpret and execute these expressions. Extensibility: The Interpreter Pattern allows for easy addition of new grammar rules or language constructs without modifying the core interpreter logic. This promotes extensibility, enabling the interpreter to support new features or languages with minimal changes. Separation of Concerns: It separates the grammar definition from the interpretation logic. This separation of concerns makes the codebase modular and easier to maintain. Changes to the grammar or language rules do not affect the interpretation logic, and vice versa. Real-world code example // Define the protocol for the expression protocol Expression { func interpret() -&gt; Int } // Concrete expression for a number class NumberExpression: Expression { private var value: Int init(_ value: Int) { self.value = value } func interpret() -&gt; Int { return value } } // Concrete expression for addition class AdditionExpression: Expression { private var left: Expression private var right: Expression init(_ left: Expression, _ right: Expression) { self.left = left self.right = right } func interpret() -&gt; Int { return left.interpret() &#43; right.interpret() } } // Concrete expression for subtraction class SubtractionExpression: Expression { private var left: Expression private var right: Expression init(_ left: Expression, _ right: Expression) { self.left = left self.right = right } func interpret() -&gt; Int { return left.interpret() - right.interpret() } } // Concrete expression for multiplication class MultiplicationExpression: Expression { private var left: Expression private var right: Expression init(_ left: Expression, _ right: Expression) { self.left = left self.right = right } func interpret() -&gt; Int { return left.interpret() * right.interpret() } } // Concrete expression for division class DivisionExpression: Expression { private var left: Expression private var right: Expression init(_ left: Expression, _ right: Expression) { self.left = left self.right = right } func interpret() -&gt; Int { let divisor = right.interpret() if divisor != 0 { return left.interpret() / divisor } else { // Handle division by zero error fatalError(&#34;Division by zero&#34;) } } } // Usage let expression = AdditionExpression( MultiplicationExpression(NumberExpression(2), NumberExpression(3)), DivisionExpression(NumberExpression(10), NumberExpression(5)) ) // Interpret the expression let result = expression.interpret() print(&#34;Result: \(result)&#34;) Thank you for reading! üòä</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-18 08:29:30 +0300 +0300'>March 18, 2024</span>&nbsp;¬∑&nbsp;2 min&nbsp;¬∑&nbsp;Dmytro Chumakov</footer>
  <a class="entry-link" aria-label="post link to The Interpreter Pattern" href="http://localhost:1313/posts/the-interpreter-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">The Flyweight Pattern
    </h2>
  </header>
  <div class="entry-content">
    <p>What is a Flyweight Pattern? The Flyweight Pattern refers to an object that minimizes memory usage by sharing some of its data with other similar objects.
Source
What problems does it solve? The Flyweight Pattern helps solve following problems:
Large Memory Footprint: When dealing with a large number of objects, especially if these objects share a significant amount of common state, traditional object creation can lead to excessive memory consumption. The Flyweight Pattern reduces memory usage by sharing this common state among multiple objects. Performance Overhead: Creating and managing a large number of objects can also introduce performance overhead due to memory allocation, deallocation, and initialization. By reusing shared objects and minimizing the creation of new objects, the Flyweight Pattern can improve performance. Object Creation Cost: Creating new objects can be costly in terms of time and resources, especially if the objects require complex initialization. By reusing existing objects, the Flyweight Pattern reduces the need for creating new objects, thereby reducing object creation costs. Real-world code example // Flyweight protocol defining the interface for shapes protocol Shape { func draw(at point: CGPoint) } // Concrete flyweight class representing a circle class Circle: Shape { private let radius: CGFloat private let fillColor: UIColor init(radius: CGFloat, fillColor: UIColor) { self.radius = radius self.fillColor = fillColor } func draw(at point: CGPoint) { print(&#34;Drawing Circle at (\(point.x), \(point.y)) with radius \(radius) and fill color \(fillColor)&#34;) // Actual drawing logic would go here } } // Flyweight factory class responsible for creating and managing flyweight objects class ShapeFactory { private var flyweights = [String: Shape]() func getCircle(radius: CGFloat, fillColor: UIColor) -&gt; Shape { let key = &#34;Circle-\(radius)-\(fillColor)&#34; if let existingShape = flyweights[key] { return existingShape } else { let newShape = Circle(radius: radius, fillColor: fillColor) flyweights[key] = newShape return newShape } } } // Client code let shapeFactory = ShapeFactory() // Request for circles with different properties let circle1 = shapeFactory.getCircle(radius: 10, fillColor: .red) let circle2 = shapeFactory.getCircle(radius: 10, fillColor: .red) // Reusing the same circle object let circle3 = shapeFactory.getCircle(radius: 20, fillColor: .blue) // Drawing circles circle1.draw(at: CGPoint(x: 100, y: 100)) circle2.draw(at: CGPoint(x: 200, y: 200)) circle3.draw(at: CGPoint(x: 300, y: 300)) Thank you for reading! üòä</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-17 08:29:30 +0300 +0300'>March 17, 2024</span>&nbsp;¬∑&nbsp;2 min&nbsp;¬∑&nbsp;Dmytro Chumakov</footer>
  <a class="entry-link" aria-label="post link to The Flyweight Pattern" href="http://localhost:1313/posts/the-flyweight-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">The Chain Of Responsibility Pattern
    </h2>
  </header>
  <div class="entry-content">
    <p>What is a Chain Of Responsibility Pattern? The Chain Of Responsibility Pattern helps create a chain of objects to examine requests. Each object in turn examines a request and either handles it or passes onto the next object in the chain.
Source
What problems does it solve? The Chain Of Responsibility Pattern (CoR) helps solve following problems:
Dynamic Request Handling: It enables dynamic assignment of responsibilities at runtime. Handlers can be added, removed, or reordered without affecting the client‚Äôs code. This flexibility allows for easier maintenance and extension of the system. Decoupling Sender and Receiver: In traditional systems, a sender often needs to know the exact receiver of a request, leading to tight coupling between them. The CoR pattern decouples senders from receivers by allowing multiple objects to handle a request without the sender knowing the specific handler. Real-world code example // Protocol defining the handler interface protocol PurchaseHandler { var next: PurchaseHandler? { get set } func handleRequest(amount: Double) } // Concrete handlers class SmallPurchaseHandler: PurchaseHandler { var next: PurchaseHandler? let maxAmount: Double = 100.0 func handleRequest(amount: Double) { if amount &lt;= maxAmount { print(&#34;SmallPurchaseHandler: Purchase approved for $\(amount)&#34;) } else if let nextHandler = next { print(&#34;SmallPurchaseHandler: Passing request to next handler&#34;) nextHandler.handleRequest(amount: amount) } else { print(&#34;SmallPurchaseHandler: No handler available, purchase rejected&#34;) } } } class MediumPurchaseHandler: PurchaseHandler { var next: PurchaseHandler? let maxAmount: Double = 500.0 func handleRequest(amount: Double) { if amount &lt;= maxAmount { print(&#34;MediumPurchaseHandler: Purchase approved for $\(amount)&#34;) } else if let nextHandler = next { print(&#34;MediumPurchaseHandler: Passing request to next handler&#34;) nextHandler.handleRequest(amount: amount) } else { print(&#34;MediumPurchaseHandler: No handler available, purchase rejected&#34;) } } } class LargePurchaseHandler: PurchaseHandler { var next: PurchaseHandler? func handleRequest(amount: Double) { print(&#34;LargePurchaseHandler: Purchase approved for $\(amount)&#34;) } } // Usage func main() { let smallHandler = SmallPurchaseHandler() let mediumHandler = MediumPurchaseHandler() let largeHandler = LargePurchaseHandler() // Connecting handlers into a chain smallHandler.next = mediumHandler mediumHandler.next = largeHandler smallHandler.handleRequest(amount: 50.0) smallHandler.handleRequest(amount: 200.0) smallHandler.handleRequest(amount: 1000.0) } Thank you for reading! üòä</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-15 08:29:30 +0300 +0300'>March 15, 2024</span>&nbsp;¬∑&nbsp;2 min&nbsp;¬∑&nbsp;Dmytro Chumakov</footer>
  <a class="entry-link" aria-label="post link to The Chain Of Responsibility Pattern" href="http://localhost:1313/posts/the-chain-of-responsibility-pattern/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/page/31/">
      ¬´&nbsp;Prev&nbsp;31/35
    </a>
    <a class="next" href="http://localhost:1313/page/33/">Next&nbsp;33/35&nbsp;¬ª
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Dmytro&#39;s Blog</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><script>
    
    
    let b = document.querySelector("#menu-trigger")
    let m = document.querySelector(".menu")
    b.addEventListener("click", function () {
        m.classList.toggle("hidden")
    });
    
    document.body.addEventListener('click', function (event) {
        if (!b.contains(event.target)) {
            m.classList.add("hidden")
        }
    });
    
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
