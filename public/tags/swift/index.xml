<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Swift on Dmytro&#39;s Blog</title>
    <link>http://localhost:1313/tags/swift/</link>
    <description>Recent content in Swift on Dmytro&#39;s Blog</description>
    <image>
      <title>Dmytro&#39;s Blog</title>
      <url>http://localhost:1313/images/papermod-cover.png</url>
      <link>http://localhost:1313/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.123.3</generator>
    <language>en</language>
    <lastBuildDate>Fri, 20 Sep 2024 07:15:17 +0300</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/swift/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DSA - Queue</title>
      <link>http://localhost:1313/posts/dsa-queue/</link>
      <pubDate>Fri, 20 Sep 2024 07:15:17 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-queue/</guid>
      <description>What is a Queue? A Queue is an abstract data type that serves as an ordered collection of elements.
A simple queue typically has several operations:
push(item) - adds an item to the tail pop() - removes and returns an item from the head These operations make a queue a FIFO (First In, First Out) data structure.
Implementation There are two ways to implement a queue.
The first and simplest (but less efficient) way is by using an array and basic operations:</description>
    </item>
    <item>
      <title>DSA - Adjacency List</title>
      <link>http://localhost:1313/posts/dsa-adjacency-list/</link>
      <pubDate>Tue, 17 Sep 2024 07:06:52 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-adjacency-list/</guid>
      <description>What is an Adjacency List? An Adjacency List helps store a list of connections between each vertex in a finite graph.
Vertex Connects with 0 1 1 0, 2, 3 2 1, 3 3 1, 2 Implementation The addEdge method takes vertices as input and adds an edge to the adjacency list. In this example, the adjacency list is represented as a dictionary that maps vertices to a set of all connected vertices.</description>
    </item>
    <item>
      <title>DSA - Graph</title>
      <link>http://localhost:1313/posts/dsa-graph/</link>
      <pubDate>Sat, 14 Sep 2024 06:57:03 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-graph/</guid>
      <description>What is a graph? A graph is an abstract data type that represents vertices and edges that connect those vertices.
Source
Implementation A graph can be represented as a matrix with edges connecting each pair of vertices. For example, a graph with vertices 0, 1, 2, 3, 4 and edges between them can be represented as a matrix:
0 1 2 3 4 0 false true false false true 1 true false true true true 2 false true false true false 3 false true true false true 4 true true false true false In Swift, you can use a list of lists (2D array) to represent the matrix:</description>
    </item>
    <item>
      <title>DSA - Breadth First Search</title>
      <link>http://localhost:1313/posts/dsa-breadth-first-search/</link>
      <pubDate>Thu, 12 Sep 2024 07:14:47 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-breadth-first-search/</guid>
      <description>What is Breadth First Search? Breadth-first search (BFS) is an algorithm for traversing tree or graph data structures. It starts at the root and explores all the neighboring nodes at the current depth before moving on to nodes at the next depth level.
Source
Implementation The implementation of BFS may vary depending on the problem. The main idea of BFS is:
It has a visited array that collects all elements that have already been visited.</description>
    </item>
    <item>
      <title>DSA - Backtracking</title>
      <link>http://localhost:1313/posts/dsa-backtracking/</link>
      <pubDate>Mon, 09 Sep 2024 07:19:46 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-backtracking/</guid>
      <description>What is Backtracking? Backtracking is a class of algorithms for finding solutions to complex problems. A backtracking algorithm uses recursion and is based on depth-first search (DFS).
Depth First Search (DFS) Depth First Search (DFS) is an essential part of backtracking. DFS is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (or an arbitrary node in the case of a graph) and explores as far as possible along each branch before backtracking.</description>
    </item>
    <item>
      <title>DSA - Trie</title>
      <link>http://localhost:1313/posts/dsa-trie/</link>
      <pubDate>Fri, 06 Sep 2024 06:56:18 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-trie/</guid>
      <description>What is a Trie? A Trie is a data structure usually called a &amp;ldquo;prefix tree,&amp;rdquo; often represented as a nested tree of dictionaries where each key is a character that maps to the next character in a word.
Let&amp;rsquo;s look at some examples of a Trie. The Trie consists of two main classes: the TrieNode class and the Trie class.
TrieNode The TrieNode class has two properties:
children - a property that represents all characters in a given word and points to the next character.</description>
    </item>
    <item>
      <title>DSA - Binary Search Tree</title>
      <link>http://localhost:1313/posts/dsa-binary-search-tree/</link>
      <pubDate>Mon, 02 Sep 2024 07:12:55 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-binary-search-tree/</guid>
      <description>What is a Tree? A Tree is a data structure that has a root and subtrees of children, representing a set of linked nodes. Trees behave similarly to a LinkedList in that they have a collection of nodes starting with a head (root). The main difference is that Trees can have multiple children, whereas a LinkedList, on the other hand, can have only one next child.
I’m going to focus on a commonly used type of tree, the Binary Search Tree.</description>
    </item>
    <item>
      <title>DSA - Sliding Window</title>
      <link>http://localhost:1313/posts/dsa-sliding-window/</link>
      <pubDate>Wed, 28 Aug 2024 07:20:26 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-sliding-window/</guid>
      <description>What is the sliding window technique? The sliding window technique is a common algorithmic approach used to create a fixed-sized window that moves through the data one step at a time, typically from left to right, to perform specific operations or computations on the elements within the window.
What is the sliding window algorithm? The sliding window algorithm is a method for finding a subset of elements that satisfy certain conditions in a given problem.</description>
    </item>
    <item>
      <title>DSA - Linked List</title>
      <link>http://localhost:1313/posts/dsa-linked-list/</link>
      <pubDate>Tue, 27 Aug 2024 07:13:19 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-linked-list/</guid>
      <description>What is a Linked List? A linked list is a common data structure that is similar to an array, but its order is based on pointers to the next element in memory instead of using physical placement (indices).
A linked list has two main components:
ListNode class: This class has a val property that represents the value and a next property that represents a pointer to the next element in memory.</description>
    </item>
    <item>
      <title>DSA - Binary Search</title>
      <link>http://localhost:1313/posts/dsa-binary-search/</link>
      <pubDate>Mon, 26 Aug 2024 07:09:48 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-binary-search/</guid>
      <description>What is binary search? Binary search is an algorithm that helps find an element in a sorted array in O(log n) time.
Why should the input be sorted before performing binary search? The input array for binary search needs to be sorted because the algorithm eliminates half of the choices at each step. If the guessed value is greater than the target value, it knows that the right part can’t contain the target value.</description>
    </item>
    <item>
      <title>DSA - Stack</title>
      <link>http://localhost:1313/posts/dsa-stack/</link>
      <pubDate>Tue, 20 Aug 2024 07:17:01 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-stack/</guid>
      <description>What is a Stack? A stack is an abstract data type that serves as a collection of elements and implements operations like push, pop, and peek at the end in O(1) time. It uses the LIFO (last in, first out) order. For example, a stack can be a collection of items where adding or removing is practical at the top.
Code Example struct Stack&amp;lt;Element&amp;gt; { private var array: [Element] init(array: [Element] = []) { self.</description>
    </item>
    <item>
      <title>DSA - Two Pointers Technique</title>
      <link>http://localhost:1313/posts/dsa-two-pointers-technique/</link>
      <pubDate>Sat, 17 Aug 2024 07:00:23 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-two-pointers-technique/</guid>
      <description>What is the Two Pointers Technique? The two pointers technique helps track indices in a collection of elements to access objects in memory by index with O(1) space. This technique is very handy when you need to optimize the time and space of a solution.
What Problems Does It Solve? The two pointers technique solves problems involving collections. For example, it is useful when you need to compare each element to other elements in that collection.</description>
    </item>
    <item>
      <title>DSA - Merge Sorted Array Problem</title>
      <link>http://localhost:1313/posts/dsa-merge-sorted-array-problem/</link>
      <pubDate>Thu, 15 Aug 2024 07:04:16 +0300</pubDate>
      <guid>http://localhost:1313/posts/dsa-merge-sorted-array-problem/</guid>
      <description>Introduction In the previous chapter, we discussed Data Structures and Algorithms, delved into an overview of Dynamic Arrays, and solved the &amp;ldquo;Remove Element&amp;rdquo; problem.
In this article, I&amp;rsquo;m going to show one of the ways to solve the 88. Merge Sorted Array problem.
Problem You are given two integer arrays, nums1 and nums2, sorted in non-decreasing order, and two integers, m and n, representing the number of elements in nums1 and nums2, respectively.</description>
    </item>
    <item>
      <title>Data Structures and Algorithms Arrays Swift</title>
      <link>http://localhost:1313/posts/data-structures-and-algorithms-arrays-swift/</link>
      <pubDate>Mon, 12 Aug 2024 07:01:34 +0300</pubDate>
      <guid>http://localhost:1313/posts/data-structures-and-algorithms-arrays-swift/</guid>
      <description>Introduction I’ve always been curious about data structures and algorithms, and how they can improve user experiences while saving money for businesses through optimized computations.
In this series of articles, I’m going to solve LeetCode problems and share my approach with you.
I’ve just started my journey in solving LeetCode problems, so my solutions might not be as efficient as they could be, but I’m always looking for improvement.
Before each topic, I’ll provide a brief introduction to the data structure, algorithm, or technique I’ll be using to solve a specific problem.</description>
    </item>
    <item>
      <title>Implementing HealthKit in an iOS App</title>
      <link>http://localhost:1313/posts/implementing-healthkit-in-an-ios-app/</link>
      <pubDate>Fri, 26 Jul 2024 07:18:58 +0300</pubDate>
      <guid>http://localhost:1313/posts/implementing-healthkit-in-an-ios-app/</guid>
      <description>Introduction Previously, I worked with a healthcare app that used the HealthKit framework, but I did not get the opportunity to implement it myself. I decided to look into it and share what I found. In this article, I will focus on the steps to integrate HealthKit, write, and access its data.
Preparation Before we dive into implementation, I assume that you have an active Apple Developer account; without it, you will not be able to access the HealthKit Store.</description>
    </item>
    <item>
      <title>Implementing Location Service</title>
      <link>http://localhost:1313/posts/implementing-location-service/</link>
      <pubDate>Tue, 23 Jul 2024 07:04:25 +0300</pubDate>
      <guid>http://localhost:1313/posts/implementing-location-service/</guid>
      <description>Introduction Nowadays, location is an essential feature in almost every application. It&amp;rsquo;s very important to know the best ways to implement it without affecting performance and user experience. In this article, I will focus on how to implement general methods in location service.
Preparation Before we begin, let&amp;rsquo;s add location permission keys to Info.plist:
Privacy - Location When In Use Usage Description Privacy - Location Always and When In Use Usage Description First Step The first step is to create LocationService with the requestPermissions method to be able to receive location events.</description>
    </item>
    <item>
      <title>Implementing ChatGPT in an iOS App</title>
      <link>http://localhost:1313/posts/implementing-chatgpt-in-an-ios-app/</link>
      <pubDate>Sun, 21 Jul 2024 07:25:28 +0300</pubDate>
      <guid>http://localhost:1313/posts/implementing-chatgpt-in-an-ios-app/</guid>
      <description>Introduction I haven&amp;rsquo;t had the opportunity to build a chatbot before. This topic was trending some time ago, and I always wanted to implement it myself. In this article, I will focus on the steps you need to know to successfully build and run a chatbot application.
First Step The first step is to add the OpenAI dependency to your project:
.package(url: &amp;#34;https://github.com/MacPaw/OpenAI.git&amp;#34;, branch: &amp;#34;main&amp;#34;) dependencies: [ .byNameItem( name: &amp;#34;OpenAI&amp;#34;, condition: .</description>
    </item>
    <item>
      <title>Implementing Apple Sign-In to an iOS App</title>
      <link>http://localhost:1313/posts/implementing-apple-sign-in-to-an-ios-app/</link>
      <pubDate>Thu, 18 Jul 2024 07:26:13 +0300</pubDate>
      <guid>http://localhost:1313/posts/implementing-apple-sign-in-to-an-ios-app/</guid>
      <description>Introduction The Apple Sign-In feature is very helpful and offers users login functionality with one click. It could be highly beneficial from a business perspective to attract more potential customers by providing easy and secure access to application functionality. In this article, I will focus on how to implement Apple Sign-In.
Before implementation, let’s set up the necessary options to be able to run the app without errors.
Add Sign in with Apple Capability to the project &amp;#x1f4dd; Before testing on the simulator, you need to be signed in to an account with enabled two-factor authentication.</description>
    </item>
    <item>
      <title>Implementing gRPC Swift</title>
      <link>http://localhost:1313/posts/implementing-grpc-swift/</link>
      <pubDate>Tue, 16 Jul 2024 07:16:41 +0300</pubDate>
      <guid>http://localhost:1313/posts/implementing-grpc-swift/</guid>
      <description>Introduction I&amp;rsquo;ve never had the chance to use this technology before. I&amp;rsquo;ve always wondered how gRPC operates. In this article, I will explore what gRPC is, how to install and use it, and when to use gRPC.
What is gRPC? gRPC is an open-source, high-performance framework that facilitates efficient communication in distributed systems. gRPC is an implementation of the RPC (Remote Procedure Call) protocol, which enables services to call functions on other machines as if they were local software methods.</description>
    </item>
    <item>
      <title>Scanning NFC tags using CoreNFC in an iOS app</title>
      <link>http://localhost:1313/posts/scanning-nfc-tags-using-corenfc-in-an-ios-app/</link>
      <pubDate>Fri, 12 Jul 2024 07:27:51 +0300</pubDate>
      <guid>http://localhost:1313/posts/scanning-nfc-tags-using-corenfc-in-an-ios-app/</guid>
      <description>Introduction I never had a chance to work with NFC (Near Field Communication), but I have always been curious to find out how it works. In this article, I will focus on scanning NFC tags using CoreNFC with NFCNDEFReaderSession.
Preparation Before we begin, let&amp;rsquo;s add the necessary objects:
Near Field Communication Tag Reading capability to the project. Privacy - NFC Scan Usage Description key to Info.plist. Near Field Communication Tag Reader Session Formats to the entitlements file.</description>
    </item>
    <item>
      <title>Scanning for peripheral devices using BLE in an iOS app</title>
      <link>http://localhost:1313/posts/scanning-for-peripheral-devices-using-ble-in-an-ios-app/</link>
      <pubDate>Wed, 10 Jul 2024 07:27:14 +0300</pubDate>
      <guid>http://localhost:1313/posts/scanning-for-peripheral-devices-using-ble-in-an-ios-app/</guid>
      <description>Introduction I had the chance to work on a project where communication via BLE was at the heart of the project.
Before adding any code to application, I always asked myself about two scenarios:
The first scenario is when the device acts as a central device while searching for and connecting to peripheral devices. The second scenario is when the device acts as a peripheral device by using CBCharacteristic and changes its value.</description>
    </item>
    <item>
      <title>Creating a 2D Space Game for iOS Using SpriteKit - Part 2</title>
      <link>http://localhost:1313/posts/creating-2d-space-game-for-ios-using-spritekit-part-2/</link>
      <pubDate>Wed, 03 Jul 2024 06:39:04 +0300</pubDate>
      <guid>http://localhost:1313/posts/creating-2d-space-game-for-ios-using-spritekit-part-2/</guid>
      <description>Introduction In the previous chapter, I started talking about the video game creation process, from project setup to adding the background. Now, I&amp;rsquo;m going to add the player and physics to it.
You can download the project here.
First Step The first step is to initialize player using SKSpriteNode, set up player.position, and add player as a child node.
SKSpriteNode - is an onscreen graphical element that can be initialized from an image or a solid color.</description>
    </item>
    <item>
      <title>Creating a 2D Space Game for iOS Using SpriteKit - Part 1</title>
      <link>http://localhost:1313/posts/creating-2d-space-game-for-ios-using-spritekit-part-1/</link>
      <pubDate>Fri, 28 Jun 2024 07:18:59 +0300</pubDate>
      <guid>http://localhost:1313/posts/creating-2d-space-game-for-ios-using-spritekit-part-1/</guid>
      <description>Introduction I have never tried creating a game before; it feels like magic to me. I know that games have an enormous amount of underlying layers of abstractions and tools such as game engines, rendering, and so on. I have always been eager to learn at least 1% of the game creation process. In this article, I&amp;rsquo;m going to explore step-by-step instructions for creating a game for the iOS platform using SpriteKit.</description>
    </item>
    <item>
      <title>Combine practical usage examples</title>
      <link>http://localhost:1313/posts/combine-practical-usage-examples/</link>
      <pubDate>Sat, 22 Jun 2024 07:13:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/combine-practical-usage-examples/</guid>
      <description>Introduction When working in a large codebase with a significant number of async events, I often found myself in situations where I couldn&amp;rsquo;t combine events effectively. This resulted in optimization problems and inefficient consumption of OS resources.
The codebase contained closures and async/await, so it wasn&amp;rsquo;t possible to use operators like merge or combineLatest. After discovering this limitation, I decided to add new methods using Combine.
I will be demonstrating this with a simple NetworkService responsible only for executing and validating requests using Combine.</description>
    </item>
    <item>
      <title>The Memento Pattern</title>
      <link>http://localhost:1313/posts/the-memento-pattern/</link>
      <pubDate>Fri, 22 Mar 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/the-memento-pattern/</guid>
      <description>What is a Memento Pattern? The Memento Pattern helps return an object to one of its previous states; for instance, if the user requests an “undo” operation.
Source
What problems does it solve? The Memento Pattern helps solve following problems:
Undo/Redo Functionality: Memento allows you to capture an object’s state at a specific point in time and store it externally. This enables you to implement undo/redo functionality by restoring the object to its previous state.</description>
    </item>
    <item>
      <title>The Interpreter Pattern</title>
      <link>http://localhost:1313/posts/the-interpreter-pattern/</link>
      <pubDate>Mon, 18 Mar 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/the-interpreter-pattern/</guid>
      <description>What is an Interpreter Pattern? The Interpreter Pattern helps implement a simple language and defines a class based representation for its grammar along with an interpreter to interpret its sentences.
Source
What problems does it solve? The Interpreter Pattern helps solve following problems:
Language Interpretation: When you have a language or syntax that needs to be interpreted, such as mathematical expressions, regular expressions, or domain-specific languages (DSLs), the Interpreter Pattern helps in implementing the logic to interpret and execute these expressions.</description>
    </item>
    <item>
      <title>The Flyweight Pattern</title>
      <link>http://localhost:1313/posts/the-flyweight-pattern/</link>
      <pubDate>Sun, 17 Mar 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/the-flyweight-pattern/</guid>
      <description>What is a Flyweight Pattern? The Flyweight Pattern refers to an object that minimizes memory usage by sharing some of its data with other similar objects.
Source
What problems does it solve? The Flyweight Pattern helps solve following problems:
Large Memory Footprint: When dealing with a large number of objects, especially if these objects share a significant amount of common state, traditional object creation can lead to excessive memory consumption. The Flyweight Pattern reduces memory usage by sharing this common state among multiple objects.</description>
    </item>
    <item>
      <title>The Chain Of Responsibility Pattern</title>
      <link>http://localhost:1313/posts/the-chain-of-responsibility-pattern/</link>
      <pubDate>Fri, 15 Mar 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/the-chain-of-responsibility-pattern/</guid>
      <description>What is a Chain Of Responsibility Pattern? The Chain Of Responsibility Pattern helps create a chain of objects to examine requests. Each object in turn examines a request and either handles it or passes onto the next object in the chain.
Source
What problems does it solve? The Chain Of Responsibility Pattern (CoR) helps solve following problems:
Dynamic Request Handling: It enables dynamic assignment of responsibilities at runtime. Handlers can be added, removed, or reordered without affecting the client’s code.</description>
    </item>
    <item>
      <title>The State Pattern</title>
      <link>http://localhost:1313/posts/the-state-pattern/</link>
      <pubDate>Sun, 10 Mar 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/the-state-pattern/</guid>
      <description>What is a State Pattern? The State Pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.
Source
What problems does it solve? Complex conditional logic: When an object’s behavior depends on its internal state, it often leads to complex conditional statements. The State pattern simplifies this by encapsulating each state and its behavior in separate classes, making the code more readable and maintainable.</description>
    </item>
    <item>
      <title>The Dependency Inversion Principle</title>
      <link>http://localhost:1313/posts/the-dependency-inversion-principle/</link>
      <pubDate>Tue, 05 Mar 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/the-dependency-inversion-principle/</guid>
      <description>What is a Dependency Inversion Principle? The Dependency Inversion Principle means that high-level modules should not depend on low-level modules.
Source
Source
What problems does it solve? The Dependency Inversion Principle (DIP) helps solve:
Rigidity Fragility Immobility problems Real-world code example Violation of DIP // High-level module directly depending on low-level modules class MessageService { func sendMessageViaEmail(message: String) { let emailSender = EmailSender() emailSender.sendMessage(message: message) } func sendMessageViaSMS(message: String) { let smsSender = SMSSender() smsSender.</description>
    </item>
    <item>
      <title>Modern Concurrency</title>
      <link>http://localhost:1313/posts/modern-concurrency/</link>
      <pubDate>Sun, 04 Feb 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/modern-concurrency/</guid>
      <description>When was it introduced? It was introduced in Swift 5.5 at WWDC 2021.
You can find the more comprehensive info about Modern Concurrency in Swift Concurrency Manifesto.
What are actors? Actors eliminate shared mutable state and explicit synchronization through deep copying of all the data that passed to an actor to a message sent and preventing direct access to actor state. Actors are reference types.
actor DatabaseManager { private var data: [String: String] = [:] func readData(key: String) -&amp;gt; String?</description>
    </item>
    <item>
      <title>What are Threads in Swift?</title>
      <link>http://localhost:1313/posts/what-are-threads-in-swift/</link>
      <pubDate>Sat, 20 Jan 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/what-are-threads-in-swift/</guid>
      <description>What is the Thread? A Thread is a small set of instructions that can be executed independently from the main program. Threads are often used to improve program performance by allowing multiple tasks to be executed at the same time. The Thread has its own stack, registers, and program counters.
Threads share memory address space, and it is possible to communicate between Threads using shared memory space. How to use it?</description>
    </item>
    <item>
      <title>DispatchGroup in Swift</title>
      <link>http://localhost:1313/posts/dispatchgroup-in-swift/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/dispatchgroup-in-swift/</guid>
      <description>What is DispatchGroup? DispatchGroup provides a mechanism to track the completion group of tasks.
How DispatchGroup works? DispatchGroup has three main methods, enter, leave and notify, that allow you to control the completion of a specific task.
let dispatchGroup = DispatchGroup() dispatchGroup.enter() dispatchGroup.leave() dispatchGroup.notify(queue: .main) {} Let`s talk about each of these methods. enter — manually indicate a block has entered group. leave — manually indicate a block in the group has been completed.</description>
    </item>
    <item>
      <title>Concurrency in Swift</title>
      <link>http://localhost:1313/posts/concurrency-in-swift/</link>
      <pubDate>Sun, 07 Jan 2024 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/concurrency-in-swift/</guid>
      <description>What is concurrency? The system can perform multiple tasks simultaneously. By tasks, I mean code or instructions. Modern computer chips have multiple cores that allow developers to create and run various tasks on multiple cores. Even if your chip has one core operating system it will provide context switching mechanism by enabling it to execute multiple tasks concurrently.
Material about processes, threads I will skip explaining concepts about processes and threads because it is a vast topic, and it will take a lot of time to explain it.</description>
    </item>
    <item>
      <title>What are value types in Swift?</title>
      <link>http://localhost:1313/posts/what-are-value-types-in-swift/</link>
      <pubDate>Thu, 28 Dec 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/what-are-value-types-in-swift/</guid>
      <description>What are value types? Value types play a central role in programming languages by grouping data values.
`Value type” is a type of data copied when assigned to a new variable.
struct Storage { var data: String = &amp;#34;some data&amp;#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` How can you pass value types? You can pass value type by copying value.
struct Storage { var data: String = &amp;#34;some data&amp;#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` copiedStorage.</description>
    </item>
    <item>
      <title>How to prevent memory leaks?</title>
      <link>http://localhost:1313/posts/how-to-prevent-memory-leaks/</link>
      <pubDate>Sun, 24 Dec 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/how-to-prevent-memory-leaks/</guid>
      <description>I was searching for tools that could help me find memory leaks faster and would be simple in implementation without affecting performance and memory size of application.
I found a fantastic fit for this task LifetimeTracker developed by Krzysztof Zabłocki.
All you need is to add LifetimeTracker package to the project, inherit from LifetimeTrackable protocol, and add two lines of code.
class Department: LifetimeTrackable {} trackLifetime method to init of instance that you are going to verify, and lifetimeConfiguration property where you set max number of valid instances.</description>
    </item>
    <item>
      <title>How to find memory leaks?</title>
      <link>http://localhost:1313/posts/how-to-find-memory-leaks/</link>
      <pubDate>Wed, 20 Dec 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/how-to-find-memory-leaks/</guid>
      <description>The common way to find memory leaks is by using Xcode Instruments. All you need is the following:
Open Xcode Instruments
Choose Leaks option Select Simulator where you are going to test your application Select your installed application When you finish preparation, you can start immediate recoding and check application for leaks. To do that, you need to open Simulator and try some cases that could cause memory leaks.
After you spend some time trying different scenarios, you can see that Instruments found Leaked Objects.</description>
    </item>
    <item>
      <title>ARC in Swift</title>
      <link>http://localhost:1313/posts/arc-in-swift/</link>
      <pubDate>Sun, 17 Dec 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/arc-in-swift/</guid>
      <description>What is ARC? Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed. - Apple
ARC In Action In this example, we assign an instance to the reference1 property.</description>
    </item>
    <item>
      <title>What is closure in Swift language?</title>
      <link>http://localhost:1313/posts/what-is-closure-in-swift-language/</link>
      <pubDate>Sun, 10 Dec 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/what-is-closure-in-swift-language/</guid>
      <description>Introduction In this article, I’m going to briefly explain what closure is.
Closures is self-conitained blocks of funcionality that can be passed around and used in your code. — Apple
Expression:
{ (params) -&amp;gt; return value in statements } @escaping When closure is marked as escaping, it will outlive or leave the scope you passed.
func response(_ completionHandler: @escaping(Result) -&amp;gt; Void) { completionHandler(.success) } @nonescaping By default, closures are nonescaping, meaning closure will no longer exist in memory after complete execution in the scope you have passed it to.</description>
    </item>
    <item>
      <title>What is “reference type” in Swift?</title>
      <link>http://localhost:1313/posts/what-is-reference-type-in-swift/</link>
      <pubDate>Sun, 03 Dec 2023 00:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/what-is-reference-type-in-swift/</guid>
      <description>Introduction In Swift, classes, closures, and actors all reference types.
&amp;lsquo;Reference type’ is instance that shares a single copy of data.
Assigning a reference type to a constant or variable, or passing it into a function or method, it is always a reference to a shared instance that is assigned or passed in.
Example You can pass your property value by sharing the same address in memory.
// Reference type example class Storage { var data = “data-example” } var storage = Storage() print(&amp;#34;\(storage.</description>
    </item>
  </channel>
</rss>
