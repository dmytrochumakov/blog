<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Combine on Dmytro&#39;s Blog</title>
    <link>http://localhost:1313/tags/combine/</link>
    <description>Recent content in Combine on Dmytro&#39;s Blog</description>
    <image>
      <title>Dmytro&#39;s Blog</title>
      <url>http://localhost:1313/images/papermod-cover.png</url>
      <link>http://localhost:1313/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.123.3</generator>
    <language>en</language>
    <lastBuildDate>Sun, 21 Jul 2024 07:25:28 +0300</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/combine/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Implementing ChatGPT in an iOS App</title>
      <link>http://localhost:1313/posts/implementing-chatgpt-in-an-ios-app/</link>
      <pubDate>Sun, 21 Jul 2024 07:25:28 +0300</pubDate>
      <guid>http://localhost:1313/posts/implementing-chatgpt-in-an-ios-app/</guid>
      <description>Implementing ChatGPT in an iOS App Introduction I haven&amp;rsquo;t had the opportunity to build a chatbot before. This topic was trending some time ago, and I always wanted to implement it myself. In this article, I will focus on the steps you need to know to successfully build and run a chatbot application.
First Step The first step is to add the OpenAI dependency to your project:
.package(url: &amp;#34;https://github.com/MacPaw/OpenAI.git&amp;#34;, branch: &amp;#34;main&amp;#34;) dependencies: [ .</description>
    </item>
    <item>
      <title>Combine practical usage examples</title>
      <link>http://localhost:1313/posts/combine-practical-usage-examples/</link>
      <pubDate>Sat, 22 Jun 2024 07:13:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/combine-practical-usage-examples/</guid>
      <description>Introduction When working in a large codebase with a significant number of async events, I often found myself in situations where I couldn&amp;rsquo;t combine events effectively. This resulted in optimization problems and inefficient consumption of OS resources.
The codebase contained closures and async/await, so it wasn&amp;rsquo;t possible to use operators like merge or combineLatest. After discovering this limitation, I decided to add new methods using Combine.
I will be demonstrating this with a simple NetworkService responsible only for executing and validating requests using Combine.</description>
    </item>
    <item>
      <title>Combine â€” Basics</title>
      <link>http://localhost:1313/posts/combine-basics/</link>
      <pubDate>Wed, 07 Feb 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/combine-basics/</guid>
      <description>What is Combine? Combine Framework provides an API for processing async events over time such as user-input, network response, and other dynamic data.
What is the purpose of Combine? The purpose of Combine is to simplify the management of async events and data streams.
Publishers Publisher declares that a type can transit a sequence of values over time. A publisher delivers elements to one or more Subscriber instances.
class PostService { func fetchPosts() -&amp;gt; AnyPublisher&amp;lt;[Post], Error&amp;gt; { guard let url = URL(string: &amp;#34;https://jsonplaceholder.</description>
    </item>
  </channel>
</rss>
