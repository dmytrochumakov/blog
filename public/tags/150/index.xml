<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>150 on Dmytro&#39;s Blog</title>
    <link>http://localhost:1313/tags/150/</link>
    <description>Recent content in 150 on Dmytro&#39;s Blog</description>
    <image>
      <title>Dmytro&#39;s Blog</title>
      <url>http://localhost:1313/images/papermod-cover.png</url>
      <link>http://localhost:1313/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.151.2</generator>
    <language>en</language>
    <lastBuildDate>Fri, 12 Dec 2025 07:55:47 +0300</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/150/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode - 150 - Reconstruct Itinerary</title>
      <link>http://localhost:1313/posts/leetcode-150-reconstruct-itinerary/</link>
      <pubDate>Fri, 12 Dec 2025 07:55:47 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-reconstruct-itinerary/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given a list of airline &lt;code&gt;tickets&lt;/code&gt; where &lt;code&gt;tickets[i] = [from_i, to_i]&lt;/code&gt; represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.&lt;/p&gt;
&lt;p&gt;All of the tickets belong to a man who departs from &lt;code&gt;&amp;quot;JFK&amp;quot;&lt;/code&gt;, thus, the itinerary must begin with &lt;code&gt;&amp;quot;JFK&amp;quot;&lt;/code&gt;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Network Delay Time</title>
      <link>http://localhost:1313/posts/leetcode-150-network-delay-time/</link>
      <pubDate>Fri, 28 Nov 2025 09:02:09 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-network-delay-time/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given a network of &lt;code&gt;n&lt;/code&gt; nodes, labeled from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;. You are also given &lt;code&gt;times&lt;/code&gt;, a list of travel times as directed edges &lt;code&gt;times[i] = (ui, vi, wi)&lt;/code&gt;, where &lt;code&gt;ui&lt;/code&gt; is the source node, &lt;code&gt;vi&lt;/code&gt; is the target node, and &lt;code&gt;wi&lt;/code&gt; is the time it takes for a signal to travel from source to target.&lt;/p&gt;
&lt;p&gt;We will send a signal from a given node &lt;code&gt;k&lt;/code&gt;. Return the minimum time it takes for all the &lt;code&gt;n&lt;/code&gt; nodes to receive the signal. If it is impossible for all the &lt;code&gt;n&lt;/code&gt; nodes to receive the signal, return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Word Ladder</title>
      <link>http://localhost:1313/posts/leetcode-150-word-ladder/</link>
      <pubDate>Mon, 17 Nov 2025 07:48:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-word-ladder/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;A transformation sequence from word &lt;code&gt;beginWord&lt;/code&gt; to word &lt;code&gt;endWord&lt;/code&gt; using a dictionary &lt;code&gt;wordList&lt;/code&gt; is a sequence of words &lt;code&gt;beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; ... -&amp;gt; sk&lt;/code&gt; such that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every adjacent pair of words differs by a single letter.&lt;/li&gt;
&lt;li&gt;Every &lt;code&gt;si&lt;/code&gt; for &lt;code&gt;1 &amp;lt;= i &amp;lt;= k&lt;/code&gt; is in &lt;code&gt;wordList&lt;/code&gt;. Note that &lt;code&gt;beginWord&lt;/code&gt; does not need to be in &lt;code&gt;wordList&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sk&lt;/code&gt; == &lt;code&gt;endWord&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given two words, &lt;code&gt;beginWord&lt;/code&gt; and &lt;code&gt;endWord&lt;/code&gt;, and a dictionary &lt;code&gt;wordList&lt;/code&gt;, return the number of words in the shortest transformation sequence from &lt;code&gt;beginWord&lt;/code&gt; to &lt;code&gt;endWord&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt; if no such sequence exists.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Redundant Connection</title>
      <link>http://localhost:1313/posts/leetcode-150-redundant-connection/</link>
      <pubDate>Wed, 05 Nov 2025 08:01:51 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-redundant-connection/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;In this problem, a tree is an undirected graph that is connected and has no cycles.&lt;/p&gt;
&lt;p&gt;You are given a graph that started as a tree with &lt;code&gt;n&lt;/code&gt; nodes labeled from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;, with one additional edge added. The added edge has two different vertices chosen from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;, and was not an edge that already existed. The graph is represented as an array &lt;code&gt;edges&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt; where &lt;code&gt;edges[i] = [ai, bi]&lt;/code&gt; indicates that there is an edge between nodes &lt;code&gt;ai&lt;/code&gt; and &lt;code&gt;bi&lt;/code&gt; in the graph.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Course Schedule II</title>
      <link>http://localhost:1313/posts/leetcode-150-course-schedule-ii/</link>
      <pubDate>Thu, 30 Oct 2025 07:52:44 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-course-schedule-ii/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;There are a total of &lt;code&gt;numCourses&lt;/code&gt; courses you have to take, labeled from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;numCourses - 1&lt;/code&gt;. You are given an array &lt;code&gt;prerequisites&lt;/code&gt; where &lt;code&gt;prerequisites[i] = [ai, bi]&lt;/code&gt; indicates that you must take course &lt;code&gt;bi&lt;/code&gt; first if you want to take course &lt;code&gt;ai&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For example, the pair &lt;code&gt;[0, 1]&lt;/code&gt; indicates that to take course &lt;code&gt;0&lt;/code&gt; you have to first take course &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Surrounded Regions</title>
      <link>http://localhost:1313/posts/leetcode-150-surrounded-regions/</link>
      <pubDate>Tue, 21 Oct 2025 07:58:33 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-surrounded-regions/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given an &lt;code&gt;m x n&lt;/code&gt; matrix &lt;code&gt;board&lt;/code&gt; containing letters &lt;code&gt;&#39;X&#39;&lt;/code&gt; and &lt;code&gt;&#39;O&#39;&lt;/code&gt;, capture regions that are surrounded:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Connect: A cell is connected to adjacent cells horizontally or vertically.&lt;/li&gt;
&lt;li&gt;Region: To form a region connect every &lt;code&gt;&#39;O&#39;&lt;/code&gt; cell.&lt;/li&gt;
&lt;li&gt;Surround: The region is surrounded with &lt;code&gt;&#39;X&#39;&lt;/code&gt; cells if you can connect the region with &lt;code&gt;&#39;X&#39;&lt;/code&gt; cells and none of the region cells are on the edge of the &lt;code&gt;board&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To capture a surrounded region, replace all &lt;code&gt;&#39;O&#39;&lt;/code&gt;s with &lt;code&gt;&#39;X&#39;&lt;/code&gt;s in-place within the original board. You do not need to return anything.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Rotting Oranges</title>
      <link>http://localhost:1313/posts/leetcode-150-rotting-oranges/</link>
      <pubDate>Fri, 17 Oct 2025 07:58:23 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-rotting-oranges/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given an &lt;code&gt;m x n grid&lt;/code&gt; where each cell can have one of three values:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; representing an empty cell,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; representing a fresh orange, or&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2&lt;/code&gt; representing a rotten orange.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.&lt;/p&gt;
&lt;p&gt;Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Walls and Gates</title>
      <link>http://localhost:1313/posts/leetcode-150-walls-and-gates/</link>
      <pubDate>Sat, 11 Oct 2025 08:04:42 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-walls-and-gates/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given an &lt;code&gt;m*n&lt;/code&gt; 2D &lt;code&gt;grid&lt;/code&gt; initialized with these three possible values:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-1&lt;/code&gt; - A wall or obstacle.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; - A gate.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INF&lt;/code&gt; - Infinity means an empty room. We use the value &lt;code&gt;2^31 - 1 = 2147483647&lt;/code&gt; to represent &lt;code&gt;INF&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Fill each empty room with the distance to its nearest gate. If it’s impossible to reach the gate, it should be filled with &lt;code&gt;INF&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Assume the grid can only be traversed up, down, left, or right.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Max Area of Island</title>
      <link>http://localhost:1313/posts/leetcode-150-max-area-of-island/</link>
      <pubDate>Mon, 06 Oct 2025 07:48:31 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-max-area-of-island/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given an &lt;code&gt;m x n&lt;/code&gt; binary matrix &lt;code&gt;grid&lt;/code&gt;. An island is a group of &lt;code&gt;1&lt;/code&gt;s (representing land) connected 4-directionally (horizontally or vertically). You may assume all four edges of the grid are surrounded by water.&lt;/p&gt;
&lt;p&gt;The area of an island is the number of cells with a value &lt;code&gt;1&lt;/code&gt; in the island.&lt;/p&gt;
&lt;p&gt;Return the maximum area of an island in &lt;code&gt;grid&lt;/code&gt;. If there is no island, return &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Reverse Nodes in k-Group</title>
      <link>http://localhost:1313/posts/leetcode-150-reverse-nodes-in-k-group/</link>
      <pubDate>Wed, 01 Oct 2025 08:03:59 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-reverse-nodes-in-k-group/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given the &lt;code&gt;head&lt;/code&gt; of a linked list, reverse the nodes of the list &lt;code&gt;k&lt;/code&gt; at a time, and return the modified list.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;k&lt;/code&gt; is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of &lt;code&gt;k&lt;/code&gt; then the left-out nodes at the end should remain as they are.&lt;/p&gt;
&lt;p&gt;You may not alter the values in the list&amp;rsquo;s nodes, only nodes themselves may be changed.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - N-Queens</title>
      <link>http://localhost:1313/posts/leetcode-150-n-queens/</link>
      <pubDate>Fri, 26 Sep 2025 08:01:26 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-n-queens/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing &lt;code&gt;n&lt;/code&gt; queens on an &lt;code&gt;n x n&lt;/code&gt; chessboard such that no two queens attack each other.&lt;/p&gt;
&lt;p&gt;Given an integer n, return all distinct solutions to the &lt;code&gt;n&lt;/code&gt;-queens puzzle. You may return the answer in any order.&lt;/p&gt;
&lt;p&gt;Each solution contains a distinct board configuration of the n-queens&amp;rsquo; placement, where &lt;code&gt;&#39;Q&#39;&lt;/code&gt; and &lt;code&gt;&#39;.&#39;&lt;/code&gt; both indicate a queen and an empty space, respectively.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Letter Combinations of a Phone Number</title>
      <link>http://localhost:1313/posts/leetcode-150-letter-combinations-of-a-phone-number/</link>
      <pubDate>Mon, 15 Sep 2025 07:36:50 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-letter-combinations-of-a-phone-number/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.&lt;/p&gt;
&lt;p&gt;A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.&lt;/p&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-2039f&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-2039f&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/1200px-telephone-keypad2svg.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: digits = &amp;#34;23&amp;#34;
Output: [&amp;#34;ad&amp;#34;,&amp;#34;ae&amp;#34;,&amp;#34;af&amp;#34;,&amp;#34;bd&amp;#34;,&amp;#34;be&amp;#34;,&amp;#34;bf&amp;#34;,&amp;#34;cd&amp;#34;,&amp;#34;ce&amp;#34;,&amp;#34;cf&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: digits = &amp;#34;&amp;#34;
Output: []
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: digits = &amp;#34;2&amp;#34;
Output: [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;0 &amp;lt;= digits.length &amp;lt;= 4&lt;/li&gt;
&lt;li&gt;digits[i] is a digit in the range [&amp;lsquo;2&amp;rsquo;, &amp;lsquo;9&amp;rsquo;]&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;From the description of the problem, we learn that we are given a string with digits from &lt;code&gt;2-9&lt;/code&gt; and we need to return all possible combinations that the number could represent.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Palindrome Partitioning</title>
      <link>http://localhost:1313/posts/leetcode-150-palindrome-partitioning/</link>
      <pubDate>Fri, 12 Sep 2025 07:46:17 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-palindrome-partitioning/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given a string &lt;code&gt;s&lt;/code&gt;, partition &lt;code&gt;s&lt;/code&gt; such that every substring of the partition is a palindrome. Return all possible palindrome partitionings of &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A substring is a contiguous non-empty sequence of characters within a string.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;A palindrome is a string that reads the same forward and backward.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: s = &amp;#34;aab&amp;#34;
Output: [[&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;],[&amp;#34;aa&amp;#34;,&amp;#34;b&amp;#34;]]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: s = &amp;#34;a&amp;#34;
Output: [[&amp;#34;a&amp;#34;]]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= s.length &amp;lt;= 16&lt;/li&gt;
&lt;li&gt;s contains only lowercase English letters.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;From the description of the problem we learn that we are given string &lt;code&gt;s&lt;/code&gt; that we need to partition in a way that all substrings are palindromes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Subsets II</title>
      <link>http://localhost:1313/posts/leetcode-150-subsets-ii/</link>
      <pubDate>Tue, 09 Sep 2025 07:18:32 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-subsets-ii/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt; that may contain duplicates, return all possible subsets (the power set).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A subset of an array is a selection of elements (possibly none) of the array.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The solution set must not contain duplicate subsets. Return the solution in any order.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [0]
Output: [[],[0]]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= nums.length &amp;lt;= 10&lt;/li&gt;
&lt;li&gt;-10 &amp;lt;= nums[i] &amp;lt;= 10&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;From the description of the problem we learn that we are given &lt;code&gt;nums&lt;/code&gt; that contains duplicate values and we need to return subsets without any duplicates.
Let&amp;rsquo;s look at an example with input &lt;code&gt;[1, 2, 2]&lt;/code&gt;

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-fa874&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-fa874&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/90.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;

From the given input:&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Permutations</title>
      <link>http://localhost:1313/posts/leetcode-150-permutations/</link>
      <pubDate>Sat, 06 Sep 2025 07:42:44 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-permutations/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an array &lt;code&gt;nums&lt;/code&gt; of distinct integers, return all the possible permutations. You can return the answer in any order.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A permutation is a rearrangement of all the elements of an array.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [0,1]
Output: [[0,1],[1,0]]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [1]
Output: [[1]]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= nums.length &amp;lt;= 6&lt;/li&gt;
&lt;li&gt;-10 &amp;lt;= nums[i] &amp;lt;= 10&lt;/li&gt;
&lt;li&gt;All the integers of nums are unique.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;From the description of the problem we learn that we need to return all possible permutations from an array of distinct integer values.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Combination Sum II</title>
      <link>http://localhost:1313/posts/leetcode-150-combination-sum-ii/</link>
      <pubDate>Tue, 02 Sep 2025 07:47:08 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-combination-sum-ii/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given a collection of candidate numbers (&lt;code&gt;candidates&lt;/code&gt;) and a target number (&lt;code&gt;target&lt;/code&gt;), find all unique combinations in &lt;code&gt;candidates&lt;/code&gt; where the candidate numbers sum to &lt;code&gt;target&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Each number in &lt;code&gt;candidates&lt;/code&gt; may only be used once in the combination.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The solution set must not contain duplicate combinations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: candidates = [2,5,2,1,2], target = 5
Output: 
[
[1,2,2],
[5]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= candidates.length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= candidates[i] &amp;lt;= 50&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= target &amp;lt;= 30&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;From the description of the problem, we learn that we are given an array of numbers &lt;code&gt;candidates&lt;/code&gt; and we want to find every combination that will sum to the given &lt;code&gt;target&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Subsets</title>
      <link>http://localhost:1313/posts/leetcode-150-subsets/</link>
      <pubDate>Wed, 27 Aug 2025 08:00:51 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-subsets/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt; of unique elements, return all possible subsets (the power set).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A subset of an array is a selection of elements (possibly none) of the array.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The solution set must not contain duplicate subsets. Return the solution in any order.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [0]
Output: [[],[0]]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= nums.length &amp;lt;= 10&lt;/li&gt;
&lt;li&gt;-10 &amp;lt;= nums[i] &amp;lt;= 10&lt;/li&gt;
&lt;li&gt;All the numbers of nums are unique.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;From the description of the problem we learn that we need to return every single subset that we can create from input &lt;code&gt;nums&lt;/code&gt;, without any duplicates.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Design Twitter</title>
      <link>http://localhost:1313/posts/leetcode-150-design-twitter/</link>
      <pubDate>Mon, 25 Aug 2025 07:54:06 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-design-twitter/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and are able to see the &lt;code&gt;10&lt;/code&gt; most recent tweets in the user&amp;rsquo;s news feed.&lt;/p&gt;
&lt;p&gt;Implement the &lt;code&gt;Twitter&lt;/code&gt; class:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Twitter()&lt;/code&gt; Initializes your Twitter object.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void postTweet(int userId, int tweetId)&lt;/code&gt; Composes a new tweet with ID &lt;code&gt;tweetId&lt;/code&gt; by the user &lt;code&gt;userId&lt;/code&gt;. Each call to this function will be made with a unique &lt;code&gt;tweetId&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; getNewsFeed(int userId)&lt;/code&gt; Retrieves the &lt;code&gt;10&lt;/code&gt; most recent tweet IDs in the user&amp;rsquo;s news feed. Each item in the news feed must be posted by users who the user followed or by the user themselves. Tweets must be ordered from most recent to least recent.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void follow(int followerId, int followeeId)&lt;/code&gt; The user with ID &lt;code&gt;followerId&lt;/code&gt; starts following the user with ID &lt;code&gt;followeeId&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void unfollow(int followerId, int followeeId)&lt;/code&gt; The user with ID &lt;code&gt;followerId&lt;/code&gt; stops following the user with ID &lt;code&gt;followeeId&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input
[&amp;#34;Twitter&amp;#34;, &amp;#34;postTweet&amp;#34;, &amp;#34;getNewsFeed&amp;#34;, &amp;#34;follow&amp;#34;, &amp;#34;postTweet&amp;#34;, &amp;#34;getNewsFeed&amp;#34;, &amp;#34;unfollow&amp;#34;, &amp;#34;getNewsFeed&amp;#34;]
[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]
Output
[null, null, [5], null, null, [6, 5], null, [5]]

Explanation
Twitter twitter = new Twitter();
twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).
twitter.getNewsFeed(1);  // User 1&amp;#39;s news feed should return a list with 1 tweet id -&amp;gt; [5]. return [5]
twitter.follow(1, 2);    // User 1 follows user 2.
twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).
twitter.getNewsFeed(1);  // User 1&amp;#39;s news feed should return a list with 2 tweet ids -&amp;gt; [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.
twitter.unfollow(1, 2);  // User 1 unfollows user 2.
twitter.getNewsFeed(1);  // User 1&amp;#39;s news feed should return a list with 1 tweet id -&amp;gt; [5], since user 1 is no longer following user 2.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= userId, followerId, followeeId &amp;lt;= 500&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= tweetId &amp;lt;= 10^4&lt;/li&gt;
&lt;li&gt;All the tweets have unique IDs.&lt;/li&gt;
&lt;li&gt;At most 3 * 10^4 calls will be made to postTweet, getNewsFeed, follow, and unfollow.&lt;/li&gt;
&lt;li&gt;A user cannot follow himself.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s start with the easy part of this problem that are &lt;code&gt;follow&lt;/code&gt; and &lt;code&gt;unfollow&lt;/code&gt; operations and move up as we go.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Task Scheduler</title>
      <link>http://localhost:1313/posts/leetcode-150-task-scheduler/</link>
      <pubDate>Tue, 19 Aug 2025 07:34:45 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-task-scheduler/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given an array of CPU &lt;code&gt;tasks&lt;/code&gt;, each labeled with a letter from A to Z, and a number &lt;code&gt;n&lt;/code&gt;. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there&amp;rsquo;s a constraint: there has to be a gap of at least &lt;code&gt;n&lt;/code&gt; intervals between two tasks with the same label.&lt;/p&gt;
&lt;p&gt;Return the minimum number of CPU intervals required to complete all tasks.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Kth Largest Element in an Array</title>
      <link>http://localhost:1313/posts/leetcode-150-kth-largest-element-in-an-array/</link>
      <pubDate>Fri, 15 Aug 2025 07:29:52 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-kth-largest-element-in-an-array/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt; and an integer &lt;code&gt;k&lt;/code&gt;, return the &lt;code&gt;kth&lt;/code&gt; largest element in the array.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that it is the &lt;code&gt;kth&lt;/code&gt; largest element in the sorted order, not the &lt;code&gt;kth&lt;/code&gt; distinct element.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Can you solve it without sorting?&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= k &amp;lt;= nums.length &amp;lt;= 10^5&lt;/li&gt;
&lt;li&gt;-10^4 &amp;lt;= nums[i] &amp;lt;= 10^4&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;From the description of the problem we learn that we need to find the &lt;code&gt;kth&lt;/code&gt; largest element from the given array. The &lt;code&gt;kth&lt;/code&gt; element means if, for example, we had &lt;code&gt;k = 1&lt;/code&gt; then we would return the &lt;code&gt;first&lt;/code&gt; largest element, or if we had &lt;code&gt;k = 3&lt;/code&gt; then we would return the &lt;code&gt;third&lt;/code&gt; largest element.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - K Closest Points to Origin</title>
      <link>http://localhost:1313/posts/leetcode-150-k-closest-points-to-origin/</link>
      <pubDate>Wed, 13 Aug 2025 07:45:42 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-k-closest-points-to-origin/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an array of &lt;code&gt;points&lt;/code&gt; where &lt;code&gt;points[i] = [xi, yi]&lt;/code&gt; represents a point on the X-Y plane and an integer &lt;code&gt;k&lt;/code&gt;, return the &lt;code&gt;k&lt;/code&gt; closest points to the origin &lt;code&gt;(0, 0)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The distance between two points on the X-Y plane is the Euclidean distance (i.e., &lt;code&gt;√(x1 - x2)^2 + (y1 - y2)^2&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Last Stone Weight</title>
      <link>http://localhost:1313/posts/leetcode-150-last-stone-weight/</link>
      <pubDate>Mon, 11 Aug 2025 07:25:28 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-last-stone-weight/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given an array of integers &lt;code&gt;stones&lt;/code&gt; where &lt;code&gt;stones[i]&lt;/code&gt; is the weight of the &lt;code&gt;ith&lt;/code&gt; stone.&lt;/p&gt;
&lt;p&gt;We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; with &lt;code&gt;x &amp;lt;= y&lt;/code&gt;. The result of this smash is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If &lt;code&gt;x == y&lt;/code&gt;, both stones are destroyed, and&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;x != y&lt;/code&gt;, the stone of weight &lt;code&gt;x&lt;/code&gt; is destroyed, and the stone of weight &lt;code&gt;y&lt;/code&gt; has new weight &lt;code&gt;y - x&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At the end of the game, there is at most one stone left.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Kth Largest Element in a Stream</title>
      <link>http://localhost:1313/posts/leetcode-150-kth-largest-element-in-a-stream/</link>
      <pubDate>Sat, 09 Aug 2025 07:41:18 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-kth-largest-element-in-a-stream/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are part of a university admissions office and need to keep track of the &lt;code&gt;kth&lt;/code&gt; highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.&lt;/p&gt;
&lt;p&gt;You are tasked to implement a class which, for a given integer &lt;code&gt;k&lt;/code&gt;, maintains a stream of test scores and continuously returns the &lt;code&gt;kth&lt;/code&gt; highest test score after a new score has been submitted. More specifically, we are looking for the &lt;code&gt;kth&lt;/code&gt; highest score in the sorted list of all scores.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Count Good Nodes in Binary Tree</title>
      <link>http://localhost:1313/posts/leetcode-150-count-good-nodes-in-binary-tree/</link>
      <pubDate>Thu, 07 Aug 2025 07:55:32 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-count-good-nodes-in-binary-tree/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given a binary tree &lt;code&gt;root&lt;/code&gt;, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.&lt;/p&gt;
&lt;p&gt;Return the number of good nodes in the binary tree.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-b588c&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-b588c&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/test_sample_1.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: root = [3,1,4,3,null,1,5]  
Output: 4  
Explanation: Nodes in blue are good.  
Root Node (3) is always a good node.  
Node 4 -&amp;gt; (3,4) is the maximum value in the path starting from the root.  
Node 5 -&amp;gt; (3,4,5) is the maximum value in the path  
Node 3 -&amp;gt; (3,1,3) is the maximum value in the path.  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-4b7b8&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-4b7b8&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/test_sample_2.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Binary Tree Right Side View</title>
      <link>http://localhost:1313/posts/leetcode-150-binary-tree-right-side-view/</link>
      <pubDate>Tue, 05 Aug 2025 07:23:43 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-binary-tree-right-side-view/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given the &lt;code&gt;root&lt;/code&gt; of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]
Explanation:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-5143c&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-5143c&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/tmpd5jn43fs-1.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: root = [1,2,3,4,null,null,null,5]
Output: [1,3,4,5]
Explanation:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-72c0e&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-72c0e&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/tmpkpe40xeh-1.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: root = [1,null,3]
Output: [1,3]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: root = []
Output: []
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the tree is in the range [0, 100].&lt;/li&gt;
&lt;li&gt;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s imagine that we have a person on the right side and if we look at the first example, we can see everything on the right side.

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-7cc78&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-7cc78&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/199.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Balanced Binary Tree</title>
      <link>http://localhost:1313/posts/leetcode-150-balanced-binary-tree/</link>
      <pubDate>Wed, 30 Jul 2025 07:35:43 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-balanced-binary-tree/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given a binary tree, determine if it is height-balanced.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-4b50b&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-4b50b&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/balance_1.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: root = [3,9,20,null,null,15,7]  
Output: true  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-c5859&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-c5859&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/balance_2.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: root = [1,2,2,3,3,null,null,4,4]  
Output: false  
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: root = []  
Output: true  
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the tree is in the range [0, 5000].&lt;/li&gt;
&lt;li&gt;-10^4 &amp;lt;= Node.val &amp;lt;= 10^4&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;From the description of the problem, we learn that we need to find if the tree is height-balanced, and that we can do it by determining if the difference between the height of every single node in the left and right subtrees is no more than &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Diameter of Binary Tree</title>
      <link>http://localhost:1313/posts/leetcode-150-diameter-of-binary-tree/</link>
      <pubDate>Sat, 26 Jul 2025 07:15:32 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-diameter-of-binary-tree/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given the &lt;code&gt;root&lt;/code&gt; of a binary tree, return the length of the diameter of the tree.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the &lt;code&gt;root&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The length of a path between two nodes is represented by the number of edges between them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-ec853&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-ec853&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/diamtree.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: root = [1,2]
Output: 1
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the tree is in the range [1, 10^4].&lt;/li&gt;
&lt;li&gt;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;From the problem statement, we learn that we are given the &lt;code&gt;root&lt;/code&gt; of a binary tree and we need to find the diameter of the binary tree. The diameter is defined as the longest path from a particular node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - LRU Cache</title>
      <link>http://localhost:1313/posts/leetcode-150-lru-cache/</link>
      <pubDate>Tue, 22 Jul 2025 07:51:33 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-lru-cache/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Design a data structure that follows the constraints of a &lt;a href=&#34;https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU&#34;&gt;Least Recently Used (LRU) cache&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Implement the &lt;code&gt;LRUCache&lt;/code&gt; class:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LRUCache(int capacity)&lt;/code&gt; Initialize the LRU cache with positive size &lt;code&gt;capacity&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int get(int key)&lt;/code&gt; Return the value of the &lt;code&gt;key&lt;/code&gt; if the key exists, otherwise return &lt;code&gt;-1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void put(int key, int value)&lt;/code&gt; Update the value of the &lt;code&gt;key&lt;/code&gt; if the &lt;code&gt;key&lt;/code&gt; exists. Otherwise, add the &lt;code&gt;key-value&lt;/code&gt; pair to the cache. If the number of keys exceeds the &lt;code&gt;capacity&lt;/code&gt; from this operation, evict the least recently used key.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The functions &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; must each run in &lt;code&gt;O(1)&lt;/code&gt; average time complexity.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Find the Duplicate Number</title>
      <link>http://localhost:1313/posts/leetcode-150-find-the-duplicate-number/</link>
      <pubDate>Thu, 17 Jul 2025 07:55:28 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-find-the-duplicate-number/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an array of integers &lt;code&gt;nums&lt;/code&gt; containing &lt;code&gt;n + 1&lt;/code&gt; integers where each integer is in the range &lt;code&gt;[1, n]&lt;/code&gt; inclusive.&lt;/p&gt;
&lt;p&gt;There is only one repeated number in &lt;code&gt;nums&lt;/code&gt;, return this repeated number.&lt;/p&gt;
&lt;p&gt;You must solve the problem without modifying the array &lt;code&gt;nums&lt;/code&gt; and using only constant extra space.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [1,3,4,2,2]
Output: 2
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [3,1,3,4,2]
Output: 3
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [3,3,3,3,3]
Output: 3
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= n &amp;lt;= 10^5&lt;/li&gt;
&lt;li&gt;nums.length == n + 1&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= nums[i] &amp;lt;= n&lt;/li&gt;
&lt;li&gt;All the integers in nums appear only once except for precisely one integer which appears two or more times.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Follow up:&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Add Two Numbers</title>
      <link>http://localhost:1313/posts/leetcode-150-add-two-numbers/</link>
      <pubDate>Mon, 14 Jul 2025 08:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-add-two-numbers/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given two non‑empty linked lists representing two non‑negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.&lt;/p&gt;
&lt;p&gt;You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-44efa&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-44efa&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/addtwonumber1.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: l1 = [0], l2 = [0]
Output: [0]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in each linked list is in the range [1, 100].&lt;/li&gt;
&lt;li&gt;0 ≤ Node.val ≤ 9&lt;/li&gt;
&lt;li&gt;It is guaranteed that the list represents a number that does not have leading zeros.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;When we add two numbers, we need to remember the carry value when it&amp;rsquo;s necessary. The main caveat in this problem is the edge cases; we will discuss them later.
From the description of the problem, we know that we are given two non‑empty linked lists without negative integers, and the digits are stored in reverse order; we will see later that this reverse order will help us solve the problem.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Copy List with Random Pointer</title>
      <link>http://localhost:1313/posts/leetcode-150-copy-list-with-random-pointer/</link>
      <pubDate>Sun, 13 Jul 2025 07:50:36 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-copy-list-with-random-pointer/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;A linked list of length &lt;code&gt;n&lt;/code&gt; is given such that each node contains an additional random pointer, which could point to any node in the list, or &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Construct a &lt;a href=&#34;https://en.wikipedia.org/wiki/Object_copying#Deep_copy&#34;&gt;deep copy&lt;/a&gt; of the list. The deep copy should consist of exactly &lt;code&gt;n&lt;/code&gt; brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;random&lt;/code&gt; pointers of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Median of Two Sorted Arrays</title>
      <link>http://localhost:1313/posts/leetcode-150-median-of-two-sorted-arrays/</link>
      <pubDate>Fri, 11 Jul 2025 07:56:09 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-median-of-two-sorted-arrays/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given two sorted arrays &lt;code&gt;nums1&lt;/code&gt; and &lt;code&gt;nums2&lt;/code&gt; of size &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; respectively, return &lt;a href=&#34;https://en.wikipedia.org/wiki/Median&#34;&gt;the median&lt;/a&gt; of the two sorted arrays.&lt;/p&gt;
&lt;p&gt;The overall run time complexity should be &lt;code&gt;O(log (m+n))&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;nums1.length == m&lt;/li&gt;
&lt;li&gt;nums2.length == n&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= m &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= n &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= m + n &amp;lt;= 2000&lt;/li&gt;
&lt;li&gt;-10^6 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 10^6&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;From our given examples we can learn that we could potentially have an even or odd number of total elements after we merge two input arrays.
If we just try to merge both inputs and find the median, it will take us O(m + n) time, but we know that is not what we were asked to do.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Time Based Key-Value Store</title>
      <link>http://localhost:1313/posts/leetcode-150-time-based-key-value-store/</link>
      <pubDate>Sun, 06 Jul 2025 07:42:17 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-time-based-key-value-store/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Design a time-based key-value data structure that can store multiple values for the same key at different timestamps and retrieve the key&amp;rsquo;s value at a certain timestamp.&lt;/p&gt;
&lt;p&gt;Implement the &lt;code&gt;TimeMap&lt;/code&gt; class:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TimeMap()&lt;/code&gt; Initializes the object of the data structure.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void set(String key, String value, int timestamp)&lt;/code&gt; Stores the key &lt;code&gt;key&lt;/code&gt; with the value &lt;code&gt;value&lt;/code&gt; at the given time &lt;code&gt;timestamp&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String get(String key, int timestamp)&lt;/code&gt; Returns a value such that &lt;code&gt;set&lt;/code&gt; was called previously, with &lt;code&gt;timestamp_prev &amp;lt;= timestamp&lt;/code&gt;. If there are multiple such values, it returns the value associated with the largest &lt;code&gt;timestamp_prev&lt;/code&gt;. If there are no values, it returns &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input
[&amp;#34;TimeMap&amp;#34;, &amp;#34;set&amp;#34;, &amp;#34;get&amp;#34;, &amp;#34;get&amp;#34;, &amp;#34;set&amp;#34;, &amp;#34;get&amp;#34;, &amp;#34;get&amp;#34;]
[[], [&amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;, 1], [&amp;#34;foo&amp;#34;, 1], [&amp;#34;foo&amp;#34;, 3], [&amp;#34;foo&amp;#34;, &amp;#34;bar2&amp;#34;, 4], [&amp;#34;foo&amp;#34;, 4], [&amp;#34;foo&amp;#34;, 5]]
Output
[null, null, &amp;#34;bar&amp;#34;, &amp;#34;bar&amp;#34;, null, &amp;#34;bar2&amp;#34;, &amp;#34;bar2&amp;#34;]

Explanation
TimeMap timeMap = new TimeMap();
timeMap.set(&amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;, 1);  // store the key &amp;#34;foo&amp;#34; and value &amp;#34;bar&amp;#34; along with timestamp = 1.
timeMap.get(&amp;#34;foo&amp;#34;, 1);         // return &amp;#34;bar&amp;#34;
timeMap.get(&amp;#34;foo&amp;#34;, 3);         // return &amp;#34;bar&amp;#34;, since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is &amp;#34;bar&amp;#34;.
timeMap.set(&amp;#34;foo&amp;#34;, &amp;#34;bar2&amp;#34;, 4); // store the key &amp;#34;foo&amp;#34; and value &amp;#34;bar2&amp;#34; along with timestamp = 4.
timeMap.get(&amp;#34;foo&amp;#34;, 4);         // return &amp;#34;bar2&amp;#34;
timeMap.get(&amp;#34;foo&amp;#34;, 5);         // return &amp;#34;bar2&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= key.length, value.length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;key and value consist of lowercase English letters and digits.&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= timestamp &amp;lt;= 10^7&lt;/li&gt;
&lt;li&gt;All the timestamps of set are strictly increasing.&lt;/li&gt;
&lt;li&gt;At most 2 * 10^5 calls will be made to set and get.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Our objective for this task is to design a key-value store.
We are going to have a &lt;code&gt;key&lt;/code&gt;, and a list of &lt;code&gt;values&lt;/code&gt; associated with that key, and each value is going to have a &lt;code&gt;timestamp&lt;/code&gt; associated with it.
As for operations, we are going to support only &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;get&lt;/code&gt; operations.
Now, let&amp;rsquo;s look at our example

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-93282&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-93282&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/981.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Koko Eating Bananas</title>
      <link>http://localhost:1313/posts/leetcode-150-koko-eating-bananas/</link>
      <pubDate>Wed, 02 Jul 2025 07:51:15 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-koko-eating-bananas/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Koko loves to eat bananas. There are &lt;code&gt;n&lt;/code&gt; piles of bananas, the &lt;code&gt;ith&lt;/code&gt; pile has &lt;code&gt;piles[i]&lt;/code&gt; bananas. The guards have gone and will come back in &lt;code&gt;h&lt;/code&gt; hours.&lt;/p&gt;
&lt;p&gt;Koko can decide her bananas-per-hour eating speed of &lt;code&gt;k&lt;/code&gt;. Each hour, she chooses some pile of bananas and eats &lt;code&gt;k&lt;/code&gt; bananas from that pile. If the pile has less than &lt;code&gt;k&lt;/code&gt; bananas, she eats all of them instead and will not eat any more bananas during this hour.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Search a 2D Matrix</title>
      <link>http://localhost:1313/posts/leetcode-150-search-a-2d-matrix/</link>
      <pubDate>Sun, 29 Jun 2025 07:43:19 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-search-a-2d-matrix/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given an &lt;code&gt;m x n&lt;/code&gt; integer matrix &lt;code&gt;matrix&lt;/code&gt; with the following two properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each row is sorted in non-decreasing order.&lt;/li&gt;
&lt;li&gt;The first integer of each row is greater than the last integer of the previous row.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given an integer &lt;code&gt;target&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;target&lt;/code&gt; is in &lt;code&gt;matrix&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/p&gt;
&lt;p&gt;You must write a solution in &lt;code&gt;O(log(m * n))&lt;/code&gt; time complexity.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-f9a47&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-f9a47&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/mat.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3  
Output: true  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-7112f&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-7112f&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/mat2.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Binary Search</title>
      <link>http://localhost:1313/posts/leetcode-150-binary-search/</link>
      <pubDate>Fri, 27 Jun 2025 07:37:23 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-binary-search/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an array of integers &lt;code&gt;nums&lt;/code&gt; which is sorted in ascending order, and an integer &lt;code&gt;target&lt;/code&gt;, write a function to search &lt;code&gt;target&lt;/code&gt; in &lt;code&gt;nums&lt;/code&gt;. If &lt;code&gt;target&lt;/code&gt; exists, then return its index. Otherwise, return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You must write an algorithm with &lt;code&gt;O(log n)&lt;/code&gt; runtime complexity.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [-1,0,3,5,9,12], target = 9  
Output: 4  
Explanation: 9 exists in nums and its index is 4
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [-1,0,3,5,9,12], target = 2  
Output: -1  
Explanation: 2 does not exist in nums so return -1
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= nums.length &amp;lt;= 10^4&lt;/li&gt;
&lt;li&gt;-10^4 &amp;lt; nums[i], target &amp;lt; 10^4&lt;/li&gt;
&lt;li&gt;All the integers in nums are unique.&lt;/li&gt;
&lt;li&gt;nums is sorted in ascending order.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Before we jump into the solution, let’s figure out what the requirements for a binary search algorithm are and how it is going to work.

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-0d4d4&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-0d4d4&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/704.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;

The main requirement for binary search is that the input must be sorted.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Largest Rectangle in Histogram</title>
      <link>http://localhost:1313/posts/leetcode-150-largest-rectangle-in-histogram/</link>
      <pubDate>Tue, 24 Jun 2025 07:51:28 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-largest-rectangle-in-histogram/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an array of integers &lt;code&gt;heights&lt;/code&gt; representing the histogram&amp;rsquo;s bar height where the width of each bar is &lt;code&gt;1&lt;/code&gt;, return the area of the largest rectangle in the histogram.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-f3e90&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-f3e90&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/histogram.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: heights = [2,1,5,6,2,3]  
Output: 10  
Explanation: The above is a histogram where width of each bar is 1.  
The largest rectangle is shown in the red area, which has an area = 10 units.  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-1deaf&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-1deaf&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/histogram-1.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Car Fleet</title>
      <link>http://localhost:1313/posts/leetcode-150-car-fleet/</link>
      <pubDate>Wed, 18 Jun 2025 07:29:11 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-car-fleet/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;There are &lt;code&gt;n&lt;/code&gt; cars at given miles away from the starting mile 0, traveling to reach the mile &lt;code&gt;target&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You are given two integer array &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;speed&lt;/code&gt;, both of length &lt;code&gt;n&lt;/code&gt;, where &lt;code&gt;position[i]&lt;/code&gt; is the starting mile of the &lt;code&gt;ith&lt;/code&gt; car and &lt;code&gt;speed[i]&lt;/code&gt; is the speed of the &lt;code&gt;ith&lt;/code&gt; car in miles per hour.&lt;/p&gt;
&lt;p&gt;A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Daily Temperatures</title>
      <link>http://localhost:1313/posts/leetcode-150-daily-temperatures/</link>
      <pubDate>Thu, 12 Jun 2025 07:47:38 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-daily-temperatures/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an array of integers &lt;code&gt;temperatures&lt;/code&gt; represents the daily temperatures, return an array &lt;code&gt;answer&lt;/code&gt; such that &lt;code&gt;answer[i]&lt;/code&gt; is the number of days you have to wait after the &lt;code&gt;i&lt;/code&gt;th day to get a warmer temperature. If there is no future day for which this is possible, keep &lt;code&gt;answer[i] == 0&lt;/code&gt; instead.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: temperatures = [73,74,75,71,69,72,76,73]  
Output: [1,1,4,2,1,1,0,0]  
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: temperatures = [30,40,50,60]  
Output: [1,1,1,0]  
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: temperatures = [30,60,90]  
Output: [1,1,0]  
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= temperatures.length &amp;lt;= 10^5&lt;/li&gt;
&lt;li&gt;30 &amp;lt;= temperatures[i] &amp;lt;= 100&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Before we jump to the solution, let&amp;rsquo;s figure out the way we can solve this problem.

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-ce6f1&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-ce6f1&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/739.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;

In the first example, we can see that we can calculate how many days in the input array it takes us to find a temperature that is greater than &lt;code&gt;73&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Generate Parentheses</title>
      <link>http://localhost:1313/posts/leetcode-150-generate-parentheses/</link>
      <pubDate>Mon, 09 Jun 2025 07:54:24 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-generate-parentheses/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given &lt;code&gt;n&lt;/code&gt; pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: n = 3  
Output: [&amp;#34;((()))&amp;#34;,&amp;#34;(()())&amp;#34;,&amp;#34;(())()&amp;#34;,&amp;#34;()(())&amp;#34;,&amp;#34;()()()&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: n = 1  
Output: [&amp;#34;()&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= n &amp;lt;= 8&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Before we jump to the solution, let&amp;rsquo;s figure out what &lt;strong&gt;well-formed parentheses&lt;/strong&gt; mean.
In this problem, this means when you&amp;rsquo;re writing the code using nested parentheses, you want them to be nested in a valid way, like &lt;code&gt;(()())&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Evaluate Reverse Polish Notation</title>
      <link>http://localhost:1313/posts/leetcode-150-evaluate-reverse-polish-notation/</link>
      <pubDate>Thu, 05 Jun 2025 07:51:16 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-evaluate-reverse-polish-notation/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given an array of strings &lt;code&gt;tokens&lt;/code&gt; that represents an arithmetic expression in &lt;a href=&#34;https://en.wikipedia.org/wiki/Reverse_Polish_notation&#34;&gt;Reverse Polish Notation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Evaluate the expression. Return an integer that represents the value of the expression.&lt;/p&gt;
&lt;p&gt;Note that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The valid operators are &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Each operand may be an integer or another expression.&lt;/li&gt;
&lt;li&gt;The division between two integers always truncates toward zero.&lt;/li&gt;
&lt;li&gt;There will not be any division by zero.&lt;/li&gt;
&lt;li&gt;The input represents a valid arithmetic expression in reverse Polish notation.&lt;/li&gt;
&lt;li&gt;The answer and all the intermediate calculations can be represented in a 32-bit integer.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: tokens = [&amp;#34;2&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;+&amp;#34;,&amp;#34;3&amp;#34;,&amp;#34;*&amp;#34;]
Output: 9
Explanation: ((2 + 1) * 3) = 9
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: tokens = [&amp;#34;4&amp;#34;,&amp;#34;13&amp;#34;,&amp;#34;5&amp;#34;,&amp;#34;/&amp;#34;,&amp;#34;+&amp;#34;]
Output: 6
Explanation: (4 + (13 / 5)) = 6
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: tokens = [&amp;#34;10&amp;#34;,&amp;#34;6&amp;#34;,&amp;#34;9&amp;#34;,&amp;#34;3&amp;#34;,&amp;#34;+&amp;#34;,&amp;#34;-11&amp;#34;,&amp;#34;*&amp;#34;,&amp;#34;/&amp;#34;,&amp;#34;*&amp;#34;,&amp;#34;17&amp;#34;,&amp;#34;+&amp;#34;,&amp;#34;5&amp;#34;,&amp;#34;+&amp;#34;]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= tokens.length &amp;lt;= 10^4&lt;/li&gt;
&lt;li&gt;tokens[i] is either an operator: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;/&lt;/code&gt;, or an integer in the range [-200, 200].&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Let’s take a look at the example with input &lt;code&gt;tokens = [&amp;quot;2&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;+&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;*&amp;quot;]&lt;/code&gt;, and try to figure out the way we can solve it.

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-359c0&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-359c0&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/150.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Min Stack</title>
      <link>http://localhost:1313/posts/leetcode-150-min-stack/</link>
      <pubDate>Tue, 03 Jun 2025 07:29:07 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-min-stack/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Design a stack that supports &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, and &lt;strong&gt;retrieving the minimum element in constant time&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Implement the &lt;code&gt;MinStack&lt;/code&gt; class:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MinStack()&lt;/code&gt; initializes the stack object.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void push(int val)&lt;/code&gt; pushes the element &lt;code&gt;val&lt;/code&gt; onto the stack.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void pop()&lt;/code&gt; removes the element on the top of the stack.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int top()&lt;/code&gt; gets the top element of the stack.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int getMin()&lt;/code&gt; retrieves the minimum element in the stack.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You must implement a solution with &lt;code&gt;O(1)&lt;/code&gt; time complexity for each function.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Sliding Window Maximum</title>
      <link>http://localhost:1313/posts/leetcode-150-sliding-window-maximum/</link>
      <pubDate>Mon, 02 Jun 2025 07:18:22 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-sliding-window-maximum/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given an array of integers &lt;code&gt;nums&lt;/code&gt;, and there is a sliding window of size &lt;code&gt;k&lt;/code&gt; which is moving from the very left of the array to the very right. You can only see the &lt;code&gt;k&lt;/code&gt; numbers in the window. Each time the sliding window moves right by one position.&lt;/p&gt;
&lt;p&gt;Return the max sliding window.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [1], k = 1
Output: [1]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= nums.length &amp;lt;= 10^5&lt;/li&gt;
&lt;li&gt;-10^4 &amp;lt;= nums[i] &amp;lt;= 10^4&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= k &amp;lt;= nums.length&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Before we jump into the solution, let&amp;rsquo;s look at our example with &lt;code&gt;nums = [1,3,-1,-3,5,3,6,7], k = 3&lt;/code&gt;

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-2dedb&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-2dedb&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/239.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;

We can see that at the first position we have &lt;strong&gt;max&lt;/strong&gt; value &lt;code&gt;3&lt;/code&gt;, which we add to our output array.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Permutation in String</title>
      <link>http://localhost:1313/posts/leetcode-150-permutation-in-string/</link>
      <pubDate>Wed, 28 May 2025 07:53:36 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-permutation-in-string/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given two strings &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s2&lt;/code&gt; contains a permutation of &lt;code&gt;s1&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A permutation is a rearrangement of all the characters of a string.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In other words, return &lt;code&gt;true&lt;/code&gt; if one of &lt;code&gt;s1&lt;/code&gt;’s permutations is a substring of &lt;code&gt;s2&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: s1 = &amp;#34;ab&amp;#34;, s2 = &amp;#34;eidbaooo&amp;#34;
Output: true
Explanation: s2 contains one permutation of s1 (&amp;#34;ba&amp;#34;).
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: s1 = &amp;#34;ab&amp;#34;, s2 = &amp;#34;eidboaoo&amp;#34;
Output: false
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= s1.length, s2.length &amp;lt;= 10^4&lt;/li&gt;
&lt;li&gt;s1 and s2 consist of lowercase English letters.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Before we jump into the solution, let&amp;rsquo;s take a look at the example with input &lt;code&gt;s1 = &amp;quot;ab&amp;quot;, s2 = &amp;quot;eidbaooo&amp;quot;&lt;/code&gt;&lt;br&gt;

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-7d24f&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-7d24f&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/567.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;br&gt;
We are looking for a permutation of &lt;code&gt;s1&lt;/code&gt; in &lt;code&gt;s2&lt;/code&gt; with the size of &lt;code&gt;s1&lt;/code&gt;.&lt;br&gt;
In the example, we can see that we have a permutation of &lt;code&gt;s1 = &amp;quot;ab&amp;quot;&lt;/code&gt; in &lt;code&gt;s2 = &amp;quot;eidbaooo&amp;quot;&lt;/code&gt; but in a different order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Trapping Rain Water</title>
      <link>http://localhost:1313/posts/leetcode-150-trapping-rain-water/</link>
      <pubDate>Fri, 23 May 2025 07:18:50 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-trapping-rain-water/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given &lt;code&gt;n&lt;/code&gt; non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-ed9e8&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-ed9e8&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/rainwatertrap.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: height = [4,2,0,3,2,5]
Output: 9
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;n == height.length&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= n &amp;lt;= 2 * 10^4&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= height[i] &amp;lt;= 10^5&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s look at our example and determine the algorithm of how much water each position could trap.&lt;br&gt;

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-ada9c&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-ada9c&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/42.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Two Sum II - Input Array Is Sorted</title>
      <link>http://localhost:1313/posts/leetcode-150-two-sum-ii-input-array-is-sorted/</link>
      <pubDate>Mon, 19 May 2025 07:17:39 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-two-sum-ii-input-array-is-sorted/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given a 1-indexed array of integers &lt;code&gt;numbers&lt;/code&gt; that is already sorted in non-decreasing order, find two numbers such that they add up to a specific &lt;code&gt;target&lt;/code&gt; number. Let these two numbers be &lt;code&gt;numbers[index1]&lt;/code&gt; and &lt;code&gt;numbers[index2]&lt;/code&gt; where &lt;code&gt;1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Return the indices of the two numbers, &lt;code&gt;index1&lt;/code&gt; and &lt;code&gt;index2&lt;/code&gt;, added by one as an integer array &lt;code&gt;[index1, index2]&lt;/code&gt; of length 2.&lt;/p&gt;
&lt;p&gt;The tests are generated such that there is exactly one solution. You may not use the same element twice.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Valid Sudoku</title>
      <link>http://localhost:1313/posts/leetcode-150-valid-sudoku/</link>
      <pubDate>Fri, 16 May 2025 08:02:42 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-valid-sudoku/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Determine if a &lt;code&gt;9 x 9&lt;/code&gt; Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Each row must contain the digits &lt;code&gt;1-9&lt;/code&gt; without repetition.&lt;/li&gt;
&lt;li&gt;Each column must contain the digits &lt;code&gt;1-9&lt;/code&gt; without repetition.&lt;/li&gt;
&lt;li&gt;Each of the nine &lt;code&gt;3 x 3&lt;/code&gt; sub-boxes of the grid must contain the digits &lt;code&gt;1-9&lt;/code&gt; without repetition.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Sudoku board (partially filled) could be valid but is not necessarily solvable.&lt;/li&gt;
&lt;li&gt;Only the filled cells need to be validated according to the mentioned rules.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-334fd&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-334fd&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/Sudoku-by-L2G-20050714.svg.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
