<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>150 on Dmytro&#39;s Blog</title>
    <link>http://localhost:1313/tags/150/</link>
    <description>Recent content in 150 on Dmytro&#39;s Blog</description>
    <image>
      <title>Dmytro&#39;s Blog</title>
      <url>http://localhost:1313/images/papermod-cover.png</url>
      <link>http://localhost:1313/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.147.0</generator>
    <language>en</language>
    <lastBuildDate>Tue, 22 Jul 2025 07:51:33 +0300</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/150/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode - 150 - LRU Cache</title>
      <link>http://localhost:1313/posts/leetcode-150-lru-cache/</link>
      <pubDate>Tue, 22 Jul 2025 07:51:33 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-lru-cache/</guid>
      <description>&lt;p&gt;LeetCode - 150 - LRU Cache&lt;/p&gt;
&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Design a data structure that follows the constraints of a &lt;a href=&#34;https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU&#34;&gt;Least Recently Used (LRU) cache&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Implement the &lt;code&gt;LRUCache&lt;/code&gt; class:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LRUCache(int capacity)&lt;/code&gt; Initialize the LRU cache with positive size &lt;code&gt;capacity&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int get(int key)&lt;/code&gt; Return the value of the &lt;code&gt;key&lt;/code&gt; if the key exists, otherwise return &lt;code&gt;-1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void put(int key, int value)&lt;/code&gt; Update the value of the &lt;code&gt;key&lt;/code&gt; if the &lt;code&gt;key&lt;/code&gt; exists. Otherwise, add the &lt;code&gt;key-value&lt;/code&gt; pair to the cache. If the number of keys exceeds the &lt;code&gt;capacity&lt;/code&gt; from this operation, evict the least recently used key.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The functions &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; must each run in &lt;code&gt;O(1)&lt;/code&gt; average time complexity.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Find the Duplicate Number</title>
      <link>http://localhost:1313/posts/leetcode-150-find-the-duplicate-number/</link>
      <pubDate>Thu, 17 Jul 2025 07:55:28 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-find-the-duplicate-number/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an array of integers &lt;code&gt;nums&lt;/code&gt; containing &lt;code&gt;n + 1&lt;/code&gt; integers where each integer is in the range &lt;code&gt;[1, n]&lt;/code&gt; inclusive.&lt;/p&gt;
&lt;p&gt;There is only one repeated number in &lt;code&gt;nums&lt;/code&gt;, return this repeated number.&lt;/p&gt;
&lt;p&gt;You must solve the problem without modifying the array &lt;code&gt;nums&lt;/code&gt; and using only constant extra space.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [1,3,4,2,2]
Output: 2
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [3,1,3,4,2]
Output: 3
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [3,3,3,3,3]
Output: 3
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= n &amp;lt;= 10^5&lt;/li&gt;
&lt;li&gt;nums.length == n + 1&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= nums[i] &amp;lt;= n&lt;/li&gt;
&lt;li&gt;All the integers in nums appear only once except for precisely one integer which appears two or more times.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Follow up:&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Add Two Numbers</title>
      <link>http://localhost:1313/posts/leetcode-150-add-two-numbers/</link>
      <pubDate>Mon, 14 Jul 2025 08:00:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-add-two-numbers/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given two non‑empty linked lists representing two non‑negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.&lt;/p&gt;
&lt;p&gt;You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-44efa&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-44efa&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/addtwonumber1.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: l1 = [0], l2 = [0]
Output: [0]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in each linked list is in the range [1, 100].&lt;/li&gt;
&lt;li&gt;0 ≤ Node.val ≤ 9&lt;/li&gt;
&lt;li&gt;It is guaranteed that the list represents a number that does not have leading zeros.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;When we add two numbers, we need to remember the carry value when it&amp;rsquo;s necessary. The main caveat in this problem is the edge cases; we will discuss them later.
From the description of the problem, we know that we are given two non‑empty linked lists without negative integers, and the digits are stored in reverse order; we will see later that this reverse order will help us solve the problem.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Copy List with Random Pointer</title>
      <link>http://localhost:1313/posts/leetcode-150-copy-list-with-random-pointer/</link>
      <pubDate>Sun, 13 Jul 2025 07:50:36 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-copy-list-with-random-pointer/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;A linked list of length &lt;code&gt;n&lt;/code&gt; is given such that each node contains an additional random pointer, which could point to any node in the list, or &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Construct a &lt;a href=&#34;https://en.wikipedia.org/wiki/Object_copying#Deep_copy&#34;&gt;deep copy&lt;/a&gt; of the list. The deep copy should consist of exactly &lt;code&gt;n&lt;/code&gt; brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;random&lt;/code&gt; pointers of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Median of Two Sorted Arrays</title>
      <link>http://localhost:1313/posts/leetcode-150-median-of-two-sorted-arrays/</link>
      <pubDate>Fri, 11 Jul 2025 07:56:09 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-median-of-two-sorted-arrays/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given two sorted arrays &lt;code&gt;nums1&lt;/code&gt; and &lt;code&gt;nums2&lt;/code&gt; of size &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; respectively, return &lt;a href=&#34;https://en.wikipedia.org/wiki/Median&#34;&gt;the median&lt;/a&gt; of the two sorted arrays.&lt;/p&gt;
&lt;p&gt;The overall run time complexity should be &lt;code&gt;O(log (m+n))&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;nums1.length == m&lt;/li&gt;
&lt;li&gt;nums2.length == n&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= m &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= n &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= m + n &amp;lt;= 2000&lt;/li&gt;
&lt;li&gt;-10^6 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 10^6&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;From our given examples we can learn that we could potentially have an even or odd number of total elements after we merge two input arrays.
If we just try to merge both inputs and find the median, it will take us O(m + n) time, but we know that is not what we were asked to do.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Time Based Key-Value Store</title>
      <link>http://localhost:1313/posts/leetcode-150-time-based-key-value-store/</link>
      <pubDate>Sun, 06 Jul 2025 07:42:17 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-time-based-key-value-store/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Design a time-based key-value data structure that can store multiple values for the same key at different timestamps and retrieve the key&amp;rsquo;s value at a certain timestamp.&lt;/p&gt;
&lt;p&gt;Implement the &lt;code&gt;TimeMap&lt;/code&gt; class:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TimeMap()&lt;/code&gt; Initializes the object of the data structure.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void set(String key, String value, int timestamp)&lt;/code&gt; Stores the key &lt;code&gt;key&lt;/code&gt; with the value &lt;code&gt;value&lt;/code&gt; at the given time &lt;code&gt;timestamp&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String get(String key, int timestamp)&lt;/code&gt; Returns a value such that &lt;code&gt;set&lt;/code&gt; was called previously, with &lt;code&gt;timestamp_prev &amp;lt;= timestamp&lt;/code&gt;. If there are multiple such values, it returns the value associated with the largest &lt;code&gt;timestamp_prev&lt;/code&gt;. If there are no values, it returns &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input
[&amp;#34;TimeMap&amp;#34;, &amp;#34;set&amp;#34;, &amp;#34;get&amp;#34;, &amp;#34;get&amp;#34;, &amp;#34;set&amp;#34;, &amp;#34;get&amp;#34;, &amp;#34;get&amp;#34;]
[[], [&amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;, 1], [&amp;#34;foo&amp;#34;, 1], [&amp;#34;foo&amp;#34;, 3], [&amp;#34;foo&amp;#34;, &amp;#34;bar2&amp;#34;, 4], [&amp;#34;foo&amp;#34;, 4], [&amp;#34;foo&amp;#34;, 5]]
Output
[null, null, &amp;#34;bar&amp;#34;, &amp;#34;bar&amp;#34;, null, &amp;#34;bar2&amp;#34;, &amp;#34;bar2&amp;#34;]

Explanation
TimeMap timeMap = new TimeMap();
timeMap.set(&amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;, 1);  // store the key &amp;#34;foo&amp;#34; and value &amp;#34;bar&amp;#34; along with timestamp = 1.
timeMap.get(&amp;#34;foo&amp;#34;, 1);         // return &amp;#34;bar&amp;#34;
timeMap.get(&amp;#34;foo&amp;#34;, 3);         // return &amp;#34;bar&amp;#34;, since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is &amp;#34;bar&amp;#34;.
timeMap.set(&amp;#34;foo&amp;#34;, &amp;#34;bar2&amp;#34;, 4); // store the key &amp;#34;foo&amp;#34; and value &amp;#34;bar2&amp;#34; along with timestamp = 4.
timeMap.get(&amp;#34;foo&amp;#34;, 4);         // return &amp;#34;bar2&amp;#34;
timeMap.get(&amp;#34;foo&amp;#34;, 5);         // return &amp;#34;bar2&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= key.length, value.length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;key and value consist of lowercase English letters and digits.&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= timestamp &amp;lt;= 10^7&lt;/li&gt;
&lt;li&gt;All the timestamps of set are strictly increasing.&lt;/li&gt;
&lt;li&gt;At most 2 * 10^5 calls will be made to set and get.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Our objective for this task is to design a key-value store.
We are going to have a &lt;code&gt;key&lt;/code&gt;, and a list of &lt;code&gt;values&lt;/code&gt; associated with that key, and each value is going to have a &lt;code&gt;timestamp&lt;/code&gt; associated with it.
As for operations, we are going to support only &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;get&lt;/code&gt; operations.
Now, let&amp;rsquo;s look at our example

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-93282&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-93282&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/981.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Koko Eating Bananas</title>
      <link>http://localhost:1313/posts/leetcode-150-koko-eating-bananas/</link>
      <pubDate>Wed, 02 Jul 2025 07:51:15 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-koko-eating-bananas/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Koko loves to eat bananas. There are &lt;code&gt;n&lt;/code&gt; piles of bananas, the &lt;code&gt;ith&lt;/code&gt; pile has &lt;code&gt;piles[i]&lt;/code&gt; bananas. The guards have gone and will come back in &lt;code&gt;h&lt;/code&gt; hours.&lt;/p&gt;
&lt;p&gt;Koko can decide her bananas-per-hour eating speed of &lt;code&gt;k&lt;/code&gt;. Each hour, she chooses some pile of bananas and eats &lt;code&gt;k&lt;/code&gt; bananas from that pile. If the pile has less than &lt;code&gt;k&lt;/code&gt; bananas, she eats all of them instead and will not eat any more bananas during this hour.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Search a 2D Matrix</title>
      <link>http://localhost:1313/posts/leetcode-150-search-a-2d-matrix/</link>
      <pubDate>Sun, 29 Jun 2025 07:43:19 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-search-a-2d-matrix/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given an &lt;code&gt;m x n&lt;/code&gt; integer matrix &lt;code&gt;matrix&lt;/code&gt; with the following two properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each row is sorted in non-decreasing order.&lt;/li&gt;
&lt;li&gt;The first integer of each row is greater than the last integer of the previous row.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given an integer &lt;code&gt;target&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;target&lt;/code&gt; is in &lt;code&gt;matrix&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/p&gt;
&lt;p&gt;You must write a solution in &lt;code&gt;O(log(m * n))&lt;/code&gt; time complexity.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-f9a47&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-f9a47&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/mat.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3  
Output: true  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-7112f&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-7112f&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/mat2.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Binary Search</title>
      <link>http://localhost:1313/posts/leetcode-150-binary-search/</link>
      <pubDate>Fri, 27 Jun 2025 07:37:23 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-binary-search/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an array of integers &lt;code&gt;nums&lt;/code&gt; which is sorted in ascending order, and an integer &lt;code&gt;target&lt;/code&gt;, write a function to search &lt;code&gt;target&lt;/code&gt; in &lt;code&gt;nums&lt;/code&gt;. If &lt;code&gt;target&lt;/code&gt; exists, then return its index. Otherwise, return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You must write an algorithm with &lt;code&gt;O(log n)&lt;/code&gt; runtime complexity.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [-1,0,3,5,9,12], target = 9  
Output: 4  
Explanation: 9 exists in nums and its index is 4
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [-1,0,3,5,9,12], target = 2  
Output: -1  
Explanation: 2 does not exist in nums so return -1
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= nums.length &amp;lt;= 10^4&lt;/li&gt;
&lt;li&gt;-10^4 &amp;lt; nums[i], target &amp;lt; 10^4&lt;/li&gt;
&lt;li&gt;All the integers in nums are unique.&lt;/li&gt;
&lt;li&gt;nums is sorted in ascending order.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Before we jump into the solution, let’s figure out what the requirements for a binary search algorithm are and how it is going to work.

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-0d4d4&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-0d4d4&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/704.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;

The main requirement for binary search is that the input must be sorted.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Largest Rectangle in Histogram</title>
      <link>http://localhost:1313/posts/leetcode-150-largest-rectangle-in-histogram/</link>
      <pubDate>Tue, 24 Jun 2025 07:51:28 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-largest-rectangle-in-histogram/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an array of integers &lt;code&gt;heights&lt;/code&gt; representing the histogram&amp;rsquo;s bar height where the width of each bar is &lt;code&gt;1&lt;/code&gt;, return the area of the largest rectangle in the histogram.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-f3e90&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-f3e90&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/histogram.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: heights = [2,1,5,6,2,3]  
Output: 10  
Explanation: The above is a histogram where width of each bar is 1.  
The largest rectangle is shown in the red area, which has an area = 10 units.  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-1deaf&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-1deaf&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/histogram-1.jpg#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Car Fleet</title>
      <link>http://localhost:1313/posts/leetcode-150-car-fleet/</link>
      <pubDate>Wed, 18 Jun 2025 07:29:11 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-car-fleet/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;There are &lt;code&gt;n&lt;/code&gt; cars at given miles away from the starting mile 0, traveling to reach the mile &lt;code&gt;target&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You are given two integer array &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;speed&lt;/code&gt;, both of length &lt;code&gt;n&lt;/code&gt;, where &lt;code&gt;position[i]&lt;/code&gt; is the starting mile of the &lt;code&gt;ith&lt;/code&gt; car and &lt;code&gt;speed[i]&lt;/code&gt; is the speed of the &lt;code&gt;ith&lt;/code&gt; car in miles per hour.&lt;/p&gt;
&lt;p&gt;A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Daily Temperatures</title>
      <link>http://localhost:1313/posts/leetcode-150-daily-temperatures/</link>
      <pubDate>Thu, 12 Jun 2025 07:47:38 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-daily-temperatures/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given an array of integers &lt;code&gt;temperatures&lt;/code&gt; represents the daily temperatures, return an array &lt;code&gt;answer&lt;/code&gt; such that &lt;code&gt;answer[i]&lt;/code&gt; is the number of days you have to wait after the &lt;code&gt;i&lt;/code&gt;th day to get a warmer temperature. If there is no future day for which this is possible, keep &lt;code&gt;answer[i] == 0&lt;/code&gt; instead.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: temperatures = [73,74,75,71,69,72,76,73]  
Output: [1,1,4,2,1,1,0,0]  
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: temperatures = [30,40,50,60]  
Output: [1,1,1,0]  
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: temperatures = [30,60,90]  
Output: [1,1,0]  
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= temperatures.length &amp;lt;= 10^5&lt;/li&gt;
&lt;li&gt;30 &amp;lt;= temperatures[i] &amp;lt;= 100&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Before we jump to the solution, let&amp;rsquo;s figure out the way we can solve this problem.

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-ce6f1&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-ce6f1&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/739.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;

In the first example, we can see that we can calculate how many days in the input array it takes us to find a temperature that is greater than &lt;code&gt;73&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Generate Parentheses</title>
      <link>http://localhost:1313/posts/leetcode-150-generate-parentheses/</link>
      <pubDate>Mon, 09 Jun 2025 07:54:24 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-generate-parentheses/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given &lt;code&gt;n&lt;/code&gt; pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: n = 3  
Output: [&amp;#34;((()))&amp;#34;,&amp;#34;(()())&amp;#34;,&amp;#34;(())()&amp;#34;,&amp;#34;()(())&amp;#34;,&amp;#34;()()()&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: n = 1  
Output: [&amp;#34;()&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= n &amp;lt;= 8&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Before we jump to the solution, let&amp;rsquo;s figure out what &lt;strong&gt;well-formed parentheses&lt;/strong&gt; mean.
In this problem, this means when you&amp;rsquo;re writing the code using nested parentheses, you want them to be nested in a valid way, like &lt;code&gt;(()())&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Evaluate Reverse Polish Notation</title>
      <link>http://localhost:1313/posts/leetcode-150-evaluate-reverse-polish-notation/</link>
      <pubDate>Thu, 05 Jun 2025 07:51:16 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-evaluate-reverse-polish-notation/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given an array of strings &lt;code&gt;tokens&lt;/code&gt; that represents an arithmetic expression in &lt;a href=&#34;https://en.wikipedia.org/wiki/Reverse_Polish_notation&#34;&gt;Reverse Polish Notation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Evaluate the expression. Return an integer that represents the value of the expression.&lt;/p&gt;
&lt;p&gt;Note that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The valid operators are &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Each operand may be an integer or another expression.&lt;/li&gt;
&lt;li&gt;The division between two integers always truncates toward zero.&lt;/li&gt;
&lt;li&gt;There will not be any division by zero.&lt;/li&gt;
&lt;li&gt;The input represents a valid arithmetic expression in reverse Polish notation.&lt;/li&gt;
&lt;li&gt;The answer and all the intermediate calculations can be represented in a 32-bit integer.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: tokens = [&amp;#34;2&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;+&amp;#34;,&amp;#34;3&amp;#34;,&amp;#34;*&amp;#34;]
Output: 9
Explanation: ((2 + 1) * 3) = 9
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: tokens = [&amp;#34;4&amp;#34;,&amp;#34;13&amp;#34;,&amp;#34;5&amp;#34;,&amp;#34;/&amp;#34;,&amp;#34;+&amp;#34;]
Output: 6
Explanation: (4 + (13 / 5)) = 6
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: tokens = [&amp;#34;10&amp;#34;,&amp;#34;6&amp;#34;,&amp;#34;9&amp;#34;,&amp;#34;3&amp;#34;,&amp;#34;+&amp;#34;,&amp;#34;-11&amp;#34;,&amp;#34;*&amp;#34;,&amp;#34;/&amp;#34;,&amp;#34;*&amp;#34;,&amp;#34;17&amp;#34;,&amp;#34;+&amp;#34;,&amp;#34;5&amp;#34;,&amp;#34;+&amp;#34;]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= tokens.length &amp;lt;= 10^4&lt;/li&gt;
&lt;li&gt;tokens[i] is either an operator: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;/&lt;/code&gt;, or an integer in the range [-200, 200].&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Let’s take a look at the example with input &lt;code&gt;tokens = [&amp;quot;2&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;+&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;*&amp;quot;]&lt;/code&gt;, and try to figure out the way we can solve it.

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-359c0&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-359c0&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/150.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Min Stack</title>
      <link>http://localhost:1313/posts/leetcode-150-min-stack/</link>
      <pubDate>Tue, 03 Jun 2025 07:29:07 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-min-stack/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Design a stack that supports &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, and &lt;strong&gt;retrieving the minimum element in constant time&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Implement the &lt;code&gt;MinStack&lt;/code&gt; class:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MinStack()&lt;/code&gt; initializes the stack object.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void push(int val)&lt;/code&gt; pushes the element &lt;code&gt;val&lt;/code&gt; onto the stack.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void pop()&lt;/code&gt; removes the element on the top of the stack.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int top()&lt;/code&gt; gets the top element of the stack.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int getMin()&lt;/code&gt; retrieves the minimum element in the stack.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You must implement a solution with &lt;code&gt;O(1)&lt;/code&gt; time complexity for each function.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Sliding Window Maximum</title>
      <link>http://localhost:1313/posts/leetcode-150-sliding-window-maximum/</link>
      <pubDate>Mon, 02 Jun 2025 07:18:22 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-sliding-window-maximum/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;You are given an array of integers &lt;code&gt;nums&lt;/code&gt;, and there is a sliding window of size &lt;code&gt;k&lt;/code&gt; which is moving from the very left of the array to the very right. You can only see the &lt;code&gt;k&lt;/code&gt; numbers in the window. Each time the sliding window moves right by one position.&lt;/p&gt;
&lt;p&gt;Return the max sliding window.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: nums = [1], k = 1
Output: [1]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= nums.length &amp;lt;= 10^5&lt;/li&gt;
&lt;li&gt;-10^4 &amp;lt;= nums[i] &amp;lt;= 10^4&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= k &amp;lt;= nums.length&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Before we jump into the solution, let&amp;rsquo;s look at our example with &lt;code&gt;nums = [1,3,-1,-3,5,3,6,7], k = 3&lt;/code&gt;

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-2dedb&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-2dedb&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/239.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;

We can see that at the first position we have &lt;strong&gt;max&lt;/strong&gt; value &lt;code&gt;3&lt;/code&gt;, which we add to our output array.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Permutation in String</title>
      <link>http://localhost:1313/posts/leetcode-150-permutation-in-string/</link>
      <pubDate>Wed, 28 May 2025 07:53:36 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-permutation-in-string/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given two strings &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s2&lt;/code&gt; contains a permutation of &lt;code&gt;s1&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A permutation is a rearrangement of all the characters of a string.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;In other words, return &lt;code&gt;true&lt;/code&gt; if one of &lt;code&gt;s1&lt;/code&gt;’s permutations is a substring of &lt;code&gt;s2&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: s1 = &amp;#34;ab&amp;#34;, s2 = &amp;#34;eidbaooo&amp;#34;
Output: true
Explanation: s2 contains one permutation of s1 (&amp;#34;ba&amp;#34;).
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: s1 = &amp;#34;ab&amp;#34;, s2 = &amp;#34;eidboaoo&amp;#34;
Output: false
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= s1.length, s2.length &amp;lt;= 10^4&lt;/li&gt;
&lt;li&gt;s1 and s2 consist of lowercase English letters.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Before we jump into the solution, let&amp;rsquo;s take a look at the example with input &lt;code&gt;s1 = &amp;quot;ab&amp;quot;, s2 = &amp;quot;eidbaooo&amp;quot;&lt;/code&gt;&lt;br&gt;

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-7d24f&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-7d24f&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/567.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;br&gt;
We are looking for a permutation of &lt;code&gt;s1&lt;/code&gt; in &lt;code&gt;s2&lt;/code&gt; with the size of &lt;code&gt;s1&lt;/code&gt;.&lt;br&gt;
In the example, we can see that we have a permutation of &lt;code&gt;s1 = &amp;quot;ab&amp;quot;&lt;/code&gt; in &lt;code&gt;s2 = &amp;quot;eidbaooo&amp;quot;&lt;/code&gt; but in a different order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Trapping Rain Water</title>
      <link>http://localhost:1313/posts/leetcode-150-trapping-rain-water/</link>
      <pubDate>Fri, 23 May 2025 07:18:50 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-trapping-rain-water/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given &lt;code&gt;n&lt;/code&gt; non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.&lt;/p&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-ed9e8&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-ed9e8&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/rainwatertrap.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: height = [4,2,0,3,2,5]
Output: 9
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;constraints&#34;&gt;Constraints&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;n == height.length&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= n &amp;lt;= 2 * 10^4&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= height[i] &amp;lt;= 10^5&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;explanation&#34;&gt;Explanation&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s look at our example and determine the algorithm of how much water each position could trap.&lt;br&gt;

    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-ada9c&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-ada9c&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/42.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Two Sum II - Input Array Is Sorted</title>
      <link>http://localhost:1313/posts/leetcode-150-two-sum-ii-input-array-is-sorted/</link>
      <pubDate>Mon, 19 May 2025 07:17:39 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-two-sum-ii-input-array-is-sorted/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Given a 1-indexed array of integers &lt;code&gt;numbers&lt;/code&gt; that is already sorted in non-decreasing order, find two numbers such that they add up to a specific &lt;code&gt;target&lt;/code&gt; number. Let these two numbers be &lt;code&gt;numbers[index1]&lt;/code&gt; and &lt;code&gt;numbers[index2]&lt;/code&gt; where &lt;code&gt;1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Return the indices of the two numbers, &lt;code&gt;index1&lt;/code&gt; and &lt;code&gt;index2&lt;/code&gt;, added by one as an integer array &lt;code&gt;[index1, index2]&lt;/code&gt; of length 2.&lt;/p&gt;
&lt;p&gt;The tests are generated such that there is exactly one solution. You may not use the same element twice.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode - 150 - Valid Sudoku</title>
      <link>http://localhost:1313/posts/leetcode-150-valid-sudoku/</link>
      <pubDate>Fri, 16 May 2025 08:02:42 +0300</pubDate>
      <guid>http://localhost:1313/posts/leetcode-150-valid-sudoku/</guid>
      <description>&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;
&lt;p&gt;Determine if a &lt;code&gt;9 x 9&lt;/code&gt; Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Each row must contain the digits &lt;code&gt;1-9&lt;/code&gt; without repetition.&lt;/li&gt;
&lt;li&gt;Each column must contain the digits &lt;code&gt;1-9&lt;/code&gt; without repetition.&lt;/li&gt;
&lt;li&gt;Each of the nine &lt;code&gt;3 x 3&lt;/code&gt; sub-boxes of the grid must contain the digits &lt;code&gt;1-9&lt;/code&gt; without repetition.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Sudoku board (partially filled) could be valid but is not necessarily solvable.&lt;/li&gt;
&lt;li&gt;Only the filled cells need to be validated according to the mentioned rules.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;
&lt;p&gt;
    
    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-334fd&#34; hidden&gt;
    &lt;label for=&#34;zoomCheck-334fd&#34;&gt;
        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; 
            src=&#34;images/Sudoku-by-L2G-20050714.svg.png#center&#34; alt=&#34;alt image&#34; 
             /&gt;
    &lt;/label&gt;
&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
