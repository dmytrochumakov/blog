<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Oop on Dmytro&#39;s Blog</title>
    <link>http://localhost:1313/tags/oop/</link>
    <description>Recent content in Oop on Dmytro&#39;s Blog</description>
    <image>
      <title>Dmytro&#39;s Blog</title>
      <url>http://localhost:1313/images/papermod-cover.png</url>
      <link>http://localhost:1313/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.123.3</generator>
    <language>en</language>
    <lastBuildDate>Fri, 22 Mar 2024 08:29:30 +0300</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/oop/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The Memento Pattern</title>
      <link>http://localhost:1313/posts/the-memento-pattern/</link>
      <pubDate>Fri, 22 Mar 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/the-memento-pattern/</guid>
      <description>What is a Memento Pattern? The Memento Pattern helps return an object to one of its previous states; for instance, if the user requests an “undo” operation.
Source
What problems does it solve? The Memento Pattern helps solve following problems:
Undo/Redo Functionality: Memento allows you to capture an object’s state at a specific point in time and store it externally. This enables you to implement undo/redo functionality by restoring the object to its previous state.</description>
    </item>
    <item>
      <title>The Interpreter Pattern</title>
      <link>http://localhost:1313/posts/the-interpreter-pattern/</link>
      <pubDate>Mon, 18 Mar 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/the-interpreter-pattern/</guid>
      <description>What is an Interpreter Pattern? The Interpreter Pattern helps implement a simple language and defines a class based representation for its grammar along with an interpreter to interpret its sentences.
Source
What problems does it solve? The Interpreter Pattern helps solve following problems:
Language Interpretation: When you have a language or syntax that needs to be interpreted, such as mathematical expressions, regular expressions, or domain-specific languages (DSLs), the Interpreter Pattern helps in implementing the logic to interpret and execute these expressions.</description>
    </item>
    <item>
      <title>The Flyweight Pattern</title>
      <link>http://localhost:1313/posts/the-flyweight-pattern/</link>
      <pubDate>Sun, 17 Mar 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/the-flyweight-pattern/</guid>
      <description>What is a Flyweight Pattern? The Flyweight Pattern refers to an object that minimizes memory usage by sharing some of its data with other similar objects.
Source
What problems does it solve? The Flyweight Pattern helps solve following problems:
Large Memory Footprint: When dealing with a large number of objects, especially if these objects share a significant amount of common state, traditional object creation can lead to excessive memory consumption. The Flyweight Pattern reduces memory usage by sharing this common state among multiple objects.</description>
    </item>
    <item>
      <title>The Chain Of Responsibility Pattern</title>
      <link>http://localhost:1313/posts/the-chain-of-responsibility-pattern/</link>
      <pubDate>Fri, 15 Mar 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/the-chain-of-responsibility-pattern/</guid>
      <description>What is a Chain Of Responsibility Pattern? The Chain Of Responsibility Pattern helps create a chain of objects to examine requests. Each object in turn examines a request and either handles it or passes onto the next object in the chain.
Source
What problems does it solve? The Chain Of Responsibility Pattern (CoR) helps solve following problems:
Dynamic Request Handling: It enables dynamic assignment of responsibilities at runtime. Handlers can be added, removed, or reordered without affecting the client’s code.</description>
    </item>
    <item>
      <title>The State Pattern</title>
      <link>http://localhost:1313/posts/the-state-pattern/</link>
      <pubDate>Sun, 10 Mar 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/the-state-pattern/</guid>
      <description>What is a State Pattern? The State Pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.
Source
What problems does it solve? Complex conditional logic: When an object’s behavior depends on its internal state, it often leads to complex conditional statements. The State pattern simplifies this by encapsulating each state and its behavior in separate classes, making the code more readable and maintainable.</description>
    </item>
    <item>
      <title>The Dependency Inversion Principle</title>
      <link>http://localhost:1313/posts/the-dependency-inversion-principle/</link>
      <pubDate>Tue, 05 Mar 2024 08:29:30 +0300</pubDate>
      <guid>http://localhost:1313/posts/the-dependency-inversion-principle/</guid>
      <description>What is a Dependency Inversion Principle? The Dependency Inversion Principle means that high-level modules should not depend on low-level modules.
Source
Source
What problems does it solve? The Dependency Inversion Principle (DIP) helps solve:
Rigidity Fragility Immobility problems Real-world code example Violation of DIP // High-level module directly depending on low-level modules class MessageService { func sendMessageViaEmail(message: String) { let emailSender = EmailSender() emailSender.sendMessage(message: message) } func sendMessageViaSMS(message: String) { let smsSender = SMSSender() smsSender.</description>
    </item>
  </channel>
</rss>
