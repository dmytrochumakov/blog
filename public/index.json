[{"content":"Introduction I was eager to learn how converting Text To Speech works in iOS. Here is what I discovered:\nFirst Step The first step is to add AVSpeechSynthesizer, an object that produces synthesized speech from text utterances.\n@State private var speechSynthesizer = AVSpeechSynthesizer() Second Step The second step is to add AVSpeechUtterance, an object that encapsulates the text for speech synthesis.\nprivate var utterance: AVSpeechUtterance { let inputMessage = \u0026#34;Hello world!\u0026#34; let utterance = AVSpeechUtterance(string: inputMessage) utterance.voice = AVSpeechSynthesisVoice(language: \u0026#34;en-US\u0026#34;) return utterance } Optional You can configure pitch, rate, and voice parameters.\nThird Step The third step is to add a speak method that actually allows you to convert Text To Speech.\nspeechSynthesizer.speak(utterance) Complete Example import SwiftUI import AVFoundation struct ContentView: View { @State private var speechSynthesizer = AVSpeechSynthesizer() private var utterance: AVSpeechUtterance { let inputMessage = \u0026#34;Hello world!\u0026#34; let utterance = AVSpeechUtterance(string: inputMessage) utterance.voice = AVSpeechSynthesisVoice(language: \u0026#34;en-US\u0026#34;) return utterance } var body: some View { VStack { Button(\u0026#34;Speak\u0026#34;) { speechSynthesizer.speak(utterance) } } .padding() } } #Preview { ContentView() } Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/text-to-speech-ios/","summary":"Introduction I was eager to learn how converting Text To Speech works in iOS. Here is what I discovered:\nFirst Step The first step is to add AVSpeechSynthesizer, an object that produces synthesized speech from text utterances.\n@State private var speechSynthesizer = AVSpeechSynthesizer() Second Step The second step is to add AVSpeechUtterance, an object that encapsulates the text for speech synthesis.\nprivate var utterance: AVSpeechUtterance { let inputMessage = \u0026#34;Hello world!","title":"Text To Speech iOS"},{"content":"Introduction I always wanted an iOS app that would allow me to economize my time by converting speech to text. I know this option is built into the keyboard, but you first need to click the text field, then tap on the microphone, and finally speak. I wanted a one-click option with the possibility to integrate it into all my daily routines. Here is what I discovered:\nFirst Step The first step is to request authorization to access the device\u0026rsquo;s microphone using the Privacy - Speech Recognition Usage Description key and the Privacy - Microphone Usage Description key.\nSecond Step The second step is to add a SpeechRecognizerService that will detect and transcribe speech. It consists of SFSpeechRecognizer, AVAudioSession, and AVAudioEngine. Your transcribed speech will be stored in the transcript property.\nimport Foundation import AVFoundation import Speech /// A helper for transcribing speech to text using SFSpeechRecognizer and AVAudioEngine. actor SpeechRecognizerService: ObservableObject { enum RecognizerError: Error { case nilRecognizer case notAuthorizedToRecognize case notPermittedToRecord case recognizerIsUnavailable var message: String { switch self { case .nilRecognizer: return \u0026#34;Can\u0026#39;t initialize speech recognizer\u0026#34; case .notAuthorizedToRecognize: return \u0026#34;Not authorized to recognize speech\u0026#34; case .notPermittedToRecord: return \u0026#34;Not permitted to record audio\u0026#34; case .recognizerIsUnavailable: return \u0026#34;Recognizer is unavailable\u0026#34; } } } @MainActor @Published private(set) var transcript: String = \u0026#34;\u0026#34; private var audioEngine: AVAudioEngine? private var request: SFSpeechAudioBufferRecognitionRequest? private var task: SFSpeechRecognitionTask? private let recognizer: SFSpeechRecognizer? /** Initializes a new speech recognizer. If this is the first time you\u0026#39;ve used the class, it requests access to the speech recognizer and the microphone. */ init() { recognizer = SFSpeechRecognizer() guard recognizer != nil else { transcribe(RecognizerError.nilRecognizer) return } Task { do { guard await SFSpeechRecognizer.hasAuthorizationToRecognize() else { throw RecognizerError.notAuthorizedToRecognize } guard await AVAudioSession.sharedInstance().hasPermissionToRecord() else { throw RecognizerError.notPermittedToRecord } } catch { transcribe(error) } } } @MainActor func startTranscribing() { Task { await transcribe() } } @MainActor func resetTranscript() { Task { await reset() } } @MainActor func stopTranscribing() { Task { await reset() } } } private extension SpeechRecognizerService { /** Begin transcribing audio. Creates a `SFSpeechRecognitionTask` that transcribes speech to text until you call `stopTranscribing()`. The resulting transcription is continuously written to the published `transcript` property. */ func transcribe() { guard let recognizer, recognizer.isAvailable else { self.transcribe(RecognizerError.recognizerIsUnavailable) return } do { let (audioEngine, request) = try Self.prepareEngine() self.audioEngine = audioEngine self.request = request self.task = recognizer.recognitionTask(with: request, resultHandler: { [weak self] result, error in self?.recognitionHandler(audioEngine: audioEngine, result: result, error: error) }) } catch { self.reset() self.transcribe(error) } } /// Reset the speech recognizer. func reset() { task?.cancel() audioEngine?.stop() audioEngine = nil request = nil task = nil } static func prepareEngine() throws -\u0026gt; (AVAudioEngine, SFSpeechAudioBufferRecognitionRequest) { let audioEngine = AVAudioEngine() let request = SFSpeechAudioBufferRecognitionRequest() request.shouldReportPartialResults = true let audioSession = AVAudioSession.sharedInstance() try audioSession.setCategory(.playAndRecord, mode: .measurement, options: .duckOthers) try audioSession.setActive(true, options: .notifyOthersOnDeactivation) let inputNode = audioEngine.inputNode let recordingFormat = inputNode.outputFormat(forBus: 0) inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) { (buffer: AVAudioPCMBuffer, when: AVAudioTime) in request.append(buffer) } audioEngine.prepare() try audioEngine.start() return (audioEngine, request) } nonisolated func recognitionHandler(audioEngine: AVAudioEngine, result: SFSpeechRecognitionResult?, error: Error?) { let receivedFinalResult = result?.isFinal ?? false let receivedError = error != nil if receivedFinalResult || receivedError { audioEngine.stop() audioEngine.inputNode.removeTap(onBus: 0) } if let result { transcribe(result.bestTranscription.formattedString) } } nonisolated func transcribe(_ message: String) { Task { @MainActor in transcript = message } } nonisolated func transcribe(_ error: Error) { var errorMessage = \u0026#34;\u0026#34; if let error = error as? RecognizerError { errorMessage += error.message } else { errorMessage += error.localizedDescription } Task { @MainActor [errorMessage] in transcript = \u0026#34;\u0026lt;\u0026lt; \\(errorMessage) \u0026gt;\u0026gt;\u0026#34; } } } extension SFSpeechRecognizer { static func hasAuthorizationToRecognize() async -\u0026gt; Bool { await withCheckedContinuation { continuation in requestAuthorization { status in continuation.resume(returning: status == .authorized) } } } } extension AVAudioSession { func hasPermissionToRecord() async -\u0026gt; Bool { await withCheckedContinuation { continuation in requestRecordPermission { authorized in continuation.resume(returning: authorized) } } } } Third Step The third step is to integrate speech recognition.\nimport SwiftUI struct ContentView: View { @StateObject private var speechRecognizerService: SpeechRecognizerService = SpeechRecognizerService() var body: some View { ScrollView { VStack { Button(\u0026#34;Start\u0026#34;) { speechRecognizerService.startTranscribing() } Divider() Button(\u0026#34;Stop\u0026#34;) { speechRecognizerService.stopTranscribing() } Divider() Text(speechRecognizerService.transcript) } } .padding() } } #Preview { ContentView() } Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/speech-to-text-ios/","summary":"Introduction I always wanted an iOS app that would allow me to economize my time by converting speech to text. I know this option is built into the keyboard, but you first need to click the text field, then tap on the microphone, and finally speak. I wanted a one-click option with the possibility to integrate it into all my daily routines. Here is what I discovered:\nFirst Step The first step is to request authorization to access the device\u0026rsquo;s microphone using the Privacy - Speech Recognition Usage Description key and the Privacy - Microphone Usage Description key.","title":"Speech To Text iOS"},{"content":"Introduction I was curious about creating animations in UIKit. I wanted to animate different properties such as color and path. Here is what I found:\nItâ€™s impossible to create complex animations only by using the block-based animation API. To do that, you need the Core Animation API and CAPropertyAnimation with its various subclasses.\nComplex animation in UIKit is based on a few key components:\nCAShapeLayer - provides extensive customization options: path, stroke, fill, shadow CABasicAnimation - helps animate color or change the path Implementation First Step The first step is to create a shape layer that will draw an arrow using CAShapeLayer.\nprivate lazy var arrowShapeLayer: CAShapeLayer = { let arrowShapeLayer = CAShapeLayer() arrowShapeLayer.strokeColor = direction.arrowColour.cgColor arrowShapeLayer.lineWidth = ArrowView.arrowLineWidth arrowShapeLayer.lineCap = .round arrowShapeLayer.fillColor = UIColor.clear.cgColor return arrowShapeLayer }() Second Step The second step is to animate the arrow direction by changing the shape layer\u0026rsquo;s path and stroke color.\nvar direction: Direction = .up { didSet { guard oldValue != direction else { return } let pathAnimation = CABasicAnimation(keyPath: \u0026#34;path\u0026#34;) pathAnimation.fromValue = arrowShapeLayer.presentation()?.path pathAnimation.duration = 0.5 arrowShapeLayer.add(pathAnimation, forKey: \u0026#34;pathAnimation\u0026#34;) let strokeColourAnimation = CABasicAnimation(keyPath: \u0026#34;strokeColor\u0026#34;) strokeColourAnimation.fromValue = arrowShapeLayer.presentation()?.strokeColor strokeColourAnimation.duration = 0.5 arrowShapeLayer.add(strokeColourAnimation, forKey: \u0026#34;strokeColourAnimation\u0026#34;) arrowShapeLayer.path = direction.arrowPath(in: bounds).cgPath arrowShapeLayer.strokeColor = direction.arrowColour.cgColor } } Third Step The third step is to synchronize Core Animation with UIKit animation by requesting the CAAction property.\nvar direction: Direction = .up { didSet { guard oldValue != direction else { return } if let backgroundColourAnimation = action(for: layer, forKey: \u0026#34;backgroundColor\u0026#34;) as? CABasicAnimation { let pathAnimation = backgroundColourAnimation.copy(forKeyPath: \u0026#34;path\u0026#34;) pathAnimation.fromValue = arrowShapeLayer.presentation()?.path arrowShapeLayer.add(pathAnimation, forKey: \u0026#34;pathAnimation\u0026#34;) let strokeColourAnimation = backgroundColourAnimation.copy(forKeyPath: \u0026#34;strokeColor\u0026#34;) strokeColourAnimation.fromValue = arrowShapeLayer.presentation()?.strokeColor arrowShapeLayer.add(strokeColourAnimation, forKey: \u0026#34;strokeColourAnimation\u0026#34;) } arrowShapeLayer.path = direction.arrowPath(in: bounds).cgPath arrowShapeLayer.strokeColor = direction.arrowColour.cgColor } } Resources If you are curious, I would recommend you read a more detailed explanation from Darjeeling Steve\u0026rsquo;s blog. I found this resource incredible and full of comprehensive information.\nThank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/animation-uikit/","summary":"Introduction I was curious about creating animations in UIKit. I wanted to animate different properties such as color and path. Here is what I found:\nItâ€™s impossible to create complex animations only by using the block-based animation API. To do that, you need the Core Animation API and CAPropertyAnimation with its various subclasses.\nComplex animation in UIKit is based on a few key components:\nCAShapeLayer - provides extensive customization options: path, stroke, fill, shadow CABasicAnimation - helps animate color or change the path Implementation First Step The first step is to create a shape layer that will draw an arrow using CAShapeLayer.","title":"Animation - UIKit"},{"content":"Introduction I was eager to learn about creating complex animations in SwiftUI. The few questions that were on my mind included what types of animations exist and what I can animate. Here is what I found:\nTypes of Animation SwiftUI has explicit and implicit animation types.\nImplicit Animation: This is specified with the .animation() modifier. SwiftUI will animate changes in old and new values.\nstruct ImplicitAnimation: View { @State private var half = false @State private var dim = false var body: some View { Image(\u0026#34;tower\u0026#34;) .scaleEffect(half ? 0.5 : 1.0) .opacity(dim ? 0.2 : 1.0) .animation(.easeInOut(duration: 1.0)) .onTapGesture { self.dim.toggle() self.half.toggle() } } } Explicit Animation: This is specified with the withAnimation closure. Only those parameters that depend on a value changed inside the withAnimation closure will be animated.\nstruct ExplicitAnimation: View { @State private var half = false @State private var dim = false var body: some View { Image(\u0026#34;tower\u0026#34;) .scaleEffect(half ? 0.5 : 1.0) .opacity(dim ? 0.5 : 1.0) .onTapGesture { self.half.toggle() withAnimation(.easeInOut(duration: 1.0)) { self.dim.toggle() } } } } What is Possible to Animate You can animate single parameters such as size, offset, color, scale, etc. You can conform to the Animatable protocol and describe how to animate a property of a view. You can also animate multiple parameters with AnimatablePair. Resources An invaluable resource is The SwiftUI Lab, which has more than 5 posts only about animation in SwiftUI.\nThank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/animation-swiftui/","summary":"Introduction I was eager to learn about creating complex animations in SwiftUI. The few questions that were on my mind included what types of animations exist and what I can animate. Here is what I found:\nTypes of Animation SwiftUI has explicit and implicit animation types.\nImplicit Animation: This is specified with the .animation() modifier. SwiftUI will animate changes in old and new values.\nstruct ImplicitAnimation: View { @State private var half = false @State private var dim = false var body: some View { Image(\u0026#34;tower\u0026#34;) .","title":"Animation - SwiftUI"},{"content":"Introduction I previously never had a chance to work with GraphQL. I was excited to learn when to apply this technology, what tools I can use, and how I can implement it. Hereâ€™s what I found:\nFor testing, I used the Star Wars GraphQL API with AllFilmsQuery:\nquery AllFilmsQuery { allFilms { films { title director created producers releaseDate } } } I requested allFilms with title, director, created, producers, and releaseDate information.\nWhen to Apply This Technology The best way to use GraphQL is when you have multiple platform applications such as web, mobile, and TV, and each client needs to request the specific data they require. It\u0026rsquo;s also beneficial when you need to fetch complex, nested, or related data from multiple sources. What Tools to Use GraphiQL Live Demo - A graphical interactive in-browser GraphQL IDE. Apollo iOS Docs - Apollo iOS is an open-source GraphQL client for native client applications, written in Swift. Apollo iOS Code Generation CLI - A CLI to generate boilerplate code. Caveats Before diving into implementation, I would like to highlight a few nuances.\nYou need to add NetworkInterceptorProvider and AuthorizationInterceptor to authenticate your operations. Without them, you won\u0026rsquo;t be able to access the data on your server.\nHow to Implement It Client class NetworkInterceptorProvider: DefaultInterceptorProvider { override func interceptors\u0026lt;Operation\u0026gt;(for operation: Operation) -\u0026gt; [ApolloInterceptor] where Operation : GraphQLOperation { var interceptors = super.interceptors(for: operation) interceptors.insert(AuthorizationInterceptor(), at: 0) return interceptors } } class AuthorizationInterceptor: ApolloInterceptor { let id: String = UUID().uuidString func interceptAsync\u0026lt;Operation\u0026gt;( chain: RequestChain, request: HTTPRequest\u0026lt;Operation\u0026gt;, response: HTTPResponse\u0026lt;Operation\u0026gt;?, completion: @escaping (Result\u0026lt;GraphQLResult\u0026lt;Operation.Data\u0026gt;, Error\u0026gt;) -\u0026gt; Void ) where Operation : GraphQLOperation { chain.proceedAsync(request: request, response: response, completion: completion) } } private let apollo: ApolloClient = { let client = URLSessionClient() let cache = InMemoryNormalizedCache() let store = ApolloStore(cache: cache) let provider = NetworkInterceptorProvider(client: client, store: store) let url = URL(string: \u0026#34;https://swapi-graphql.netlify.app/.netlify/functions/index\u0026#34;)! let transport = RequestChainNetworkTransport(interceptorProvider: provider, endpointURL: url) return ApolloClient(networkTransport: transport, store: store) }() UI import SwiftUI import Apollo import StarWarsAPI struct ContentView: View { @State private var list: [AllFilmsQuery.Data.AllFilms.Film?] = [] var body: some View { VStack { ForEach(list, id: \\.self) { row in Text(row?.title ?? \u0026#34;\u0026#34;) } }.onAppear(perform: { apollo.fetch(query: AllFilmsQuery()) { result in switch result { case .success(let response): self.list = response.data?.allFilms?.films ?? [] case .failure(let error): print(error) } } }) .padding() } } #Preview { ContentView() } References You can find more detailed information in the amazing post Unleashing the Power of GraphQL in Your iOS App where you can find step-by-step instructions on how to use Apollo iOS and GraphQL. I also recommend watching the video â€œAdopting GraphQL\u0026quot; by Carola Nitz, hosted by Swiftable. Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/implementing-graphql-in-an-ios-application/","summary":"Introduction I previously never had a chance to work with GraphQL. I was excited to learn when to apply this technology, what tools I can use, and how I can implement it. Hereâ€™s what I found:\nFor testing, I used the Star Wars GraphQL API with AllFilmsQuery:\nquery AllFilmsQuery { allFilms { films { title director created producers releaseDate } } } I requested allFilms with title, director, created, producers, and releaseDate information.","title":"Implementing GraphQL in an iOS application"},{"content":"Introduction I was eager to learn about securing user data using Keychain and biometric authentication. Here are a few steps I found:\nCaveats You can test accessing Keychain data using Touch ID and Face ID only on a real device.\nFirst Step The first step is to add the Privacy - Face ID Usage Description key to your Info.plist. Without it, you would not be able to retrieve data from Keychain using Face ID.\nSecond Step The second step would be to add the addCredentials method to be able to save user data to Keychain.\n/// Stores credentials for the given server. func addCredentials(_ credentials: Credentials, server: String) throws { // Use the username as the account, and get the password as data. let account = credentials.username let password = credentials.password.data(using: String.Encoding.utf8)! // Create an access control instance that dictates how the item can be read later. let access = SecAccessControlCreateWithFlags(nil, // Use the default allocator. kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly, .userPresence, nil) // Ignore any error. // Allow a device unlock in the last 10 seconds to be used to get at keychain items. let context = LAContext() context.touchIDAuthenticationAllowableReuseDuration = 10 // Build the query for use in the add operation. let query: [String: Any] = [kSecClass as String: kSecClassInternetPassword, kSecAttrAccount as String: account, kSecAttrServer as String: server, kSecAttrAccessControl as String: access as Any, kSecUseAuthenticationContext as String: context, kSecValueData as String: password] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainError(status: status) } } Third Step The third step is to add the readCredentials method to be capable of retrieving user data from Keychain.\n/// Reads the stored credentials for the given server. func readCredentials(server: String) throws -\u0026gt; Credentials { let context = LAContext() context.localizedReason = \u0026#34;Access your password on the keychain\u0026#34; let query: [String: Any] = [kSecClass as String: kSecClassInternetPassword, kSecAttrServer as String: server, kSecMatchLimit as String: kSecMatchLimitOne, kSecReturnAttributes as String: true, kSecUseAuthenticationContext as String: context, kSecReturnData as String: true] var item: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, \u0026amp;item) guard status == errSecSuccess else { throw KeychainError(status: status) } guard let existingItem = item as? [String: Any], let passwordData = existingItem[kSecValueData as String] as? Data, let password = String(data: passwordData, encoding: String.Encoding.utf8), let account = existingItem[kSecAttrAccount as String] as? String else { throw KeychainError(status: errSecInternalError) } return Credentials(username: account, password: password) } Fourth Step The fourth step is to add the deleteCredentials method to have the ability to delete user data from Keychain.\n/// Deletes credentials for the given server. func deleteCredentials(server: String) throws { let query: [String: Any] = [kSecClass as String: kSecClassInternetPassword, kSecAttrServer as String: server] let status = SecItemDelete(query as CFDictionary) guard status == errSecSuccess else { throw KeychainError(status: status) } } UI import SwiftUI import LocalAuthentication struct ContentView: View { @State private var status: String = \u0026#34;\u0026#34; var body: some View { VStack { ForEach(Command.allCases) { command in Button(command.rawValue) { switch command { case .add: // Normally, username and password would come from the user interface. let credentials = Credentials(username: \u0026#34;appleseed\u0026#34;, password: \u0026#34;1234\u0026#34;) do { try addCredentials(credentials, server: server) status = statusMessage(.add, nil) } catch { status = error.localizedDescription } case .read: do { status = statusMessage(.read, try readCredentials(server: server)) } catch { status = error.localizedDescription } case .delete: do { try deleteCredentials(server: server) status = statusMessage(.delete, nil) } catch { status = error.localizedDescription } } } if command != .delete { Spacer() } } Spacer() Text(status) } } } Helpers enum Command: String, CaseIterable, Identifiable { var id: String { rawValue } case add case read case delete } /// The username and password that we want to store or read. struct Credentials { var username: String var password: String } /// Keychain errors we might encounter. struct KeychainError: Error { var status: OSStatus var localizedDescription: String { return SecCopyErrorMessageString(status, nil) as String? ?? \u0026#34;Unknown error.\u0026#34; } } /// The server we are accessing with the credentials. let server = \u0026#34;www.example.com\u0026#34; func statusMessage(_ command: Command, _ credentials: Credentials? = nil) -\u0026gt; String { switch command { case .add: return \u0026#34;Added credentials.\u0026#34; case .read: return \u0026#34;Read credentials: \\(credentials!.username)/\\(credentials!.password)\u0026#34; case .delete: return \u0026#34;Deleted credentials.\u0026#34; } } You can find more detailed information and project details in the Apple Developer Documentation.\nThank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/securing-user-data-with-keychain-touch-id-and-face-id/","summary":"Introduction I was eager to learn about securing user data using Keychain and biometric authentication. Here are a few steps I found:\nCaveats You can test accessing Keychain data using Touch ID and Face ID only on a real device.\nFirst Step The first step is to add the Privacy - Face ID Usage Description key to your Info.plist. Without it, you would not be able to retrieve data from Keychain using Face ID.","title":"Securing user data with Keychain, Touch ID, and Face ID"},{"content":"Introduction I was wondering how to add in-app purchases to my app. I chose non-consumable in-app purchase because you can pay one time for this item. Here are a few steps on how I did it.\nFirst Step Set up In-App Purchases for your app in App Store Connect account or add a .storekit configuration file and start from there. If you\u0026rsquo;ve already set up In-App Purchases in your account, you can sync the StoreKit config with that data.\nCaveats Be aware that if you choose to set up the StoreKit configuration file first, you will not find that file in the Xcode 15.3.0 iOS template. Instead, switch to macOS and search for it there.\nSecond Step fetchProducts by identifiers to retrieve data and by using an SKProductsRequestDelegate to receive and display products.\nfunc fetchProducts() { let productIDs: Set\u0026lt;String\u0026gt; = [\u0026#34;com.remove.ads.nonconsumable\u0026#34;] let request = SKProductsRequest(productIdentifiers: productIDs) request.delegate = self request.start() } // MARK: - SKProductsRequestDelegate extension ViewModel: SKProductsRequestDelegate { func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) { DispatchQueue.main.async { self.products = response.products.map { product in Product(id: product.productIdentifier, title: product.localizedTitle, price: product.price.doubleValue) } for product in response.products { self.productsMap[product.productIdentifier] = product } } } } Third Step Add a purchaseProduct method and connect the view model with the UI.\nfunc purchaseProduct(product: Product) { guard SKPaymentQueue.canMakePayments() else { errorMessage = \u0026#34;In-app purchases are disabled on this device.\u0026#34; return } guard let skProduct = productsMap[product.id] else { errorMessage = \u0026#34;Product information not available.\u0026#34; return } let payment = SKPayment(product: skProduct) SKPaymentQueue.default().add(payment) } UI var body: some View { ZStack(alignment: .top) { VStack(spacing: 10) { Text(\u0026#34;With StoreKit 2\u0026#34;) .padding() ForEach(viewModel.products) { product in Button { viewModel.purchaseProduct(product: product) } label: { Text(product.title) } } } .padding() } .onAppear(perform: { viewModel.fetchProducts() }) } ViewModel final class ViewModel: NSObject, ObservableObject { @Published var products: [Product] = [] private var productsMap: [String: SKProduct] = [:] @Published var errorMessage: String? func fetchProducts() { let productIDs: Set\u0026lt;String\u0026gt; = [\u0026#34;com.remove.ads.nonconsumable\u0026#34;] let request = SKProductsRequest(productIdentifiers: productIDs) request.delegate = self request.start() } func purchaseProduct(product: Product) { guard SKPaymentQueue.canMakePayments() else { errorMessage = \u0026#34;In-app purchases are disabled on this device.\u0026#34; return } guard let skProduct = productsMap[product.id] else { errorMessage = \u0026#34;Product information not available.\u0026#34; return } let payment = SKPayment(product: skProduct) SKPaymentQueue.default().add(payment) } } // MARK: - SKProductsRequestDelegate extension ViewModel: SKProductsRequestDelegate { func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) { DispatchQueue.main.async { self.products = response.products.map { product in Product(id: product.productIdentifier, title: product.localizedTitle, price: product.price.doubleValue) } for product in response.products { self.productsMap[product.productIdentifier] = product } } } } Helpers struct Product: Identifiable { let id: String let title: String let price: Double } Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/implementing-in-app-purchases-to-swiftui-app-using-storekit-2/","summary":"Introduction I was wondering how to add in-app purchases to my app. I chose non-consumable in-app purchase because you can pay one time for this item. Here are a few steps on how I did it.\nFirst Step Set up In-App Purchases for your app in App Store Connect account or add a .storekit configuration file and start from there. If you\u0026rsquo;ve already set up In-App Purchases in your account, you can sync the StoreKit config with that data.","title":"Implementing In-App Purchases to SwiftUI app using StoreKit 2"},{"content":"Introduction Sometime ago, I was working on a marketplace app, and I needed to add Apple Pay to make purchases more easily. Here are a few steps on how I did it: First Step You need to add Apple Pay capability to your project. You will need to Register a Merchant ID. I will skip this step; you can find info by following this link Setting up Apple Pay. Second Step You will need to import PassKit and create PKPaymentRequest to interact with PKPaymentAuthorizationController and PKPaymentAuthorizationControllerDelegate. func initiateApplePay() { // Create payment request let paymentRequest = PKPaymentRequest() paymentRequest.merchantIdentifier = \u0026#34;your_merchant_identifier\u0026#34; paymentRequest.countryCode = \u0026#34;US\u0026#34; paymentRequest.currencyCode = \u0026#34;USD\u0026#34; paymentRequest.supportedNetworks = [.visa, .masterCard, .amex] paymentRequest.merchantCapabilities = .threeDSecure // Add payment items from cart for item in cartItems { let paymentItem = PKPaymentSummaryItem(label: item.name, amount: item.price) paymentRequest.paymentSummaryItems.append(paymentItem) } // Add total amount let totalItem = PKPaymentSummaryItem(label: \u0026#34;Total\u0026#34;, amount: totalAmount) paymentRequest.paymentSummaryItems.append(totalItem) // Present Apple Pay sheet let paymentController = PKPaymentAuthorizationController(paymentRequest: paymentRequest) paymentController.delegate = self paymentController.present(completion: nil) } Third Step Add UI and connect it with the view model.\nUI import SwiftUI struct ContentView: View { @StateObject private var viewModel = MarketplaceViewModel() var body: some View { VStack { List(viewModel.products) { product in HStack { Text(product.name) Spacer() Text(product.price.stringValue + \u0026#34;$\u0026#34;) Button(viewModel.inCart(product: product) ? \u0026#34;\u0026#34; : \u0026#34;Add to cart\u0026#34;) { viewModel.addToCart(product: product) } } } Text(\u0026#34;Total: \\(viewModel.totalAmount)\u0026#34;) Button(\u0026#34;Pay with Apple Pay\u0026#34;) { viewModel.initiateApplePay() } .padding() } } } #Preview { ContentView() } ViewModel final class MarketplaceViewModel: NSObject, ObservableObject { private var cartItems: [Product] = [] @Published private(set) var totalAmount: NSDecimalNumber = 0.0 @Published private(set) var products: [Product] = [] func fetchProducts() { Task { self.products = await ProductService.getProducts() } } func inCart(product: Product) -\u0026gt; Bool { cartItems.contains(product) } override init() { super.init() fetchProducts() } private func calculateTotalAmount() { totalAmount = cartItems.reduce(0) { $0.adding($1.price) } } func addToCart(product: Product) { cartItems.append(product) calculateTotalAmount() } func initiateApplePay() { // Create payment request let paymentRequest = PKPaymentRequest() paymentRequest.merchantIdentifier = \u0026#34;your_merchant_identifier\u0026#34; paymentRequest.countryCode = \u0026#34;US\u0026#34; paymentRequest.currencyCode = \u0026#34;USD\u0026#34; paymentRequest.supportedNetworks = [.visa, .masterCard, .amex] paymentRequest.merchantCapabilities = .threeDSecure // Add payment items from cart for item in cartItems { let paymentItem = PKPaymentSummaryItem(label: item.name, amount: item.price) paymentRequest.paymentSummaryItems.append(paymentItem) } // Add total amount let totalItem = PKPaymentSummaryItem(label: \u0026#34;Total\u0026#34;, amount: totalAmount) paymentRequest.paymentSummaryItems.append(totalItem) // Present Apple Pay sheet let paymentController = PKPaymentAuthorizationController(paymentRequest: paymentRequest) paymentController.delegate = self paymentController.present(completion: nil) } } // MARK: - PKPaymentAuthorizationControllerDelegate extension MarketplaceViewModel: PKPaymentAuthorizationControllerDelegate { func paymentAuthorizationController(_ controller: PKPaymentAuthorizationController, didAuthorizePayment payment: PKPayment, handler completion: @escaping (PKPaymentAuthorizationResult) -\u0026gt; Void) { let paymentResult = PKPaymentAuthorizationResult(status: .success, errors: nil) completion(paymentResult) } func paymentAuthorizationControllerDidFinish(_ controller: PKPaymentAuthorizationController) { controller.dismiss(completion: nil) } } Helpers struct Product: Identifiable, Equatable { let id: UUID let name: String let price: NSDecimalNumber } final class ProductService { static func getProducts() async -\u0026gt; [Product] { let products: [Product] = [ Product(id: UUID(), name: \u0026#34;Product 1\u0026#34;, price: 10.0), Product(id: UUID(), name: \u0026#34;Product 2\u0026#34;, price: 20.0), Product(id: UUID(), name: \u0026#34;Product 3\u0026#34;, price: 15.0) ] return products } } Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/implementing-apple-pay-in-a-swiftui-app/","summary":"Introduction Sometime ago, I was working on a marketplace app, and I needed to add Apple Pay to make purchases more easily. Here are a few steps on how I did it: First Step You need to add Apple Pay capability to your project. You will need to Register a Merchant ID. I will skip this step; you can find info by following this link Setting up Apple Pay. Second Step You will need to import PassKit and create PKPaymentRequest to interact with PKPaymentAuthorizationController and PKPaymentAuthorizationControllerDelegate.","title":"Implementing Apple Pay in a SwiftUI app"},{"content":"Introduction I have been looking for information about implementation details of integration testing. I found a lot of information, but it was theoretical and all information looked the same. I did not find a meaningful example, so I tried to come up with my own definition and sample.\nIntegration testing means testing the behavior between modules or views to ensure they work as expected after user actions.\nThere are two ways of conducting integration testing: The first is by unit tests, where you try to test the flowing data between view models. The second is UI tests, where you try to test if the UI items exist and navigation works correctly. I will focus on testing the flowing data between view models.\nSample: List View and Detail View When you tap on a row in the list, you expect that:\nThe selected item will pass to the detail view. The detail view will receive this item. The selected item will be equal to the passed item. import XCTest @testable import IntegrationTesting final class IntegrationTestingTests: XCTestCase { func testItemSelection() { let viewModel = MockItemListViewModel(service: MockItemService()) let selectedIndex = 1 let itemListView = ItemListView(viewModel: viewModel, didSelectItem: { let itemDetailView = ItemDetailView(selectedItem: $0) XCTAssertEqual(itemDetailView.selectedItem?.name, viewModel.items[selectedIndex].name) }) itemListView.didSelectItem(viewModel.items[selectedIndex]) } } Helpers import Combine final class MockItemListViewModel: ItemListViewModel { var selectedItem: Item? = nil } class ItemListViewModel: ObservableObject { @Published var items: [Item] = [] private var cancellables: Set\u0026lt;AnyCancellable\u0026gt; = [] private let service: ItemService init(service: ItemService) { self.service = service fetchItems() } func fetchItems() { service.fetchItems() .sink { completion in // Handle error or completion if necessary } receiveValue: { [weak self] items in self?.items = items } .store(in: \u0026amp;cancellables) } } import Combine protocol ItemService { func fetchItems() -\u0026gt; AnyPublisher\u0026lt;[Item], Error\u0026gt; } final class MockItemService: ItemService { func fetchItems() -\u0026gt; AnyPublisher\u0026lt;[Item], Error\u0026gt; { return Just([Item(name: \u0026#34;Item 1\u0026#34;), Item(name: \u0026#34;Item 2\u0026#34;)]) .setFailureType(to: Error.self) .eraseToAnyPublisher() } } import SwiftUI struct ItemListView: View { @ObservedObject var viewModel: ItemListViewModel var didSelectItem: (Item) -\u0026gt; Void var body: some View { List(viewModel.items) { item in Button(action: { didSelectItem(item) }) { Text(item.name) } }.accessibilityIdentifier(\u0026#34;ItemListView\u0026#34;) } } import SwiftUI struct ItemDetailView: View { var selectedItem: Item? var body: some View { if let item = selectedItem { Text(\u0026#34;Item Detail: \\(item.name)\u0026#34;) } else { Text(\u0026#34;No item selected\u0026#34;) } } } Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/integration-testing-for-swiftui-views/","summary":"Introduction I have been looking for information about implementation details of integration testing. I found a lot of information, but it was theoretical and all information looked the same. I did not find a meaningful example, so I tried to come up with my own definition and sample.\nIntegration testing means testing the behavior between modules or views to ensure they work as expected after user actions.\nThere are two ways of conducting integration testing: The first is by unit tests, where you try to test the flowing data between view models.","title":"Integration testing for SwiftUI views"},{"content":"Introduction After spending some time developing my personal iOS app, I found myself in a position where I needed to add UI tests to my application. The reason behind this decision was the necessity to change the architecture to make it more scalable. However, this task proved to be challenging due to certain parts of the code being tightly coupled. The situation was quite frustrating. To address this problem, I decided to incorporate UI tests that could help identify issues during the refactoring process.\nCaveats Make sure to run UI tests from a generated bundle specifically designed for UI testing. If you attempt to test the UI using a bundle intended for Unit tests, you will consistently encounter the error: No target application path specified via test configuration: \u0026lt;XCTestConfiguration: 0x102b051f0\u0026gt;. Also, don\u0026rsquo;t forget to hide the keyboard when necessary. If you need to tap on the tab bar and forget to close it, the operation will not succeed because it won\u0026rsquo;t be able to locate the tab bar button. To resolve this, simply add the following code: app.buttons[\u0026#34;Return\u0026#34;].tap() Implementation Here\u0026rsquo;s an example of a To-Do list with functionalities for listing and adding tasks.\nUI Tests var app: XCUIApplication! override func setUpWithError() throws { continueAfterFailure = false app = XCUIApplication() app.launch() } func testAddTask() throws { let addTaskTab = app.tabBars.buttons[\u0026#34;Add Task\u0026#34;] addTaskTab.tap() let textField = app.textFields[\u0026#34;Enter task\u0026#34;] textField.tap() textField.typeText(\u0026#34;New Task\u0026#34;) // Dismiss the keyboard app.buttons[\u0026#34;Return\u0026#34;].tap() let addTaskButton = app.buttons[\u0026#34;AddTaskButton\u0026#34;] addTaskButton.tap() app.tabBars.buttons[\u0026#34;Tasks\u0026#34;].tap() XCTAssertTrue(app.staticTexts[\u0026#34;New Task\u0026#34;].exists) } UI struct ContentView: View { @StateObject var viewModel = TaskViewModel() var body: some View { TabView { TaskListView(viewModel: viewModel) .tabItem { Image(systemName: \u0026#34;list.bullet\u0026#34;) Text(\u0026#34;Tasks\u0026#34;) } AddTaskView(viewModel: viewModel) .tabItem { Image(systemName: \u0026#34;plus.circle\u0026#34;) Text(\u0026#34;Add Task\u0026#34;) } } } } struct TaskListView: View { @ObservedObject var viewModel: TaskViewModel var body: some View { NavigationView { List(viewModel.tasks) { task in Text(task.title) } .navigationBarTitle(\u0026#34;Tasks\u0026#34;) } } } struct AddTaskView: View { @ObservedObject var viewModel: TaskViewModel @State private var newTaskTitle = \u0026#34;\u0026#34; var body: some View { VStack { TextField(\u0026#34;Enter task\u0026#34;, text: $newTaskTitle) .padding() Button(\u0026#34;Add Task\u0026#34;) { viewModel.addTask(title: newTaskTitle) newTaskTitle = \u0026#34;\u0026#34; } .accessibilityIdentifier(\u0026#34;AddTaskButton\u0026#34;) .padding() } .navigationTitle(\u0026#34;Add Task\u0026#34;) } } final class TaskViewModel: ObservableObject { @Published var tasks: [Task] = [] func addTask(title: String) { let newTask = Task(title: title) tasks.append(newTask) } } struct Task: Identifiable { let id = UUID() var title: String var isCompleted: Bool = false } Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/ui-testing-swiftui-views-using-xctest-framework/","summary":"Introduction After spending some time developing my personal iOS app, I found myself in a position where I needed to add UI tests to my application. The reason behind this decision was the necessity to change the architecture to make it more scalable. However, this task proved to be challenging due to certain parts of the code being tightly coupled. The situation was quite frustrating. To address this problem, I decided to incorporate UI tests that could help identify issues during the refactoring process.","title":"UI testing SwiftUI views using XCTest Framework"},{"content":"Introduction I was curious about how to add Dynamic Island and implement it into a Video Streaming App. Here are a few steps on how you can achieve this.\nCaveats Debugging Dynamic Island can be a bit tricky; it only works when the main app is running. If you try to run it separately, you will encounter the error SendProcessControlEvent:toPid: encountered an error: Error Domain=com.apple.dt.deviceprocesscontrolservice Code=8 \u0026quot;Failed to show Widget\u0026quot;. The solution is to configure live activities and run them through the main app. Be aware that when you add a widget to the project, in some cases, it adds all main target files to Compile Sources. Implementation Dynamic Islands are divided into different sizes: minimal, compactTrailing, compactLeading, and expanded. Before proceeding, you need to add LiveActivityManager to be able to display Dynamic Islands.\nimport Foundation import ActivityKit struct VideoStreamingWidgetActivityAttributes: ActivityAttributes { struct ContentState: Codable, Hashable { var isPlaying: String = \u0026#34;0\u0026#34; } } final class LiveActivityManager { @discardableResult static func startActivity(isPlaying: String) throws -\u0026gt; String { var activity: Activity\u0026lt;VideoStreamingWidgetActivityAttributes\u0026gt;? let initialState = VideoStreamingWidgetActivityAttributes.ContentState(isPlaying: isPlaying) do { activity = try Activity.request(attributes: VideoStreamingWidgetActivityAttributes(), contentState: initialState, pushType: nil) guard let id = activity?.id else { throw LiveActivityErrorType.failedToGetID } return id } catch { throw error } } } enum LiveActivityErrorType: Error { case failedToGetID } UI compactTrailing compactTrailing: { Text(\u0026#34;0:33\u0026#34;) .foregroundColor(.red) .padding(.trailing, 8) } compactLeading compactLeading: { Image(systemName: \u0026#34;waveform\u0026#34;) .resizable() .aspectRatio(contentMode: .fit) .foregroundColor(.red) .padding(.leading, 8) } expanded DynamicIsland { DynamicIslandExpandedRegion(.center) { HStack { Text(\u0026#34;0:33\u0026#34;) .foregroundStyle(.gray) .frame(height: 4) ProgressView(value: 33, total: 344) .progressViewStyle(.linear) Text(\u0026#34;-2:33\u0026#34;) .foregroundStyle(.gray) .frame(height: 4) } } DynamicIslandExpandedRegion(.bottom) { HStack(spacing: 24) { ForEach(Command.allCases) { command in Button(intent: ButtonIntent(id: command.id)) { Image(systemName: imageSystemName(isPlaying: true, command: command)) } } } } } Helpers enum Command: String, CaseIterable { case previous case playPause case next } extension Command: Identifiable { var id: String { rawValue } } func imageSystemName(isPlaying: Bool, command: Command) -\u0026gt; String { switch command { case .playPause: if isPlaying { return \u0026#34;pause.fill\u0026#34; } else { return \u0026#34;play.fill\u0026#34; } case .next: return \u0026#34;forward.fill\u0026#34; case .previous: return \u0026#34;backward.fill\u0026#34; } } import AppIntents struct ButtonIntent: AppIntent { static let title: LocalizedStringResource = \u0026#34;ButtonIntent\u0026#34; @Parameter(title: \u0026#34;id\u0026#34;) var id: String init(id: String) { self.id = id } init() {} func perform() async throws -\u0026gt; some IntentResult { if id == Command.playPause.rawValue { } return .result() } } Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/building-dynamic-island-for-video-streaming-app/","summary":"Introduction I was curious about how to add Dynamic Island and implement it into a Video Streaming App. Here are a few steps on how you can achieve this.\nCaveats Debugging Dynamic Island can be a bit tricky; it only works when the main app is running. If you try to run it separately, you will encounter the error SendProcessControlEvent:toPid: encountered an error: Error Domain=com.apple.dt.deviceprocesscontrolservice Code=8 \u0026quot;Failed to show Widget\u0026quot;. The solution is to configure live activities and run them through the main app.","title":"Building Dynamic Island for Video Streaming App"},{"content":"Introduction I was exploring the idea of creating a YouTube-like widget for the lock screen on iOS devices. It wasn\u0026rsquo;t easy because most articles on the Internet discussed general implementations, such as for a coffee shop or a to-do list. Even when I found some similar versions, the project wouldn\u0026rsquo;t compile. I made the decision to approach it my way, so here\u0026rsquo;s what I found out:\nCaveats After being stuck for two or more hours without understanding why, after tapping on a button, I wasn't able to receive a callback from it and the widget always opened the main iOS app, I realized that I forgot to add AppIntent - without it, you can\u0026rsquo;t handle actions for iOS 17. import AppIntents struct ButtonIntent: AppIntent { static let title: LocalizedStringResource = \u0026#34;ButtonIntent\u0026#34; @Parameter(title: \u0026#34;id\u0026#34;) var id: String func perform() async throws -\u0026gt; some IntentResult { if id == Command.playPause.rawValue { DataModel.shared.isPlaying.toggle() } return .result() } } Another crucial point is not to forget to add an explicit init. If you don\u0026rsquo;t implement it explicitly, it will not work. import AppIntents struct ButtonIntent: AppIntent { static let title: LocalizedStringResource = \u0026#34;ButtonIntent\u0026#34; @Parameter(title: \u0026#34;id\u0026#34;) var id: String init(id: String) { self.id = id } init() {} func perform() async throws -\u0026gt; some IntentResult { if id == Command.playPause.rawValue { DataModel.shared.isPlaying.toggle() } return .result() } } Lastly, I attempted to add a Slider, but I found that it\u0026rsquo;s not supported by the widget. My solution was to choose a ProgressView instead. Implementation struct YouTubeLockScreenWidget: View { var body: some View { VStack { Spacer() ProgressView(value: DataModel.shared.currentTime, total: DataModel.shared.totalTime) .progressViewStyle(.linear) Spacer() HStack { ForEach(Command.allCases) { command in Button(intent: ButtonIntent(id: command.id)) { Image(systemName: imageSystemName(isPlaying: DataModel.shared.isPlaying, command: command)) } } } } } } final class DataModel { static let shared = DataModel() var isPlaying: Bool = false var currentTime: TimeInterval = 34 var totalTime: TimeInterval = 304 } enum Command: String, CaseIterable { case previous case playPause case next } extension Command: Identifiable { var id: String { rawValue } } func imageSystemName(isPlaying: Bool, command: Command) -\u0026gt; String { switch command { case .playPause: if isPlaying { return \u0026#34;pause.fill\u0026#34; } else { return \u0026#34;play.fill\u0026#34; } case .next: return \u0026#34;forward.fill\u0026#34; case .previous: return \u0026#34;backward.fill\u0026#34; } } I had not replaced default generated code when I was adding widget to the project. I just added YouTubeLockScreenWidget to generated VideoStreamingWidgetEntryView.\nstruct VideoStreamingWidgetEntryView : View { var entry: Provider.Entry var body: some View { YouTubeLockScreenWidget() } } Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/building-video-streaming-widget-for-ios-app/","summary":"Introduction I was exploring the idea of creating a YouTube-like widget for the lock screen on iOS devices. It wasn\u0026rsquo;t easy because most articles on the Internet discussed general implementations, such as for a coffee shop or a to-do list. Even when I found some similar versions, the project wouldn\u0026rsquo;t compile. I made the decision to approach it my way, so here\u0026rsquo;s what I found out:\nCaveats After being stuck for two or more hours without understanding why, after tapping on a button, I wasn't able to receive a callback from it and the widget always opened the main iOS app, I realized that I forgot to add AppIntent - without it, you can\u0026rsquo;t handle actions for iOS 17.","title":"Building Video Streaming Widget for iOS App"},{"content":"Introduction I was looking for a way to add a video player to my iOS app that could be able to play remote videos.\nCaveats Problem I found that you can\u0026rsquo;t open Vimeo or Youtube videos because of AVFoundationErrorDomain Code=-11850 \u0026quot;Operation Stopped\u0026quot; UserInfo={NSLocalizedFailureReason=The server is not correctly configured Domain=NSOSStatusErrorDomain Code=-12939 error. I donâ€™t know exactly what this means, but I\u0026rsquo;m speculating it\u0026rsquo;s related to some protection.\nSolution My solution was to find another video that is not related to those platforms.\nImplementation AVKit has a built-in video player called VideoPlayer. All you need to play a video is to pass AVPlayer with videoURL.\n@ViewBuilder var fullScreenVideoPlayer: some View { let avPlayer = AVPlayer(url: videoURL) VideoPlayer(player: avPlayer) .edgesIgnoringSafeArea(.all) .onAppear { avPlayer.play() } } I will dive a little deeper with widgets in the next chapters.\nThank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/building-video-streaming-ios-app/","summary":"Introduction I was looking for a way to add a video player to my iOS app that could be able to play remote videos.\nCaveats Problem I found that you can\u0026rsquo;t open Vimeo or Youtube videos because of AVFoundationErrorDomain Code=-11850 \u0026quot;Operation Stopped\u0026quot; UserInfo={NSLocalizedFailureReason=The server is not correctly configured Domain=NSOSStatusErrorDomain Code=-12939 error. I donâ€™t know exactly what this means, but I\u0026rsquo;m speculating it\u0026rsquo;s related to some protection.\nSolution My solution was to find another video that is not related to those platforms.","title":"Building Video Streaming iOS App"},{"content":"Introduction I never had a chance to work with WebSockets, so I decided to take a look and create a group chat. Here\u0026rsquo;s what I discovered:\nTo be able to send and receive messages, you need to create an interface for communication between a server and your application. In my case, I chose sendMessage and receiveMessage methods. For the server-side, I chose Node.js. For the iOS application, I chose the Socket.IO library. Implementation Letâ€™s dive deeper into the implementation.\nFirst step The first step would be to create a server.js file to be able to handle incoming events.\nconst express = require(\u0026#39;express\u0026#39;); const app = express(); const server = require(\u0026#39;http\u0026#39;).Server(app); const io = require(\u0026#39;socket.io\u0026#39;)(server); const { randomUUID } = require(\u0026#39;crypto\u0026#39;); const users = new Map(); io.on(\u0026#39;connection\u0026#39;, (socket) =\u0026gt; { let username = socket.handshake.auth.username; console.log(\u0026#39;a user connected\u0026#39;); users.set(socket.id, username); io.emit(\u0026#39;receiveNewUser\u0026#39;, username, Object.fromEntries(users)); socket.on(\u0026#39;sendMessage\u0026#39;, (message) =\u0026gt; { const username = users.get(socket.id); io.emit(\u0026#39;receiveMessage\u0026#39;, randomUUID(), username, message); }); socket.on(\u0026#39;disconnect\u0026#39;, () =\u0026gt; { console.log(\u0026#39;user disconnected\u0026#39;); users.delete(socket.id); }); }); server.listen(3000, () =\u0026gt; { console.log(\u0026#39;listening on *:3000\u0026#39;); }); Second step The next step would be creating a ChatService that will be responsible for connect, disconnect, send, and receive data.\nimport SocketIO final class ChatService { private var manager: SocketManager! private var socket: SocketIOClient! private var username: String! init() { manager = SocketManager(socketURL: URL(string: \u0026#34;http://localhost:3000\u0026#34;)!) socket = manager.defaultSocket } func connect(username: String) { self.username = username socket.connect(withPayload: [\u0026#34;username\u0026#34;: username]) } func disconnect() { socket.disconnect() } func sendMessage(_ message: String) { socket.emit(\u0026#34;sendMessage\u0026#34;, message) } func sendUsername(_ username: String) { socket.emit(\u0026#34;sendUsername\u0026#34;, username) } func receiveMessage(_ completion: @escaping (String, String, UUID) -\u0026gt; Void) { socket.on(\u0026#34;receiveMessage\u0026#34;) { data, _ in if let text = data[2] as? String, let id = data[0] as? String, let username = data[1] as? String { completion(username, text, UUID.init(uuidString: id) ?? UUID()) } } } func receiveNewUser(_ completion: @escaping (String, [String:String]) -\u0026gt; Void) { socket.on(\u0026#34;receiveNewUser\u0026#34;) { data, _ in if let username = data[0] as? String, let users = data[1] as? [String:String] { completion(username, users) } } } } Third step The next step would be creating a ViewModel communicating with the ChatService.\nimport Foundation final class ViewModel: ObservableObject { private let chatService: ChatService = ChatService() @Published var message: String = \u0026#34;\u0026#34; @Published var messages: [Message] = [] @Published var username: String = \u0026#34;\u0026#34; @Published var users: [String:String] = [:] @Published var newUser: String = \u0026#34;\u0026#34; @Published var showUsernamePrompt: Bool = true @Published var isShowingNewUserAlert = false } extension ViewModel { func connect() { chatService.connect(username: username) chatService.receiveMessage { username, text, id in self.receiveMessage(username: username, text: text, id: id) } chatService.receiveNewUser { username, users in self.receiveNewUser(username: username, users: users) } showUsernamePrompt = false } func sendMessage() { chatService.sendMessage(message) message = \u0026#34;\u0026#34; } func receiveMessage(username: String, text: String, id: UUID) { messages.append(Message(username: username, text: text, id: id)) } func receiveNewUser(username: String, users: [String:String]) { self.users = users self.newUser = username self.isShowingNewUserAlert = self.username != username } func disconnect() { chatService.disconnect() message = \u0026#34;\u0026#34; messages = [] username = \u0026#34;\u0026#34; users = [:] newUser = \u0026#34;\u0026#34; showUsernamePrompt = true isShowingNewUserAlert = false } } Fourth step The last step would be creating UI and connecting it with the ViewModel.\nimport SwiftUI struct ChatView: View { @StateObject private var viewModel = ViewModel() var body: some View { NavigationView { VStack { if viewModel.showUsernamePrompt { HStack { TextField(\u0026#34;Enter your username\u0026#34;, text: $viewModel.username) .textFieldStyle(RoundedBorderTextFieldStyle()) Button(action: viewModel.connect) { Text(\u0026#34;Connect\u0026#34;) } } .padding() } else { List { ForEach(viewModel.messages, id: \\.self) { message in HStack { if message.username == viewModel.username { Text(\u0026#34;Me:\u0026#34;) .font(.subheadline) .foregroundColor(.blue) } else { Text(\u0026#34;\\(message.username):\u0026#34;) .font(.subheadline) .foregroundColor(.green) } Text(message.text) } } } HStack { TextField(\u0026#34;Enter a message\u0026#34;, text: $viewModel.message) .textFieldStyle(RoundedBorderTextFieldStyle()) HStack { Button(action: viewModel.sendMessage) { Text(\u0026#34;Send\u0026#34;) } Button(action: viewModel.disconnect) { Text(\u0026#34;Disconnect\u0026#34;) } } } .padding() } } .navigationBarTitle(\u0026#34;Group Chat \\(viewModel.users.count \u0026gt; 0 ? \u0026#34;(\\(viewModel.users.count) connected)\u0026#34; : \u0026#34;\u0026#34;)\u0026#34;) .navigationBarTitleDisplayMode(.inline) .alert(\u0026#34;\\(viewModel.newUser) just joined the chat!\u0026#34;, isPresented: $viewModel.isShowingNewUserAlert) { Button(\u0026#34;OK\u0026#34;, role: .cancel) { viewModel.isShowingNewUserAlert = false } } } } } #Preview { ChatView() } Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/building-group-chat-using-websockets/","summary":"Introduction I never had a chance to work with WebSockets, so I decided to take a look and create a group chat. Here\u0026rsquo;s what I discovered:\nTo be able to send and receive messages, you need to create an interface for communication between a server and your application. In my case, I chose sendMessage and receiveMessage methods. For the server-side, I chose Node.js. For the iOS application, I chose the Socket.","title":"Building Group Chat using WebSockets"},{"content":"Introduction I find myself fascinated by the idea of creating an app for visionOS where I could possibly display 3D AirPods that I like. Here are a few steps on how you can do the same:\nFirst step The first step that you need to do is to create a visionOS project.\nSecond step The next step would be adding a 3D object to Reality Composer Pro and exporting it as a .usdz file. You can download free 3D objects here. All you need to do to download content is to register on this site.\nThird step The final step would be adding code to display the 3D object. To do that, we need to add Model3D. It helps asynchronously load and display a 3D model.\nimport SwiftUI import RealityKit import RealityKitContent struct AirPodsMaxAnimation: View { var body: some View { NavigationStack { VStack { Model3D(named: \u0026#34;Airpods_Max_Pink\u0026#34;) { model in model .resizable() .aspectRatio(contentMode: .fit) .scaleEffect(0.5) .phaseAnimator([false, true]) { AirPodsMax, threeDYRotate in AirPodsMax .rotation3DEffect(.degrees(threeDYRotate ? 0 : -360 * 5), axis: (x: 0, y: 1, z: 0)) } animation: { threeDYRotate in .linear(duration: 25).repeatForever(autoreverses: false) } } placeholder: { ProgressView() } } .navigationTitle(\u0026#34;Airpods Max Pink\u0026#34;) } } } #Preview(windowStyle: .automatic) { AirPodsMaxAnimation() } Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/exploring-visionos/","summary":"Introduction I find myself fascinated by the idea of creating an app for visionOS where I could possibly display 3D AirPods that I like. Here are a few steps on how you can do the same:\nFirst step The first step that you need to do is to create a visionOS project.\nSecond step The next step would be adding a 3D object to Reality Composer Pro and exporting it as a .","title":"Exploring visionOS"},{"content":"Introduction I was searching for an AR implementation of a 3D guitar inside an iOS app. Here\u0026rsquo;s what I discovered:\nFirst Step The first step is not related to building the app. Before that you need to create a project using the Reality Composer Pro app (you can find it through Spotlight search).\nSecond Step After that, you need to visit https://developer.apple.com/augmented-reality/quick-look/ and download one of the USDZ files. In my case, I chose the 3D guitar.\nThird Step Now, you can start diving into AR implementation inside the iOS project:\nYou need to add the Privacy - Camera Usage Description key to be able to use the camera Put your_file_name.usdz into the iOS project Create an ARViewRepresentable struct ARViewRepresentable: UIViewRepresentable { func makeUIView(context: Context) -\u0026gt; some ARView { let arView = ARView(frame: .zero) return arView } func updateUIView(_ uiView: UIViewType, context: Context) { } } Load, and anchor the 3D model func makeUIView(context: Context) -\u0026gt; some ARView { let arView = ARView(frame: .zero) // Load 3D model guard let guitarModelURL = Bundle.main.url(forResource: \u0026#34;fender_stratocaster\u0026#34;, withExtension: \u0026#34;usdz\u0026#34;) else { fatalError(\u0026#34;Failed to load model file.\u0026#34;) } let guitarModel = try! Entity.load(contentsOf: guitarModelURL) // Anchor 3D model let anchorEntity = AnchorEntity(.plane(.horizontal, classification: .any, minimumBounds: .zero)) anchorEntity.addChild(guitarModel) return arView } and finally add it to arView.scene func makeUIView(context: Context) -\u0026gt; some ARView { let arView = ARView(frame: .zero) // Load 3D model guard let guitarModelURL = Bundle.main.url(forResource: \u0026#34;fender_stratocaster\u0026#34;, withExtension: \u0026#34;usdz\u0026#34;) else { fatalError(\u0026#34;Failed to load model file.\u0026#34;) } let guitarModel = try! Entity.load(contentsOf: guitarModelURL) // Anchor 3D model let anchorEntity = AnchorEntity(.plane(.horizontal, classification: .any, minimumBounds: .zero)) anchorEntity.addChild(guitarModel) // Add anchor to scene arView.scene.addAnchor(anchorEntity) return arView } That\u0026rsquo;s it! Play and enjoy ðŸ˜Š\nThank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/ios-ar-app-experience-3d-guitar/","summary":"Introduction I was searching for an AR implementation of a 3D guitar inside an iOS app. Here\u0026rsquo;s what I discovered:\nFirst Step The first step is not related to building the app. Before that you need to create a project using the Reality Composer Pro app (you can find it through Spotlight search).\nSecond Step After that, you need to visit https://developer.apple.com/augmented-reality/quick-look/ and download one of the USDZ files. In my case, I chose the 3D guitar.","title":"iOS AR App: Experience 3D Guitar"},{"content":"Introduction I was wondering about how to create movie recommendations, so I decided to take a closer look and find out more about this topic. This is what I found:\nFirst step: You need to create a JSON file with the data that you will use to train the model and define the parameters for training the model.\n[ { \u0026#34;title\u0026#34;: \u0026#34;Avatar\u0026#34;, \u0026#34;year\u0026#34;: \u0026#34;2009\u0026#34;, \u0026#34;rated\u0026#34;: \u0026#34;PG-13\u0026#34;, \u0026#34;released\u0026#34;: \u0026#34;18 Dec 2009\u0026#34;, \u0026#34;runtime\u0026#34;: \u0026#34;162 min\u0026#34;, \u0026#34;genre\u0026#34;: \u0026#34;Action, Adventure, Fantasy\u0026#34;, \u0026#34;director\u0026#34;: \u0026#34;James Cameron\u0026#34;, \u0026#34;writer\u0026#34;: \u0026#34;James Cameron\u0026#34;, \u0026#34;actors\u0026#34;: \u0026#34;Sam Worthington, Zoe Saldana, Sigourney Weaver, Stephen Lang\u0026#34;, \u0026#34;plot\u0026#34;: \u0026#34;A paraplegic marine dispatched to the moon Pandora on a unique mission becomes torn between following his orders and protecting the world he feels is his home.\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;English, Spanish\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;USA, UK\u0026#34;, \u0026#34;awards\u0026#34;: \u0026#34;Won 3 Oscars. Another 80 wins \u0026amp; 121 nominations.\u0026#34;, \u0026#34;poster\u0026#34;: \u0026#34;https://ia.media-imdb.com/images/M/MV5BMTYwOTEwNjAzMl5BMl5BanBnXkFtZTcwODc5MTUwMw@@._V1_SX300.jpg\u0026#34;, \u0026#34;metascore\u0026#34;: \u0026#34;83\u0026#34;, \u0026#34;imdbrating\u0026#34;: \u0026#34;7.9\u0026#34;, \u0026#34;imdbvotes\u0026#34;: \u0026#34;890,617\u0026#34;, \u0026#34;imdbid\u0026#34;: \u0026#34;tt0499549\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;movie\u0026#34;, \u0026#34;response\u0026#34;: \u0026#34;True\u0026#34;, \u0026#34;keywords\u0026#34;: [\u0026#34;alien\u0026#34;, \u0026#34;avatar\u0026#34;, \u0026#34;fantasy world\u0026#34;, \u0026#34;soldier\u0026#34;, \u0026#34;battle\u0026#34;] }, ] When you have created the data, you can proceed to the next step.\nCreating a model with parameters Creating a model with parameters is essential for training. As an example, I chose the following parameters to create more realistic recommendations: director, actors, language, country, metascore, IMDb rating, and IMDb votes.\nstruct Movie: Decodable { var id: String { return imdbid } let title: String let keywords: [String] let director: String let actors: String let language: String let country: String let poster: String let metascore: String let imdbrating: String let imdbvotes: String let imdbid: String } extension Movie: Identifiable, TextImageProviding { var url: URL { return URL(string: poster)! } } When you have created the model, you can proceed to the next step:\nCreating a Recommendations service In this step, it\u0026rsquo;s important to specify the ML model you\u0026rsquo;ll utilize. I chose the MLLinearRegressor model because linear regression computes an output value for a given input value. I selected \u0026lsquo;favorite\u0026rsquo; as the target column for this model to create predictions based on the films I like.\nimport Foundation import TabularData #if canImport(CreateML) import CreateML #endif final class RecommendationService { private let queue = DispatchQueue(label: \u0026#34;com.recommendation-service.queue\u0026#34;, qos: .userInitiated) func computeRecommendations(basedOn items: [FavoriteWrapper\u0026lt;Movie\u0026gt;]) async throws -\u0026gt; [Movie] { return try await withCheckedThrowingContinuation { continuation in queue.async { #if targetEnvironment(simulator) continuation.resume(throwing: NSError(domain: \u0026#34;Simulator Not Supported\u0026#34;, code: -1)) #else let trainingData = items.filter { $0.isFavorite != nil } let trainingDataFrame = self.dataFrame(for: trainingData) let testData = items let testDataFrame = self.dataFrame(for: testData) do { let regressor = try MLLinearRegressor(trainingData: trainingDataFrame, targetColumn: \u0026#34;favorite\u0026#34;) let predictionsColumn = (try regressor.predictions(from: testDataFrame)).compactMap { value in value as? Double } let sorted = zip(testData, predictionsColumn) .sorted { lhs, rhs -\u0026gt; Bool in lhs.1 \u0026gt; rhs.1 } .filter { $0.1 \u0026gt; 0 } .prefix(10) print(sorted.map(\\.1)) let result = sorted.map(\\.0.model) continuation.resume(returning: result) } catch { continuation.resume(throwing: error) } #endif } } } private func dataFrame(for data: [FavoriteWrapper\u0026lt;Movie\u0026gt;]) -\u0026gt; DataFrame { var dataFrame = DataFrame() dataFrame.append( column: Column(name: \u0026#34;keywords\u0026#34;, contents: data.flatMap(\\.model.keywords).joined(separator: \u0026#34;, \u0026#34;)) ) dataFrame.append( column: Column(name: \u0026#34;director\u0026#34;, contents: data.map(\\.model.director)) ) dataFrame.append( column: Column(name: \u0026#34;actors\u0026#34;, contents: data.map(\\.model.actors)) ) dataFrame.append( column: Column(name: \u0026#34;language\u0026#34;, contents: data.map(\\.model.language)) ) dataFrame.append( column: Column(name: \u0026#34;country\u0026#34;, contents: data.map(\\.model.country)) ) dataFrame.append( column: Column\u0026lt;Int\u0026gt;( name: \u0026#34;metascore\u0026#34;, contents: data.map { return Int($0.model.metascore) } ) ) dataFrame.append( column: Column\u0026lt;Double\u0026gt;( name: \u0026#34;imdbrating\u0026#34;, contents: data.map { return Double($0.model.imdbrating) } ) ) dataFrame.append( column: Column(name: \u0026#34;imdbvotes\u0026#34;, contents: data.map(\\.model.imdbvotes)) ) dataFrame.append( column: Column\u0026lt;Int\u0026gt;( name: \u0026#34;favorite\u0026#34;, contents: data.map { if let isFavorite = $0.isFavorite { return isFavorite ? 1 : -1 } else { return 0 } } ) ) return dataFrame } } Once you\u0026rsquo;ve finished with the ML part, proceed to the next step:\nCreating a ViewModel to assemble all components At this stage, you handle user input and recompute recommendations based on user input.\n@MainActor final class MainViewModel: ObservableObject { private var allMovies: [FavoriteWrapper\u0026lt;Movie\u0026gt;] = [] @Published private(set) var movies: [Movie] = [] @Published private(set) var recommendations: [Movie] = [] private let recommendationService: RecommendationService private var recommendationsTask: Task\u0026lt;Void, Never\u0026gt;? init(recommendationService: RecommendationService = RecommendationService()) { self.recommendationService = recommendationService } func loadAllMovies() async { guard let url = Bundle.main.url(forResource: \u0026#34;movies\u0026#34;, withExtension: \u0026#34;json\u0026#34;) else { return } do { let data = try Data(contentsOf: url) allMovies = (try JSONDecoder().decode([Movie].self, from: data)).shuffled().map { FavoriteWrapper(model: $0) } movies = allMovies.map(\\.model) } catch { print(error.localizedDescription) } } func didRemove(_ item: Movie, isLiked: Bool) { movies.removeAll { $0.id == item.id } if let index = allMovies.firstIndex(where: { $0.model.id == item.id }) { allMovies[index] = FavoriteWrapper(model: item, isFavorite: isLiked) } recommendationsTask?.cancel() recommendationsTask = Task { do { let result = try await recommendationService.computeRecommendations(basedOn: allMovies) if !Task.isCancelled { recommendations = result } } catch { print(error.localizedDescription) } } } func resetUserChoices() { movies = allMovies.map(\\.model) recommendations = [] } } The final step The final step is to create the UI and connect it with the ViewModel.\nimport SwiftUI struct ContentView: View { @StateObject private var viewModel: MainViewModel init() { _viewModel = StateObject(wrappedValue: MainViewModel()) } var body: some View { NavigationView { ScrollView { VStack(alignment: .leading) { SectionTitleView(text: \u0026#34;Swipe to Like or Dislike\u0026#34;) if viewModel.movies.isEmpty { HStack { Spacer() VStack { Text(\u0026#34;All Done!\u0026#34;) .multilineTextAlignment(.center) .font(.callout) .foregroundColor(.secondary) Button(\u0026#34;Try Again\u0026#34;) { withAnimation { viewModel.resetUserChoices() } } .font(.headline) .buttonStyle(.borderedProminent) } Spacer() } .padding(.horizontal) .padding(.vertical, 32) } else { CardsStackView(models: viewModel.movies) { item, isLiked in withAnimation(.spring()) { viewModel.didRemove(item, isLiked: isLiked) } } .zIndex(1) } RecommendationsView(recommendations: viewModel.recommendations) } } .navigationTitle(\u0026#34;TmovieÂ´inder!\u0026#34;) .task { await viewModel.loadAllMovies() } } .navigationViewStyle(.stack) } } Resources ðŸ”— GitHub project ðŸ“¥ Download materials Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/building-movie-recommendations-using-ml/","summary":"Introduction I was wondering about how to create movie recommendations, so I decided to take a closer look and find out more about this topic. This is what I found:\nFirst step: You need to create a JSON file with the data that you will use to train the model and define the parameters for training the model.\n[ { \u0026#34;title\u0026#34;: \u0026#34;Avatar\u0026#34;, \u0026#34;year\u0026#34;: \u0026#34;2009\u0026#34;, \u0026#34;rated\u0026#34;: \u0026#34;PG-13\u0026#34;, \u0026#34;released\u0026#34;: \u0026#34;18 Dec 2009\u0026#34;, \u0026#34;runtime\u0026#34;: \u0026#34;162 min\u0026#34;, \u0026#34;genre\u0026#34;: \u0026#34;Action, Adventure, Fantasy\u0026#34;, \u0026#34;director\u0026#34;: \u0026#34;James Cameron\u0026#34;, \u0026#34;writer\u0026#34;: \u0026#34;James Cameron\u0026#34;, \u0026#34;actors\u0026#34;: \u0026#34;Sam Worthington, Zoe Saldana, Sigourney Weaver, Stephen Lang\u0026#34;, \u0026#34;plot\u0026#34;: \u0026#34;A paraplegic marine dispatched to the moon Pandora on a unique mission becomes torn between following his orders and protecting the world he feels is his home.","title":"Building movie recommendations using ML"},{"content":"Introduction If you\u0026rsquo;re wondering how to test an Xcode project using GitHub Actions, here are a few steps:\nFirst, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.3.app/Contents/Developer - name: Install xcpretty run: gem install xcpretty - name: Test project run: xcodebuild -project /Users/runner/work/YourProjectName/YourProjectName/YourProjectName/YourProjectName.xcodeproj -scheme YourSchemeName -destination \u0026#39;platform=iOS Simulator,OS=17.4,name=iPhone 15 Pro\u0026#39; clean build test | xcpretty Caveats If you don\u0026rsquo;t specify the path to the Xcode project, you will receive an error like this: xcodebuild: error: â€˜YourProjectName.xcodeproj' does not exist.\nYou can debug project directory by adding this line to your config:\n- name: Debug Directory Contents run: ls -la /Users/runner/work/YourProjectName/YourProjectName Thank you for reading!\n","permalink":"http://localhost:1313/posts/testing-xcode-project-using-github-actions/","summary":"Introduction If you\u0026rsquo;re wondering how to test an Xcode project using GitHub Actions, here are a few steps:\nFirst, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.","title":"Testing Xcode project using Github Actions"},{"content":"Introduction If you\u0026rsquo;re wondering how to build an Xcode project using GitHub Actions, here are a few steps:\nFirst, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.3.app/Contents/Developer - name: Install xcpretty run: gem install xcpretty - name: Build project run: xcodebuild -project /Users/runner/work/YourProjectName/YourProjectName/YourProjectName/YourProjectName.xcodeproj -scheme YourSchemeName -sdk iphonesimulator -destination \u0026#39;platform=iOS Simulator,name=iPhone 15 Pro\u0026#39; clean build | xcpretty Caveats If you don\u0026rsquo;t specify the path to the Xcode project, you will receive an error like this: xcodebuild: error: â€˜YourProjectName.xcodeproj' does not exist.\nYou can debug project directory by adding this line to your config:\n- name: Debug Directory Contents run: ls -la /Users/runner/work/YourProjectName/YourProjectName Thank you for reading!\n","permalink":"http://localhost:1313/posts/building-xcode-project-using-github-actions/","summary":"Introduction If you\u0026rsquo;re wondering how to build an Xcode project using GitHub Actions, here are a few steps:\nFirst, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.","title":"Building Xcode project using Github Actions"},{"content":"Introduction You can easily deliver an iOS app in two ways: through beta and release lanes.\nThe First Way - TestFlight By creating a beta lane inside the Fastfile. It utilizes:\nbuild_app: To easily build and sign your app (via gym). pilot: Makes it easier to manage your app on Appleâ€™s TestFlight. lane :beta do build_app(scheme: \u0026#34;YourScheme\u0026#34;) pilot end To run Fastlane:\nfastlane beta Attention Before proceeding, you need to have the ipa or pkg file generated.\nThe Second Way - App Store Connect By creating a release lane inside the Fastfile. It utilizes:\ngym: To build and package iOS apps for you. deliver: To upload screenshots, metadata, and binaries to App Store Connect. lane :release do gym # Builds the app deliver # Uploads the app to App Store Connect end To run Fastlane:\nfastlane release If you haven\u0026rsquo;t installed Fastlane yet, here are the steps: Outline of the Process\nInstall Fastlane: You can do so using RubyGems, which is the Ruby package manager: brew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running: fastlane init ","permalink":"http://localhost:1313/posts/delivering-ios-app-using-fastlane/","summary":"Introduction You can easily deliver an iOS app in two ways: through beta and release lanes.\nThe First Way - TestFlight By creating a beta lane inside the Fastfile. It utilizes:\nbuild_app: To easily build and sign your app (via gym). pilot: Makes it easier to manage your app on Appleâ€™s TestFlight. lane :beta do build_app(scheme: \u0026#34;YourScheme\u0026#34;) pilot end To run Fastlane:\nfastlane beta Attention Before proceeding, you need to have the ipa or pkg file generated.","title":"Delivering iOS app using Fastlane"},{"content":"Introduction When you are working on different projects sometimes you need to use different IDEâ€™s. You need to find a way to archive a project in the fastest way.\nOne of such ways is by using the xcodebuild archive command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild archive: Once you\u0026rsquo;re in the project directory, you can run xcodebuild archive with the appropriate parameters to build your project. Example: xcodebuild archive -scheme YourSchemeName -archivePath ~/Desktop/YourAppName.xcarchive Another way is by integrating fastlane into your workflow: Outline of the process Install Fastlane: If you haven\u0026rsquo;t already installed Fastlane, you can do so using RubyGems, which is the Ruby package manager:\nbrew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running:\nfastlane init Create a lane for archiving: Open your Fastfile located in the fastlane directory of your project, and add a new lane for archiving:\nlane :archive do gym( scheme: \u0026#34;YourSchemeName\u0026#34;, output_directory: \u0026#34;/path/to/your/archive/directory\u0026#34;, output_name: \u0026#34;YourAppName\u0026#34; ) end Run the archive lane: Once you\u0026rsquo;ve defined the archive lane, you can run it using the following command:\nfastlane archive ","permalink":"http://localhost:1313/posts/archiving-xcode-project-using-the-cli/","summary":"Introduction When you are working on different projects sometimes you need to use different IDEâ€™s. You need to find a way to archive a project in the fastest way.\nOne of such ways is by using the xcodebuild archive command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project.","title":"Archiving Xcode project using the CLI"},{"content":"Introduction When you are working on different projects sometimes you need to use different IDEâ€™s. You need to find a way to test a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project. Example: xcodebuild -project YourProject.xcodeproj -scheme YourSchemeName test Another way is by integrating fastlane into your workflow: Outline of the process Install Fastlane: If you haven\u0026rsquo;t already installed Fastlane, you can do so using RubyGems, which is the Ruby package manager:\nbrew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running:\nfastlane init Define a Lane for Testing: Open your Fastfile and define a lane for running tests. Here\u0026rsquo;s a basic example:\nlane :run_tests do scan(scheme: \u0026#34;YourSchemeName\u0026#34;) end Run Tests Using Fastlane: You can now run your tests using the lane you defined. In the terminal, navigate to your project directory and run:\nfastlane run_tests Testing a project through a project generation tools If you are testing a project through a project generation tool like tuist you do not need anything that was mentioned above because it already has build-in commands:\ntuist test YourSchemeName ","permalink":"http://localhost:1313/posts/testing-xcode-project-using-the-cli/","summary":"Introduction When you are working on different projects sometimes you need to use different IDEâ€™s. You need to find a way to test a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project.","title":"Testing Xcode project using the CLI"},{"content":"Introduction When you are working on different projects sometimes you need to use different IDEâ€™s. You need to find a way to build a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project. Example: xcodebuild -project YourProjectName.xcodeproj -scheme YourSchemeName Another way is by integrating fastlane into your workflow: Outline of the process Install Fastlane: If you haven\u0026rsquo;t already installed Fastlane, you can do so using RubyGems, which is the Ruby package manager:\nbrew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running:\nfastlane init Build with Fastlane: Once Fastlane is set up, you can use it to build your Xcode project. Fastlane provides a lane named build_app for building your app. You can run this lane with the following command:\nfastlane build_app Building a project through a project generation tools If you are building a project through a project generation tool like tuist you do not need anything that was mentioned above because it already has build-in commands tuist build.\n","permalink":"http://localhost:1313/posts/building-xcode-project-using-the-cli/","summary":"Introduction When you are working on different projects sometimes you need to use different IDEâ€™s. You need to find a way to build a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project.","title":"Building Xcode project using the CLI"},{"content":"What is a Visitor Pattern? The Visitor Pattern helps add new capabilities to a composite of objects.\nSource\nWhat problems does it solve? The Visitor Pattern helps solve following problems:\nSeparation of Concerns: The Visitor Pattern separates algorithms from the objects on which they operate. This allows for clean code organization by keeping algorithms and operations separate from the data structures they operate on. Extensibility: It allows you to add new operations to existing object structures without modifying those structures. This is especially useful when dealing with complex object hierarchies where adding new functionality directly to the classes would lead to code bloat and tight coupling. Traversal of Object Structures: It provides a way to traverse complex object structures while performing some action on each element of the structure. This is particularly useful in scenarios where you need to process every element of a data structure in a specific order or with a specific algorithm. Real-world code example // Element protocol representing the items on the menu protocol MenuItem { func accept(visitor: OrderVisitor) } // Concrete item types class Coffee: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } class Tea: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } class Pastry: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } // Visitor protocol defining the operations to be performed on menu items protocol OrderVisitor { func visit(_ item: Coffee) func visit(_ item: Tea) func visit(_ item: Pastry) } // Concrete visitor implementing operations on menu items class TotalCostVisitor: OrderVisitor { var totalCost = 0.0 func visit(_ item: Coffee) { totalCost += item.price } func visit(_ item: Tea) { totalCost += item.price } func visit(_ item: Pastry) { totalCost += item.price } } class ItemDetailsVisitor: OrderVisitor { var details = \u0026#34;\u0026#34; func visit(_ item: Coffee) { details += \u0026#34;Coffee: \\(item.name), Price: $\\(item.price)\\n\u0026#34; } func visit(_ item: Tea) { details += \u0026#34;Tea: \\(item.name), Price: $\\(item.price)\\n\u0026#34; } func visit(_ item: Pastry) { details += \u0026#34;Pastry: \\(item.name), Price: $\\(item.price)\\n\u0026#34; } } // Example usage let items: [MenuItem] = [Coffee(name: \u0026#34;Espresso\u0026#34;, price: 2.5), Tea(name: \u0026#34;Green Tea\u0026#34;, price: 2.0), Pastry(name: \u0026#34;Croissant\u0026#34;, price: 3.0)] let totalCostVisitor = TotalCostVisitor() for item in items { item.accept(visitor: totalCostVisitor) } print(\u0026#34;Total cost of the order: $\\(totalCostVisitor.totalCost)\u0026#34;) let itemDetailsVisitor = ItemDetailsVisitor() for item in items { item.accept(visitor: itemDetailsVisitor) } print(\u0026#34;Order details:\u0026#34;) print(itemDetailsVisitor.details) ","permalink":"http://localhost:1313/posts/the-visitor-pattern/","summary":"What is a Visitor Pattern? The Visitor Pattern helps add new capabilities to a composite of objects.\nSource\nWhat problems does it solve? The Visitor Pattern helps solve following problems:\nSeparation of Concerns: The Visitor Pattern separates algorithms from the objects on which they operate. This allows for clean code organization by keeping algorithms and operations separate from the data structures they operate on. Extensibility: It allows you to add new operations to existing object structures without modifying those structures.","title":"The Visitor Pattern"},{"content":"What is a Memento Pattern? The Memento Pattern helps return an object to one of its previous states; for instance, if the user requests an â€œundoâ€ operation.\nSource\nWhat problems does it solve? The Memento Pattern helps solve following problems:\nUndo/Redo Functionality: Memento allows you to capture an objectâ€™s state at a specific point in time and store it externally. This enables you to implement undo/redo functionality by restoring the object to its previous state. Checkpointing: In applications where users need to save progress or create checkpoints (such as in games or long processes), the Memento Pattern allows you to save the state of an object at various intervals so that users can return to those points later. Real-world code example // Memento: Represents the state of the TextEditor struct TextEditorMemento { let text: String } // Originator: Creates and stores states in Memento objects class TextEditor { private var text: String = \u0026#34;\u0026#34; func setText(_ text: String) { self.text = text } func getText() -\u0026gt; String { return text } func save() -\u0026gt; TextEditorMemento { return TextEditorMemento(text: text) } func restore(fromMemento memento: TextEditorMemento) { self.text = memento.text } } // Caretaker: Manages the mementos class TextEditorHistory { private var history: [TextEditorMemento] = [] private let editor: TextEditor init(editor: TextEditor) { self.editor = editor } func save() { let snapshot = editor.save() history.append(snapshot) } func undo() { guard let lastSnapshot = history.popLast() else { print(\u0026#34;Nothing to undo.\u0026#34;) return } editor.restore(fromMemento: lastSnapshot) } func printHistory() { print(\u0026#34;Text Editor History:\u0026#34;) for (index, snapshot) in history.enumerated() { print(\u0026#34;Step \\(index + 1): \\(snapshot.text)\u0026#34;) } print(\u0026#34;Current text: \\(editor.getText())\u0026#34;) } } // Example usage let textEditor = TextEditor() let history = TextEditorHistory(editor: textEditor) textEditor.setText(\u0026#34;Hello, World!\u0026#34;) history.save() textEditor.setText(\u0026#34;This is a Swift example.\u0026#34;) history.save() textEditor.setText(\u0026#34;Using Memento Pattern.\u0026#34;) history.save() history.printHistory() history.undo() print(\u0026#34;After Undo:\u0026#34;) history.printHistory() Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/the-memento-pattern/","summary":"What is a Memento Pattern? The Memento Pattern helps return an object to one of its previous states; for instance, if the user requests an â€œundoâ€ operation.\nSource\nWhat problems does it solve? The Memento Pattern helps solve following problems:\nUndo/Redo Functionality: Memento allows you to capture an objectâ€™s state at a specific point in time and store it externally. This enables you to implement undo/redo functionality by restoring the object to its previous state.","title":"The Memento Pattern"},{"content":"What is an Interpreter Pattern? The Interpreter Pattern helps implement a simple language and defines a class based representation for its grammar along with an interpreter to interpret its sentences.\nSource\nWhat problems does it solve? The Interpreter Pattern helps solve following problems:\nLanguage Interpretation: When you have a language or syntax that needs to be interpreted, such as mathematical expressions, regular expressions, or domain-specific languages (DSLs), the Interpreter Pattern helps in implementing the logic to interpret and execute these expressions. Extensibility: The Interpreter Pattern allows for easy addition of new grammar rules or language constructs without modifying the core interpreter logic. This promotes extensibility, enabling the interpreter to support new features or languages with minimal changes. Separation of Concerns: It separates the grammar definition from the interpretation logic. This separation of concerns makes the codebase modular and easier to maintain. Changes to the grammar or language rules do not affect the interpretation logic, and vice versa. Real-world code example // Define the protocol for the expression protocol Expression { func interpret() -\u0026gt; Int } // Concrete expression for a number class NumberExpression: Expression { private var value: Int init(_ value: Int) { self.value = value } func interpret() -\u0026gt; Int { return value } } // Concrete expression for addition class AdditionExpression: Expression { private var left: Expression private var right: Expression init(_ left: Expression, _ right: Expression) { self.left = left self.right = right } func interpret() -\u0026gt; Int { return left.interpret() + right.interpret() } } // Concrete expression for subtraction class SubtractionExpression: Expression { private var left: Expression private var right: Expression init(_ left: Expression, _ right: Expression) { self.left = left self.right = right } func interpret() -\u0026gt; Int { return left.interpret() - right.interpret() } } // Concrete expression for multiplication class MultiplicationExpression: Expression { private var left: Expression private var right: Expression init(_ left: Expression, _ right: Expression) { self.left = left self.right = right } func interpret() -\u0026gt; Int { return left.interpret() * right.interpret() } } // Concrete expression for division class DivisionExpression: Expression { private var left: Expression private var right: Expression init(_ left: Expression, _ right: Expression) { self.left = left self.right = right } func interpret() -\u0026gt; Int { let divisor = right.interpret() if divisor != 0 { return left.interpret() / divisor } else { // Handle division by zero error fatalError(\u0026#34;Division by zero\u0026#34;) } } } // Usage let expression = AdditionExpression( MultiplicationExpression(NumberExpression(2), NumberExpression(3)), DivisionExpression(NumberExpression(10), NumberExpression(5)) ) // Interpret the expression let result = expression.interpret() print(\u0026#34;Result: \\(result)\u0026#34;) Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/the-interpreter-pattern/","summary":"What is an Interpreter Pattern? The Interpreter Pattern helps implement a simple language and defines a class based representation for its grammar along with an interpreter to interpret its sentences.\nSource\nWhat problems does it solve? The Interpreter Pattern helps solve following problems:\nLanguage Interpretation: When you have a language or syntax that needs to be interpreted, such as mathematical expressions, regular expressions, or domain-specific languages (DSLs), the Interpreter Pattern helps in implementing the logic to interpret and execute these expressions.","title":"The Interpreter Pattern"},{"content":"What is a Flyweight Pattern? The Flyweight Pattern refers to an object that minimizes memory usage by sharing some of its data with other similar objects.\nSource\nWhat problems does it solve? The Flyweight Pattern helps solve following problems:\nLarge Memory Footprint: When dealing with a large number of objects, especially if these objects share a significant amount of common state, traditional object creation can lead to excessive memory consumption. The Flyweight Pattern reduces memory usage by sharing this common state among multiple objects. Performance Overhead: Creating and managing a large number of objects can also introduce performance overhead due to memory allocation, deallocation, and initialization. By reusing shared objects and minimizing the creation of new objects, the Flyweight Pattern can improve performance. Object Creation Cost: Creating new objects can be costly in terms of time and resources, especially if the objects require complex initialization. By reusing existing objects, the Flyweight Pattern reduces the need for creating new objects, thereby reducing object creation costs. Real-world code example // Flyweight protocol defining the interface for shapes protocol Shape { func draw(at point: CGPoint) } // Concrete flyweight class representing a circle class Circle: Shape { private let radius: CGFloat private let fillColor: UIColor init(radius: CGFloat, fillColor: UIColor) { self.radius = radius self.fillColor = fillColor } func draw(at point: CGPoint) { print(\u0026#34;Drawing Circle at (\\(point.x), \\(point.y)) with radius \\(radius) and fill color \\(fillColor)\u0026#34;) // Actual drawing logic would go here } } // Flyweight factory class responsible for creating and managing flyweight objects class ShapeFactory { private var flyweights = [String: Shape]() func getCircle(radius: CGFloat, fillColor: UIColor) -\u0026gt; Shape { let key = \u0026#34;Circle-\\(radius)-\\(fillColor)\u0026#34; if let existingShape = flyweights[key] { return existingShape } else { let newShape = Circle(radius: radius, fillColor: fillColor) flyweights[key] = newShape return newShape } } } // Client code let shapeFactory = ShapeFactory() // Request for circles with different properties let circle1 = shapeFactory.getCircle(radius: 10, fillColor: .red) let circle2 = shapeFactory.getCircle(radius: 10, fillColor: .red) // Reusing the same circle object let circle3 = shapeFactory.getCircle(radius: 20, fillColor: .blue) // Drawing circles circle1.draw(at: CGPoint(x: 100, y: 100)) circle2.draw(at: CGPoint(x: 200, y: 200)) circle3.draw(at: CGPoint(x: 300, y: 300)) Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/the-flyweight-pattern/","summary":"What is a Flyweight Pattern? The Flyweight Pattern refers to an object that minimizes memory usage by sharing some of its data with other similar objects.\nSource\nWhat problems does it solve? The Flyweight Pattern helps solve following problems:\nLarge Memory Footprint: When dealing with a large number of objects, especially if these objects share a significant amount of common state, traditional object creation can lead to excessive memory consumption. The Flyweight Pattern reduces memory usage by sharing this common state among multiple objects.","title":"The Flyweight Pattern"},{"content":"What is a Chain Of Responsibility Pattern? The Chain Of Responsibility Pattern helps create a chain of objects to examine requests. Each object in turn examines a request and either handles it or passes onto the next object in the chain.\nSource\nWhat problems does it solve? The Chain Of Responsibility Pattern (CoR) helps solve following problems:\nDynamic Request Handling: It enables dynamic assignment of responsibilities at runtime. Handlers can be added, removed, or reordered without affecting the clientâ€™s code. This flexibility allows for easier maintenance and extension of the system. Decoupling Sender and Receiver: In traditional systems, a sender often needs to know the exact receiver of a request, leading to tight coupling between them. The CoR pattern decouples senders from receivers by allowing multiple objects to handle a request without the sender knowing the specific handler. Real-world code example // Protocol defining the handler interface protocol PurchaseHandler { var next: PurchaseHandler? { get set } func handleRequest(amount: Double) } // Concrete handlers class SmallPurchaseHandler: PurchaseHandler { var next: PurchaseHandler? let maxAmount: Double = 100.0 func handleRequest(amount: Double) { if amount \u0026lt;= maxAmount { print(\u0026#34;SmallPurchaseHandler: Purchase approved for $\\(amount)\u0026#34;) } else if let nextHandler = next { print(\u0026#34;SmallPurchaseHandler: Passing request to next handler\u0026#34;) nextHandler.handleRequest(amount: amount) } else { print(\u0026#34;SmallPurchaseHandler: No handler available, purchase rejected\u0026#34;) } } } class MediumPurchaseHandler: PurchaseHandler { var next: PurchaseHandler? let maxAmount: Double = 500.0 func handleRequest(amount: Double) { if amount \u0026lt;= maxAmount { print(\u0026#34;MediumPurchaseHandler: Purchase approved for $\\(amount)\u0026#34;) } else if let nextHandler = next { print(\u0026#34;MediumPurchaseHandler: Passing request to next handler\u0026#34;) nextHandler.handleRequest(amount: amount) } else { print(\u0026#34;MediumPurchaseHandler: No handler available, purchase rejected\u0026#34;) } } } class LargePurchaseHandler: PurchaseHandler { var next: PurchaseHandler? func handleRequest(amount: Double) { print(\u0026#34;LargePurchaseHandler: Purchase approved for $\\(amount)\u0026#34;) } } // Usage func main() { let smallHandler = SmallPurchaseHandler() let mediumHandler = MediumPurchaseHandler() let largeHandler = LargePurchaseHandler() // Connecting handlers into a chain smallHandler.next = mediumHandler mediumHandler.next = largeHandler smallHandler.handleRequest(amount: 50.0) smallHandler.handleRequest(amount: 200.0) smallHandler.handleRequest(amount: 1000.0) } Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/the-chain-of-responsibility-pattern/","summary":"What is a Chain Of Responsibility Pattern? The Chain Of Responsibility Pattern helps create a chain of objects to examine requests. Each object in turn examines a request and either handles it or passes onto the next object in the chain.\nSource\nWhat problems does it solve? The Chain Of Responsibility Pattern (CoR) helps solve following problems:\nDynamic Request Handling: It enables dynamic assignment of responsibilities at runtime. Handlers can be added, removed, or reordered without affecting the clientâ€™s code.","title":"The Chain Of Responsibility Pattern"},{"content":"What is a State Pattern? The State Pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.\nSource\nWhat problems does it solve? Complex conditional logic: When an objectâ€™s behavior depends on its internal state, it often leads to complex conditional statements. The State pattern simplifies this by encapsulating each state and its behavior in separate classes, making the code more readable and maintainable. State-specific behavior: Objects often need to change their behavior based on their state. The State pattern allows objects to delegate behavior to state objects, which can vary independently. This promotes better encapsulation and separation of concerns. Adding new states: When new states need to be added, the State pattern makes it easier to extend the functionality without modifying existing code. New states can be added by creating new state classes and integrating them into the existing context, without changing the context class itself. Real-world code example // Define the VendingMachine protocol protocol VendingMachineState { func insertCoin() func dispenseItem() } // Define concrete states class NoCoinState: VendingMachineState { private let vendingMachine: VendingMachine init(vendingMachine: VendingMachine) { self.vendingMachine = vendingMachine } func insertCoin() { print(\u0026#34;Coin inserted\u0026#34;) // Transition to the HasCoinState vendingMachine.changeState(newState: vendingMachine.hasCoinState) } func dispenseItem() { print(\u0026#34;Please insert a coin first\u0026#34;) } } class HasCoinState: VendingMachineState { private let vendingMachine: VendingMachine init(vendingMachine: VendingMachine) { self.vendingMachine = vendingMachine } func insertCoin() { print(\u0026#34;Coin already inserted\u0026#34;) } func dispenseItem() { if vendingMachine.inventoryCount \u0026gt; 0 { print(\u0026#34;Item dispensed\u0026#34;) vendingMachine.decreaseInventory() // Transition to the NoCoinState vendingMachine.changeState(newState: vendingMachine.noCoinState) } else { print(\u0026#34;Out of stock\u0026#34;) } } } // Define the VendingMachine class class VendingMachine { var inventoryCount: Int = 5 var currentState: VendingMachineState! var noCoinState: VendingMachineState! var hasCoinState: VendingMachineState! init() { noCoinState = NoCoinState(vendingMachine: self) hasCoinState = HasCoinState(vendingMachine: self) currentState = noCoinState } func changeState(newState: VendingMachineState) { currentState = newState } func insertCoin() { currentState.insertCoin() } func dispenseItem() { currentState.dispenseItem() } func decreaseInventory() { inventoryCount -= 1 } } // Usage let vendingMachine = VendingMachine() vendingMachine.dispenseItem() vendingMachine.insertCoin() vendingMachine.insertCoin() vendingMachine.dispenseItem() vendingMachine.dispenseItem() Thank you for reading!\n","permalink":"http://localhost:1313/posts/the-state-pattern/","summary":"What is a State Pattern? The State Pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.\nSource\nWhat problems does it solve? Complex conditional logic: When an objectâ€™s behavior depends on its internal state, it often leads to complex conditional statements. The State pattern simplifies this by encapsulating each state and its behavior in separate classes, making the code more readable and maintainable.","title":"The State Pattern"},{"content":"What is a Dependency Inversion Principle? The Dependency Inversion Principle means that high-level modules should not depend on low-level modules.\nSource\nSource\nWhat problems does it solve? The Dependency Inversion Principle (DIP) helps solve:\nRigidity Fragility Immobility problems Real-world code example Violation of DIP // High-level module directly depending on low-level modules class MessageService { func sendMessageViaEmail(message: String) { let emailSender = EmailSender() emailSender.sendMessage(message: message) } func sendMessageViaSMS(message: String) { let smsSender = SMSSender() smsSender.sendMessage(message: message) } func sendMessageViaPushNotification(message: String) { let pushNotificationSender = PushNotificationSender() pushNotificationSender.sendMessage(message: message) } } Adhering to DIP // Protocol defining the interface for sending messages protocol MessageSender { func sendMessage(message: String) } // High-level module depending on abstraction (MessageSender protocol) class MessageService { private let messageSender: MessageSender init(messageSender: MessageSender) { self.messageSender = messageSender } func sendMessage(message: String) { messageSender.sendMessage(message: message) } } // Concrete implementations of MessageSender protocol for different channels class EmailSender: MessageSender { func sendMessage(message: String) { print(\u0026#34;Sending email: \\(message)\u0026#34;) } } class SMSSender: MessageSender { func sendMessage(message: String) { print(\u0026#34;Sending SMS: \\(message)\u0026#34;) } } class PushNotificationSender: MessageSender { func sendMessage(message: String) { print(\u0026#34;Sending push notification: \\(message)\u0026#34;) } } // Example usage let emailSender = EmailSender() let smsSender = SMSSender() let pushNotificationSender = PushNotificationSender() let emailService = MessageService(messageSender: emailSender) let smsService = MessageService(messageSender: smsSender) let pushNotificationService = MessageService(messageSender: pushNotificationSender) emailService.sendMessage(message: \u0026#34;Hello via email\u0026#34;) smsService.sendMessage(message: \u0026#34;Hello via SMS\u0026#34;) pushNotificationService.sendMessage(message: \u0026#34;Hello via push notification\u0026#34;) Thank you for reading! ðŸ˜Š ","permalink":"http://localhost:1313/posts/the-dependency-inversion-principle/","summary":"What is a Dependency Inversion Principle? The Dependency Inversion Principle means that high-level modules should not depend on low-level modules.\nSource\nSource\nWhat problems does it solve? The Dependency Inversion Principle (DIP) helps solve:\nRigidity Fragility Immobility problems Real-world code example Violation of DIP // High-level module directly depending on low-level modules class MessageService { func sendMessageViaEmail(message: String) { let emailSender = EmailSender() emailSender.sendMessage(message: message) } func sendMessageViaSMS(message: String) { let smsSender = SMSSender() smsSender.","title":"The Dependency Inversion Principle"},{"content":"What is a Big O notation? The Big O notation helps identify algorithm efficiency. It can measure computation and memory growth with respect to input. Real-world code example O(n) â€” Linear Time\nfunc containsValue(array: [Int], value: Int) -\u0026gt; Bool { for element in array { if element == value { return true } } return false } O(1) â€” Constant Time\nfunc findFirstElement(array: [Int]) -\u0026gt; Int? { return array.first } Thank you for reading!\n","permalink":"http://localhost:1313/posts/big-o-notation/","summary":"What is a Big O notation? The Big O notation helps identify algorithm efficiency. It can measure computation and memory growth with respect to input. Real-world code example O(n) â€” Linear Time\nfunc containsValue(array: [Int], value: Int) -\u0026gt; Bool { for element in array { if element == value { return true } } return false } O(1) â€” Constant Time\nfunc findFirstElement(array: [Int]) -\u0026gt; Int? { return array.first } Thank you for reading!","title":"Big O notation"},{"content":"What is Combine? Combine Framework provides an API for processing async events over time such as user-input, network response, and other dynamic data.\nWhat is the purpose of Combine? The purpose of Combine is to simplify the management of async events and data streams.\nPublishers Publisher declares that a type can transit a sequence of values over time. A publisher delivers elements to one or more Subscriber instances.\nclass PostService { func fetchPosts() -\u0026gt; AnyPublisher\u0026lt;[Post], Error\u0026gt; { guard let url = URL(string: \u0026#34;https://jsonplaceholder.typicode.com/posts\u0026#34;) else { fatalError(\u0026#34;Invalid URL\u0026#34;) } return URLSession.shared.dataTaskPublisher(for: url) .map(\\.data) .decode(type: [Post].self, decoder: JSONDecoder()) .receive(on: DispatchQueue.main) .eraseToAnyPublisher() } } Subscribers Subscriber is a protocol that declares a type that can receive input from a publisher. A Subscriber instance receives a stream of elements from a Publisher.\nprivate var cancellable: AnyCancellable? let service = PostService() cancellable = service.fetchPosts() .sink(receiveCompletion: { completion in switch completion { case .finished: break case .failure(let error): print(error.localizedDescription) } }, receiveValue: { posts in print(\u0026#34;Received posts count:\u0026#34;, posts.count) }) AnyCancellable When you call a method like sink or assign on a publisher, it returns a type that conforms to the Cancellable protocol. Storing this return value in an instance of AnyCancellable keeps the subscription active. When the AnyCancellable instance is deallocated, its deinit method automatically cancels the subscription.\nvar cancellables = Set\u0026lt;AnyCancellable\u0026gt;() let publisher = Just(\u0026#34;Hello, Combine!\u0026#34;) publisher .sink { completion in print(\u0026#34;Completion: \\(completion)\u0026#34;) } receiveValue: { value in print(\u0026#34;Received value: \\(value)\u0026#34;) } .store(in: \u0026amp;cancellables) Operators Transforming Operators map: Transforms each value received from a publisher by applying a function. flatMap: Transforms each value received into a new publisher, then flattens the result into a single publisher stream. scan: Applies a closure over the previous result and the current value to produce a new value, useful for accumulating values. Filtering Operators filter: Emits only those values from a publisher that satisfy a given predicate. removeDuplicates: Suppresses duplicate consecutive values published by a publisher. first/last: Emits only the first or last value from a publisher that satisfies a predicate condition. Combining Operators combineLatest: Combines the latest value from two or more publishers and emits a combined value each time any of the publishers emit a value. merge: Combines multiple publishers of the same type into a single publisher stream, emitting values as they arrive. zip: Combines values from multiple publishers into tuples, emitting a tuple only when each of the publishers has emitted a new value. Error Handling Operators catch: Handles errors from a publisher by replacing the failed publisher with another publisher or a value. retry: Attempts to recreate a subscription to a failed publisher for a specified number of times. Utility Operators delay: Delays the emission of items from the publisher for a specified interval. subscribe(on:)/receive(on:): Specifies the dispatch queue for performing subscription work or receiving values. print: Prints log messages for all publisher events to the console, useful for debugging. Timing Operators debounce: Emits a value from a publisher only after a specified time interval has passed without receiving another value. throttle: Emits either the first or last value received in a specified time window. Collecting Operators collect: Collects received values and emits an array of those values either when the publisher completes or when a buffer size is reached. When to use Combine? I found great advice from Apple when it comes to Combine:\nâ€œA Combine publisher fills a role similar to, but distinct from, the AsyncSequence in the Swift standard library. A Publisher and an AsyncSequence both produce elements over time. However, the pull model in Combine uses a Subscriber to request elements from a publisher, while Swift concurrency uses the for-await-in syntax to iterate over elements published by an AsyncSequence. Both APIs offer methods to modify the sequence by mapping or filtering elements, while only Combine provides time-based operations like debounce(for:scheduler:options:) and throttle(for:scheduler:latest:), and combining operations like merge(with:) and combineLatest(_:_:). To bridge the two approaches, the property values exposes a publisherâ€™s elements as an AsyncSequence, allowing you to iterate over them with for-await-in rather than attaching a Subscriber.â€\nThank you for reading!\n","permalink":"http://localhost:1313/posts/combine-basics/","summary":"What is Combine? Combine Framework provides an API for processing async events over time such as user-input, network response, and other dynamic data.\nWhat is the purpose of Combine? The purpose of Combine is to simplify the management of async events and data streams.\nPublishers Publisher declares that a type can transit a sequence of values over time. A publisher delivers elements to one or more Subscriber instances.\nclass PostService { func fetchPosts() -\u0026gt; AnyPublisher\u0026lt;[Post], Error\u0026gt; { guard let url = URL(string: \u0026#34;https://jsonplaceholder.","title":"Combine â€” Basics"},{"content":"When was it introduced? It was introduced in Swift 5.5 at WWDC 2021.\nYou can find the more comprehensive info about Modern Concurrency in Swift Concurrency Manifesto.\nWhat are actors? Actors eliminate shared mutable state and explicit synchronization through deep copying of all the data that passed to an actor to a message sent and preventing direct access to actor state. Actors are reference types.\nactor DatabaseManager { private var data: [String: String] = [:] func readData(key: String) -\u0026gt; String? { data[key] } func writeData(key: String, value: String) { data[key] = value } } What is an asynchronous function? The asynchronous function or asynchronous method can be suspended while it is partway through execution. It can pause in the middle when itâ€™s waiting for something.\nfunc someAsyncOperation(index: Int) async throws -\u0026gt; String { try await Task.sleep(nanoseconds: 1_000_000_000) return \u0026#34;Operation \\(index) Completed\u0026#34; } func performAsyncOperations() async throws { for index in 1...1000 { Task.detached { print(\u0026#34;Start of operation \\(index)\u0026#34;) let result = try await someAsyncOperation(index: index) print(\u0026#34;End of operation \\(index) with result: \\(result)\u0026#34;) return result } } } Task { print(\u0026#34;Start of example\u0026#34;) try await performAsyncOperationsWithYield() print(\u0026#34;End of example\u0026#34;) } What are Asynchronous Sequences? Asynchronous Sequences enable you to stop an async task until the next item is prepared, giving room for other tasks to progress. Crafting your own Asynchronous Sequence involves adhering to the AsyncSequence protocol.\nstruct AsyncCounter: AsyncSequence { typealias Element = Int struct AsyncCounterIterator: AsyncIteratorProtocol { var count = 0 mutating func next() async -\u0026gt; Int? { defer { count += 1 } return count } } func makeAsyncIterator() -\u0026gt; AsyncCounterIterator { return AsyncCounterIterator() } } let asyncCounter = AsyncCounter() for await count in asyncCounter { print(\u0026#34;Count: \\(count)\u0026#34;) try await Task.sleep(nanoseconds: 1 * 1_000_000_000) } What are Tasks and TaskGroups? You can draw a parallel between Tasks and DispatchQueue`s because they have similar concepts. If you want to execute your code asynchronously you should put your code into async context. Tasks and Queues help you solve this problem.\nfunc fetchData() async throws -\u0026gt; String { try await Task.sleep(nanoseconds: 2 * 1_000_000_000) return \u0026#34;Data fetched successfully!\u0026#34; } Task { print(\u0026#34;Start fetching data...\u0026#34;) do { let result = try await fetchData() print(result) } catch { print(\u0026#34;Error: \\(error)\u0026#34;) } print(\u0026#34;Data fetching completed.\u0026#34;) } let customQueue = DispatchQueue(label: \u0026#34;com.example.myqueue\u0026#34;, attributes: .concurrent) func performTask() { customQueue.async { print(\u0026#34;Task is starting...\u0026#34;) Thread.sleep(forTimeInterval: 2) print(\u0026#34;Task completed.\u0026#34;) } } for _ in 1...3 { performTask() } TaskGroup allows you to explicitly add child tasks and give you more control over priority and cancellation.\nfunc fetchImages(urls: [URL]) async throws -\u0026gt; [UIImage] { try await withThrowingTaskGroup(of: UIImage.self) { group in var images: [UIImage] = [] for url in urls { group.addTask { try await downloadImage(from: url) } } for try await result in group { images.append(result) } return images } } func downloadImage(from url: URL) async throws -\u0026gt; UIImage { // Download and return the image } What is Task.yield()? If you have a long-running operation you can call the Task.yield() method to explicitly add suspension points. By doing that you are letting other tasks make progress.\nfunc performAsyncOperationsWithYield() async throws { for index in 1...1000 { Task.detached { print(\u0026#34;Start of operation \\(index)\u0026#34;) // Yield control to the scheduler await Task.yield() let result = try await someAsyncOperation(index: index) print(\u0026#34;End of operation \\(index) with result: \\(result)\u0026#34;) return result } } } What are Sendable Types? A type that can be shared from one concurrency context to another is known as a sendable type. In other words it guarantees that the operation that you perform is thread-safe.\nimport Foundation struct WeatherData: Sendable { var temperature: Double var condition: String var city: String } func fetchWeatherData(forCity city: String) async -\u0026gt; WeatherData { try? await Task.sleep(nanoseconds: 1_000_000_000) return WeatherData(temperature: 72.0, condition: \u0026#34;Sunny\u0026#34;, city: city) } import SwiftUI @MainActor class WeatherViewModel: ObservableObject { @Published var currentWeather: WeatherData? func updateWeather(forCity city: String) { Task { let weatherData = await fetchWeatherData(forCity: city) // Since WeatherData conforms to Sendable, this is safe self.currentWeather = weatherData } } } Thank you for reading!\n","permalink":"http://localhost:1313/posts/modern-concurrency/","summary":"When was it introduced? It was introduced in Swift 5.5 at WWDC 2021.\nYou can find the more comprehensive info about Modern Concurrency in Swift Concurrency Manifesto.\nWhat are actors? Actors eliminate shared mutable state and explicit synchronization through deep copying of all the data that passed to an actor to a message sent and preventing direct access to actor state. Actors are reference types.\nactor DatabaseManager { private var data: [String: String] = [:] func readData(key: String) -\u0026gt; String?","title":"Modern Concurrency"},{"content":"What is the Thread? A Thread is a small set of instructions that can be executed independently from the main program. Threads are often used to improve program performance by allowing multiple tasks to be executed at the same time. The Thread has its own stack, registers, and program counters.\nThreads share memory address space, and it is possible to communicate between Threads using shared memory space. How to use it? You can create a single Thread by the following example:\n// Create a new thread and start it let newThread = Thread { } newThread.start() What else can you do? You can:\ncancel exit sleep etc You can check the current Thread execution state: isExecuting isFinished isCancelled You can subclass Thread and override the main() method if you need it.\nCaveats The main problem with Threads is that you must manually manage relationships between them. It can cause testability, readability, and potentially Thread Explosion issues.\nWhat is Thread Explosion? Thread Explosion occurs when a system has too many running Threads simultaneously. It can cause performance issues such as memory overhead and cost of context switching (CPU cycles).\nTips You can delegate your work with Threads to Grand Central Dispatch (GCD).\nGCD provides an API that manages the number of Threads automatically.\nYou can also use async/await and Task functionality from Swift 5.5 that helps manage the number of Threads in poll-based factors like system load and the number of available CPUs. If you have a long-running operation, you can call the Task.yield() method and let other tasks in your program make progress on their work.\nThank you for reading!\n","permalink":"http://localhost:1313/posts/what-are-threads-in-swift/","summary":"What is the Thread? A Thread is a small set of instructions that can be executed independently from the main program. Threads are often used to improve program performance by allowing multiple tasks to be executed at the same time. The Thread has its own stack, registers, and program counters.\nThreads share memory address space, and it is possible to communicate between Threads using shared memory space. How to use it?","title":"What are Threads in Swift?"},{"content":"What is DispatchGroup? DispatchGroup provides a mechanism to track the completion group of tasks.\nHow DispatchGroup works? DispatchGroup has three main methods, enter, leave and notify, that allow you to control the completion of a specific task.\nlet dispatchGroup = DispatchGroup() dispatchGroup.enter() dispatchGroup.leave() dispatchGroup.notify(queue: .main) {} Let`s talk about each of these methods. enter â€” manually indicate a block has entered group. leave â€” manually indicate a block in the group has been completed. notify(queue: ) â€” schedule a block to be submitted to a queue when all the blocks associated with a group have been completed. The queue parameter is the queue to which the supplied block will be submitted when the group is complete.\nHow to implement DispatchGroup? You can implement DispatchGroup following these steps:\nlet dispatchGroup = DispatchGroup() dispatchGroup.enter() fetchGitHubUser1 { print(\u0026#34;fetchGitHubUser1 task completed\u0026#34;) dispatchGroup.leave() } dispatchGroup.enter() fetchGitHubUser2 { print(\u0026#34;fetchGitHubUser2 task completed\u0026#34;) dispatchGroup.leave() } dispatchGroup.notify(queue: .main) { print(\u0026#34;All tasks completed\u0026#34;) } // prints fetchGitHubUser1 task started fetchGitHubUser2 task started fetchGitHubUser1 task completed fetchGitHubUser2 task completed All tasks completed Pros You can create a group of tasks and track when all tasks finish their work. You can specify a queue where you want to be notified about completed operations.\nCons You should manually manage enter and leave operations that increase complexity and the chance of error. You can accidentally forget to write the leave operation, which can cause unpredictable behavior.\n","permalink":"http://localhost:1313/posts/dispatchgroup-in-swift/","summary":"What is DispatchGroup? DispatchGroup provides a mechanism to track the completion group of tasks.\nHow DispatchGroup works? DispatchGroup has three main methods, enter, leave and notify, that allow you to control the completion of a specific task.\nlet dispatchGroup = DispatchGroup() dispatchGroup.enter() dispatchGroup.leave() dispatchGroup.notify(queue: .main) {} Let`s talk about each of these methods. enter â€” manually indicate a block has entered group. leave â€” manually indicate a block in the group has been completed.","title":"DispatchGroup in Swift"},{"content":"What is concurrency? The system can perform multiple tasks simultaneously. By tasks, I mean code or instructions. Modern computer chips have multiple cores that allow developers to create and run various tasks on multiple cores. Even if your chip has one core operating system it will provide context switching mechanism by enabling it to execute multiple tasks concurrently.\nMaterial about processes, threads I will skip explaining concepts about processes and threads because it is a vast topic, and it will take a lot of time to explain it. I attached links to the material to help you understand it more deeply. https://youtu.be/4rLW7zg21gI?si=49hq8Wrbpmeev41k https://youtu.be/r2__Rw8vu1M?si=b7b257Qu4Bty7OxA I will focus on implementation.\nThe old and modern way of implementing concurrency You can divide concurrency implementation into old or unstructured and modern or structured.\nBy old, I mean GCD (Grand Central Dispatch). By modern, I mean async/await, actor, and Task.\nIn this article, I will talk about the old way. GCD helps you keep your distance from manually managing threads and avoid unnecessary complexity, and it does it by providing API. One of these APIs is DispatchQueue.\nDispatchQueue By default, DispatchQueue is serial; all work on this queue will be executed sequentially. DispatchQueue has access to the main property and the global() method. The main property returns the serial queue associated with the main thread of the current process. The global() method returns a concurrent queue specified by quality-of-service level.\npublic class func global(qos: DispatchQoS.QoSClass = .default) -\u0026gt; DispatchQueue You can pass many parameters when you try to initialize a new queue.\npublic convenience init(label: String, qos: DispatchQoS = .unspecified, attributes: DispatchQueue.Attributes = [], autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency = .inherit, target: DispatchQueue? = nil) Letâ€™s talk about three of them (label, qos, attributes). The first is label, which is used mainly for debugging and identification.\nlet queue = DispatchQueue(label: \u0026#34;com.example.myqueue\u0026#34;) The second one is qos (Quality Of Service) allows you to choose the priority in which you like to run your task. You can choose between background, utility, default, userInitiated, userIneractive, and unspecified priorities.\n/// qos_class_t public struct DispatchQoS : Equatable { public let qosClass: DispatchQoS.QoSClass public let relativePriority: Int @available(macOS 10.10, iOS 8.0, *) public static let background: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let utility: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let `default`: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let userInitiated: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let userInteractive: DispatchQoS public static let unspecified: DispatchQoS } userIneractive has the highest priority; it usually calls when you need to display UI almost immediately.\nbackground, on the other hand, has the lowest priority.\nHow to achieve concurrency with DispatchQueue API? You can use a serial queue with the following: sync functionality allows you to wait until the block you passed finishes its work.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serial\u0026#34;) serialQueue.sync {} async functionality will schedule your work and be executed later in time.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serial\u0026#34;) serialQueue.async {} Or you can use a concurrent queue with similar methods but running your task in parallel.\nlet concurrentQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.concurrent\u0026#34;, attributes: .concurrent) concurrentQueue.sync {} concurrentQueue.async {} The difference between serial queue and concurrent queue The difference between a serial and concurrent queue is that you should not wait until the concurrent operation finishes work in the async block.\nlet concurrentQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.concurrent\u0026#34;, attributes: .concurrent) concurrentQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } concurrentQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Concurrent Queue Task 6 is running on Concurrent Queue Task 2 is running on Concurrent Queue Task 7 is running on Concurrent Queue Task 3 is running on Concurrent Queue Task 8 is running on Concurrent Queue Task 4 is running on Concurrent Queue Task 9 is running on Concurrent Queue Task 5 is running on Concurrent Queue Task 10 is running on Concurrent Queue The serial queue executes tasks in order, and you should wait until the first async block finishes its work to start the second block.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serual\u0026#34;) serialQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } serialQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Serial Queue Task 2 is running on Serial Queue Task 3 is running on Serial Queue Task 4 is running on Serial Queue Task 5 is running on Serial Queue Task 6 is running on Serial Queue Task 7 is running on Serial Queue Task 8 is running on Serial Queue Task 9 is running on Serial Queue Task 10 is running on Serial Queue When you try to use the sync functionality, it behaves similarly on serial and concurrent queues by executing each task step by step and waiting till each block finishes its work.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serial\u0026#34;) serialQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } serialQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Serial Queue Task 2 is running on Serial Queue Task 3 is running on Serial Queue Task 4 is running on Serial Queue Task 5 is running on Serial Queue Task 6 is running on Serial Queue Task 7 is running on Serial Queue Task 8 is running on Serial Queue Task 9 is running on Serial Queue Task 10 is running on Serial Queue let concurrentQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.concurrent\u0026#34;, attributes: .concurrent) concurrentQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } concurrentQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Concurrent Queue Task 2 is running on Concurrent Queue Task 3 is running on Concurrent Queue Task 4 is running on Concurrent Queue Task 5 is running on Concurrent Queue Task 6 is running on Concurrent Queue Task 7 is running on Concurrent Queue Task 8 is running on Concurrent Queue Task 9 is running on Concurrent Queue Task 10 is running on Concurrent Queue ","permalink":"http://localhost:1313/posts/concurrency-in-swift/","summary":"What is concurrency? The system can perform multiple tasks simultaneously. By tasks, I mean code or instructions. Modern computer chips have multiple cores that allow developers to create and run various tasks on multiple cores. Even if your chip has one core operating system it will provide context switching mechanism by enabling it to execute multiple tasks concurrently.\nMaterial about processes, threads I will skip explaining concepts about processes and threads because it is a vast topic, and it will take a lot of time to explain it.","title":"Concurrency in Swift"},{"content":"What are value types? Value types play a central role in programming languages by grouping data values.\n`Value typeâ€ is a type of data copied when assigned to a new variable.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` How can you pass value types? You can pass value type by copying value.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` copiedStorage.data = \u0026#34;new data\u0026#34; // Changes `copiedStorage`, not `originalStorage` print(\u0026#34;\\(originalStorage.data), \\(copiedStorage.data)\u0026#34;) // prints \u0026#34;some data, new data\u0026#34; The effect of assignment, initialization, and argument passing creates an independent instance with a unique copy of its data.\nWhat types are value types? Value types can be struct, enum, tuple.\nWhat data types are value types? Strings, Arrays, Dictionaries, Numbers, Booleans, Floating-point numbers, and Integers are all value types.\nHow value types are stored in memory? The value types use Stack data structure for memory management.\nWhat is Copy-on-write mechanism? The copy-on-write mechanism is a resource-management technique used to optimize value types performance. It improves performance by avoiding unnecessary copies of value types. If resource is duplicated but not modified itâ€™s unnecessary to create new resource.\nWhen to use value types? Choose value types if you donâ€™t have shared mutable state.\n","permalink":"http://localhost:1313/posts/what-are-value-types-in-swift/","summary":"What are value types? Value types play a central role in programming languages by grouping data values.\n`Value typeâ€ is a type of data copied when assigned to a new variable.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` How can you pass value types? You can pass value type by copying value.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` copiedStorage.","title":"What are value types in Swift?"},{"content":"I was searching for tools that could help me find memory leaks faster and would be simple in implementation without affecting performance and memory size of application.\nI found a fantastic fit for this task LifetimeTracker developed by Krzysztof ZabÅ‚ocki.\nAll you need is to add LifetimeTracker package to the project, inherit from LifetimeTrackable protocol, and add two lines of code.\nclass Department: LifetimeTrackable {} trackLifetime method to init of instance that you are going to verify, and lifetimeConfiguration property where you set max number of valid instances.\nclass Department: LifetimeTrackable { static var lifetimeConfiguration = LifetimeConfiguration(maxCount: 1, groupName: \u0026#34;Department\u0026#34;) let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) trackLifetime() } var employee: Employee? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } The final step is to add LifetimeTracker.setup to didFinishLaunchingWithOptions to be able to see Dashboard with detected issues.\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { #if DEBUG LifetimeTracker.setup( onUpdate: LifetimeTrackerDashboardIntegration( visibility: .alwaysVisible, style: .bar, textColorForNoIssues: .systemGreen, textColorForLeakDetected: .systemRed ).refreshUI ) #else #endif return true } I hope this article will help you save time finding and debugging this tricky task :-).\n","permalink":"http://localhost:1313/posts/how-to-prevent-memory-leaks/","summary":"I was searching for tools that could help me find memory leaks faster and would be simple in implementation without affecting performance and memory size of application.\nI found a fantastic fit for this task LifetimeTracker developed by Krzysztof ZabÅ‚ocki.\nAll you need is to add LifetimeTracker package to the project, inherit from LifetimeTrackable protocol, and add two lines of code.\nclass Department: LifetimeTrackable {} trackLifetime method to init of instance that you are going to verify, and lifetimeConfiguration property where you set max number of valid instances.","title":"How to prevent memory leaks?"},{"content":"The common way to find memory leaks is by using Xcode Instruments. All you need is the following:\nOpen Xcode Instruments\nChoose Leaks option Select Simulator where you are going to test your application Select your installed application When you finish preparation, you can start immediate recoding and check application for leaks. To do that, you need to open Simulator and try some cases that could cause memory leaks.\nAfter you spend some time trying different scenarios, you can see that Instruments found Leaked Objects. Another way to find memory leaks is by using Debug Memory Graph in Xcode Debug Area. Inside Debug Memory Graph, you can find MemoryLeaks section. MemoryLeaks section displays what objects have strong reference cycles between themselves.\nAll tools above have opportunity to find and highlight potential issues and help you resolve them.\n","permalink":"http://localhost:1313/posts/how-to-find-memory-leaks/","summary":"The common way to find memory leaks is by using Xcode Instruments. All you need is the following:\nOpen Xcode Instruments\nChoose Leaks option Select Simulator where you are going to test your application Select your installed application When you finish preparation, you can start immediate recoding and check application for leaks. To do that, you need to open Simulator and try some cases that could cause memory leaks.\nAfter you spend some time trying different scenarios, you can see that Instruments found Leaked Objects.","title":"How to find memory leaks?"},{"content":"What is ARC? Swift uses Automatic Reference Counting (ARC) to track and manage your appâ€™s memory usage. In most cases, this means that memory management â€œjust worksâ€ in Swift, and you donâ€™t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed. - Apple\nARC In Action In this example, we assign an instance to the reference1 property.\nnumber of references equals 1. class Storage { let data: Data init(data: Data) { self.data = data print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var reference1: Storage? var reference2: Storage? var reference3: Storage? reference1 = Storage(data: Data()) Now we can assign a reference to another two properties, reference2 and reference3. Whenever you assign a reference, you increase the counter.\nnumber of references equals 3. reference2 = reference1 reference3 = reference1 When you set reference2 and reference3 to nil, the number of references equals 1.\nreference2 = nil reference3 = nil Only when you set reference1 to nil object will be deinitialized.\nreference1 = nil Memory leaks Memory leaks appear when you have strong references between two instances that point to each other.\nIn this example, class Employee has optional department property, and class Department has optional employee property.\nclass Department { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } var employee: Employee? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } class Employee { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } var department: Department? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var employee: Employee? var department: Department? employee = Employee(name: \u0026#34;John Doe\u0026#34;) department = Department(name: \u0026#34;Research and development\u0026#34;) If we try to assign Department reference to employee property and Employee reference to department property, it creates a memory leak by strong references that point to each other.\nemployee!.department = department department!.employee = employee If you try to set employee and department properties to nil, then these two objects canâ€™t be deallocated because of the existing strong reference relationship between both objects.\nemployee = nil department = nil To avoid this unpleasant situation, we can use weak, unowned references.\nWeak reference If you use a weak keyword before a property, you say that this property should not keep a strong reference. Weak property should always be mutable and optional because ARC set the property to nil after the instance was deallocated.\nIn this example, Employee instance has department property with weak keyword. It means when we set employee property to nil ARC sets department property to nil and deallocates Department instance.\nclass Department { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } var employee: Employee? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } class Employee { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } weak var department: Department? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var employee: Employee? var department: Department? employee = Employee(name: \u0026#34;John Doe\u0026#34;) department = Department(name: \u0026#34;Research and development\u0026#34;) employee!.department = department department!.employee = employee department = nil employee = nil Unowned reference Unowned reference canâ€™t be optional, and it should always have value. If you try to access a deallocated property value, you will face a runtime error.\nIn this example, we have two instances: User and DiscountCard. DiscountCard has a relationship with the User that is marked as unowned to avoid a strong reference cycle.\nclass User { let name: String var discountCard: DiscountCard? init(name: String) { self.name = name } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } class DiscountCard { let number: UInt64 unowned let user: User init(number: UInt64, user: User) { self.number = number self.user = user } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var user: User? user = User(name: \u0026#34;John Doe\u0026#34;) When you create DiscountCard instance and assign it as reference to user property, it no longer holds strong reference.\nuser!.discountCard = DiscountCard(number: 1234_5678_9012_3456, user: user!) After we set user property to nil, it will deallocate User and DiscountCard instances.\nuser = nil Strong Reference Cycles for Closures Strong reference cycle for closure can occur if you assign closure to property of instance. In this case, you assign reference to that closure. The strong reference cycle appears because closures are reference types.\nclass MemoryStorage { let text: String let additionalText: String? lazy var copy: () -\u0026gt; String = { if let additionalText = self.additionalText { self.text + \u0026#34;\\n\u0026#34; + additionalText } else { self.text } } init(text: String, additionalText: String? = nil) { self.text = text self.additionalText = additionalText } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var memoryStorage: MemoryStorage? = MemoryStorage(text: \u0026#34;Thank you for registration\u0026#34;, additionalText: \u0026#34;John Doe\u0026#34;) print(memoryStorage!.copy()) memoryStorage = nil In this example, closure captures self.text property and create strong reference cycle by referencing to self.\nBreaking Strong Reference Cycle in Closure To break strong reference cycle, we need to add capture list with unowned keyword to copy closure.\nclass MemoryStorage { let text: String let additionalText: String? lazy var copy: () -\u0026gt; String = { [unowned self] in if let additionalText = self.additionalText { self.text + \u0026#34;\\n\u0026#34; + additionalText } else { self.text } } init(text: String, additionalText: String? = nil) { self.text = text self.additionalText = additionalText } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var memoryStorage: MemoryStorage? = MemoryStorage(text: \u0026#34;Thank you for registration\u0026#34;, additionalText: \u0026#34;John Doe\u0026#34;) print(memoryStorage!.copy()) memoryStorage = nil ","permalink":"http://localhost:1313/posts/arc-in-swift/","summary":"What is ARC? Swift uses Automatic Reference Counting (ARC) to track and manage your appâ€™s memory usage. In most cases, this means that memory management â€œjust worksâ€ in Swift, and you donâ€™t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed. - Apple\nARC In Action In this example, we assign an instance to the reference1 property.","title":"ARC in Swift"},{"content":"Introduction In this article, Iâ€™m going to briefly explain what closure is.\nClosures is self-conitained blocks of funcionality that can be passed around and used in your code. â€” Apple\nExpression:\n{ (params) -\u0026gt; return value in statements } @escaping When closure is marked as escaping, it will outlive or leave the scope you passed.\nfunc response(_ completionHandler: @escaping(Result) -\u0026gt; Void) { completionHandler(.success) } @nonescaping By default, closures are nonescaping, meaning closure will no longer exist in memory after complete execution in the scope you have passed it to.\nfunc filterImage(_ completionHandler: (Image) -\u0026gt; Void) { completionHandler(UIImage.filtered) } @autoclosure Autoclosures automatically create closure from the argument that you passed into a function.\nfunc animate(_ animation: @autoclosure @escaping () -\u0026gt; Void, duration: TimeInterval = 0.25) { UIView.animate(withDuration: duration, animations: animation) } Closure conceptualy looks like this first pointer points to the code that implements closure the second pointer pointed to the reference counted object.\nstruct Closure { var functionPointer: UnsafeRawPointer var closureContext: AnyObject? } ","permalink":"http://localhost:1313/posts/what-is-closure-in-swift-language/","summary":"Introduction In this article, Iâ€™m going to briefly explain what closure is.\nClosures is self-conitained blocks of funcionality that can be passed around and used in your code. â€” Apple\nExpression:\n{ (params) -\u0026gt; return value in statements } @escaping When closure is marked as escaping, it will outlive or leave the scope you passed.\nfunc response(_ completionHandler: @escaping(Result) -\u0026gt; Void) { completionHandler(.success) } @nonescaping By default, closures are nonescaping, meaning closure will no longer exist in memory after complete execution in the scope you have passed it to.","title":"What is closure in Swift language?"},{"content":"Introduction In Swift, classes, closures, and actors all reference types.\n\u0026lsquo;Reference typeâ€™ is instance that shares a single copy of data.\nAssigning a reference type to a constant or variable, or passing it into a function or method, it is always a reference to a shared instance that is assigned or passed in.\nExample You can pass your property value by sharing the same address in memory.\n// Reference type example class Storage { var data = â€œdata-exampleâ€ } var storage = Storage() print(\u0026#34;\\(storage.data)\u0026#34;) // prints \u0026#34;data-example\u0026#34; print(\u0026#34;storage address:\u0026#34;, Unmanaged.passUnretained(storage).toOpaque()) var copiedStorage = storage copiedStorage.data = â€œnew-dataâ€ print(\u0026#34;\\(storage.data), \\(copiedStorage.data)\u0026#34;) // prints \u0026#34;new-data, new-data\u0026#34; print(\u0026#34;copiedStorage address:\u0026#34;, Unmanaged.passUnretained(copiedStorage).toOpaque()) As you can see, storage and copied storage property addresses are the same.\nSummary Copying data by reference refers to the same address in memory. This means that modifying data in one variable also affects another. It also means that multiple reference types may refer to the same object.\n","permalink":"http://localhost:1313/posts/what-is-reference-type-in-swift/","summary":"Introduction In Swift, classes, closures, and actors all reference types.\n\u0026lsquo;Reference typeâ€™ is instance that shares a single copy of data.\nAssigning a reference type to a constant or variable, or passing it into a function or method, it is always a reference to a shared instance that is assigned or passed in.\nExample You can pass your property value by sharing the same address in memory.\n// Reference type example class Storage { var data = â€œdata-exampleâ€ } var storage = Storage() print(\u0026#34;\\(storage.","title":"What is â€œreference typeâ€ in Swift?"},{"content":"Introduction The Composable Architecture (TCA) uses a unidirectional data flow (UDF). UDF is a design pattern where data and events move consistently and predictably. In UDF, data can only be transferred to other application parts in one way.\nIn TCA, the only way to mutate the state is by sending actions to a runtime store. The runtime store holds the entire appâ€™s business logic and mutates the state inside.\nUDF can reduce data inconsistencies because of the single source of truth for the application.\nTCA is built around key components: Action State Reducer Effect Store Environment Code examples: Timer\nhttps://github.com/dmytrochumakov/TCA-Examples/tree/main/Timer/Timer/Timer Sources: https://github.com/pointfreeco/swift-composable-architecture https://www.youtube.com/watch?v=SfFDj6qT-xg\u0026ab_channel=SwiftandTips https://www.youtube.com/watch?v=XWZmgbylTpc\u0026ab_channel=SwiftHeroes https://www.youtube.com/watch?v=McmGb9sexMo\u0026ab_channel=SwiftandTips https://www.youtube.com/watch?v=McmGb9sexMo\u0026ab_channel=SwiftandTips https://markvillar.com/the-composable-architecture/ ","permalink":"http://localhost:1313/posts/lets-talk-about-composable-architecture/","summary":"Introduction The Composable Architecture (TCA) uses a unidirectional data flow (UDF). UDF is a design pattern where data and events move consistently and predictably. In UDF, data can only be transferred to other application parts in one way.\nIn TCA, the only way to mutate the state is by sending actions to a runtime store. The runtime store holds the entire appâ€™s business logic and mutates the state inside.\nUDF can reduce data inconsistencies because of the single source of truth for the application.","title":"Letâ€™s talk about Composable Architecture"},{"content":" Hi! I'm Dmytro Chumakov.\nHighly skilled iOS Developer with extensive experience in developing, and testing mobile application projects.\nProficient in Swift, Objective-C, and SwiftUI, with a strong foundation in modern software engineering practices.\nKnown for enhancing application performance, and automating repetitive tasks.\nMy Values Innovation: I consistently seek innovative solutions, leveraging modern technologies and creative thinking to stay ahead of the curve.\nEfficiency: My focus on streamlining processes and maximizing productivity underscores my commitment to efficiency in every aspect of my work.\nQuality: I am dedicated to delivering high-quality products, ensuring excellence through thorough testing, documentation, and performance optimization.\nUser-Centricity: My development approach prioritizes user needs and experience, crafting applications that prioritize safety, interaction, and functionality.\nContinuous Learning: I actively pursue ongoing learning and skill development, staying updated with the latest industry trends and technologies.\nCollaboration: I thrive in collaborative environments, leveraging leadership skills to drive teamwork and achieve collective success in project delivery.\nCommunity Engagement: I am passionate about sharing knowledge and contributing to the developer community through technical posts and videos, fostering growth and learning for others.\n","permalink":"http://localhost:1313/about/","summary":"Information about me.","title":"About Me"},{"content":" E-commerce Proficient in developing marketplace and utility management apps, capable of creating e-commerce platforms with features like product catalogs, user authentication, payment gateways, and order management systems.\nHealthcare Skilled in healthcare app development, with experience in building Glucose Tracker and COVID-19 tracking applications. Capable of developing apps for health metric monitoring, telemedicine, medication management, and wellness tracking.\nFinance Experienced in utility management and currency-related projects, able to create personal finance management apps, budgeting tools, and investment trackers.\nSocial Networking Well-versed in developing social features like buyer-seller chat, suitable for creating social networking apps, messaging platforms, and event planning applications.\nUtility and Productivity Expertise in utility management and macOS tools, ideal for developing task management apps, note-taking tools, and time tracking solutions.\nEducation Background in building Multi-User studying apps and technical resources, capable of contributing to e-learning platforms, and language learning apps.\nCross-Domain Integration Diverse experience enables integration of functionalities across domains, such as combining e-commerce with social networking or incorporating healthcare monitoring into productivity tools.\nOpen Source Contributions Experienced in open-source projects, capable of contributing by improving documentation, fixing bugs, adding features, or creating libraries/frameworks for iOS development.\nEmerging Technologies Stay updated with AR, VR, ML, and IoT trends, exploring projects that leverage these technologies for innovative app development.\n","permalink":"http://localhost:1313/cases/","summary":"E-commerce Proficient in developing marketplace and utility management apps, capable of creating e-commerce platforms with features like product catalogs, user authentication, payment gateways, and order management systems.\nHealthcare Skilled in healthcare app development, with experience in building Glucose Tracker and COVID-19 tracking applications. Capable of developing apps for health metric monitoring, telemedicine, medication management, and wellness tracking.\nFinance Experienced in utility management and currency-related projects, able to create personal finance management apps, budgeting tools, and investment trackers.","title":"Cases"},{"content":"iOS App Maintenance Service This service is designed to improve your appâ€™s stability, leading to more 5-star ratings and increased user satisfaction.\nIs This Service Right for You? Here are a few questions for you:\nAre you tired of getting negative app reviews due to bugs and crashes? Feel frustrated by your appâ€™s low search rank and disappointing download numbers? Always worried about your appâ€™s sudden breakdowns post-iOS updates? Struggling to find a reliable developer when your app needs quick fixes? If youâ€™ve answered â€œyesâ€ to any of these questions, this service is your solution! The Transformations Youâ€™ll Get A Glitch-Free App: Iâ€™ll keep your app free from bugs and crashes, ensuring a smooth user experience and preventing negative reviews. Enhanced User Satisfaction: By delivering a glitch-free app, youâ€™ll provide a seamless and enjoyable experience for your users, leading to higher - user satisfaction and retention rates. Higher Appâ€™s Rating: A flawless app leads to higher ratings and more 5-star reviews, attracting new users and loyal customers. Rise in App Store Rankings: A well-performing app climbs the search rankings, gaining visibility and organic downloads. Stay Ahead of iOS Updates: Iâ€™ll ensure your app stays compatible with iOS updates, eliminating the fear of it breaking after each new release. Expert Developer at Your Fingertips: Iâ€™m always ready to assist you, ensuring your app remains relevant and competitive in the ever-evolving market. Pick What You Need All packages come with a 30-day 110% Money-Back Guarantee.\nMost Popular Lite Essential care for apps\n$399 per month\nUnlimited bug fixes Unlimited crash fixes iOS compatibility updates Bi-weekly app releases Unlimited email support Most Popular Plus Ongoing app enhancement\n$799 per month\nAll services in Lite + Performance monitoring App reviews support Minor UI/UX improvement App content updates Most Popular Pro For constantly evolving apps\n$2499 per month\nAll services in Plus + Feature implementation Major UI/UX improvement Major feature updates Weekly consultation call Ready to Boost Your Appâ€™s Success? Ready to unlock your appâ€™s true potential? Or do you have questions?\nSend me an email or schedule a call with me, and letâ€™s make it happen together. Iâ€™m here to assist you every step of the way.\nGet in Touch Now! ","permalink":"http://localhost:1313/ios-app-maintenance-service/","summary":"iOS App Maintenance Service This service is designed to improve your appâ€™s stability, leading to more 5-star ratings and increased user satisfaction.\nIs This Service Right for You? Here are a few questions for you:\nAre you tired of getting negative app reviews due to bugs and crashes? Feel frustrated by your appâ€™s low search rank and disappointing download numbers? Always worried about your appâ€™s sudden breakdowns post-iOS updates? Struggling to find a reliable developer when your app needs quick fixes?","title":"Services"}]