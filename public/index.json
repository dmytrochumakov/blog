[{"content":"What is a Queue? A Queue is an abstract data type that serves as an ordered collection of elements.\nA simple queue typically has several operations:\npush(item) - adds an item to the tail pop() - removes and returns an item from the head These operations make a queue a FIFO (First In, First Out) data structure.\nImplementation There are two ways to implement a queue.\nThe first and simplest (but less efficient) way is by using an array and basic operations:\nstruct Queue { private(set) var queue: [Int] init(queue: [Int] = []) { self.queue = queue } mutating func push(_ item: Int) { self.queue.insert(item, at: 0) } mutating func pop() -\u0026gt; Int? { return self.queue.popLast() } func peek() -\u0026gt; Int? { return self.queue.last } } The second, more efficient way is by using a linked list, which allows push and pop operations in O(1) time.\nfinal class Node { private(set) var val: Int var next: Node? init( val: Int, next: Node? = nil ) { self.val = val self.next = next } } final class LinkedListQueue { private(set) var head: Node? private(set) var tail: Node? func push(_ item: Int) { let newNode = Node(val: item) if head == nil { self.head = newNode self.tail = newNode return } self.tail?.next = newNode self.tail = newNode } func pop() -\u0026gt; Int? { if head == nil { return nil } let tmp = self.head self.head = tmp?.next if self.head == nil { self.tail = nil } return tmp?.val } } Time/Space Complexity using a Linked List Queue Operation Average Worst Case Insert O(1) O(1) Delete O(1) O(1) Space Complexity: O(n) for both average and worst case.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-queue/","summary":"What is a Queue? A Queue is an abstract data type that serves as an ordered collection of elements.\nA simple queue typically has several operations:\npush(item) - adds an item to the tail pop() - removes and returns an item from the head These operations make a queue a FIFO (First In, First Out) data structure.\nImplementation There are two ways to implement a queue.\nThe first and simplest (but less efficient) way is by using an array and basic operations:","title":"DSA - Queue"},{"content":"What is an Adjacency List? An Adjacency List helps store a list of connections between each vertex in a finite graph.\nVertex Connects with 0 1 1 0, 2, 3 2 1, 3 3 1, 2 Implementation The addEdge method takes vertices as input and adds an edge to the adjacency list. In this example, the adjacency list is represented as a dictionary that maps vertices to a set of all connected vertices.\nIn JSON form, it looks like this:\n{ \u0026#34;0\u0026#34;: [1], \u0026#34;1\u0026#34;: [0, 2, 3], \u0026#34;2\u0026#34;: [1, 3], \u0026#34;3\u0026#34;: [1, 2] } Code Example final class Graph { private(set) var graph: [Int: Set\u0026lt;Int\u0026gt;] init() { self.graph = [:] } func addEdge(u: Int, v: Int) -\u0026gt; [Int: Set\u0026lt;Int\u0026gt;] { if self.graph[u] == nil { self.graph[u] = [v] } else { self.graph[u]!.insert(v) } if self.graph[v] == nil { self.graph[v] = [u] } else { self.graph[v]!.insert(u) } return self.graph } } As for the implementation, the addEdge algorithm checks:\nIf vertex u is already in the graph, it inserts vertex v into the set. Otherwise, it creates a new set for u with vertex v. Finally, it repeats steps 1 \u0026amp; 2 but swaps u and v. Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-adjacency-list/","summary":"What is an Adjacency List? An Adjacency List helps store a list of connections between each vertex in a finite graph.\nVertex Connects with 0 1 1 0, 2, 3 2 1, 3 3 1, 2 Implementation The addEdge method takes vertices as input and adds an edge to the adjacency list. In this example, the adjacency list is represented as a dictionary that maps vertices to a set of all connected vertices.","title":"DSA - Adjacency List"},{"content":"What is a graph? A graph is an abstract data type that represents vertices and edges that connect those vertices.\nSource\nImplementation A graph can be represented as a matrix with edges connecting each pair of vertices. For example, a graph with vertices 0, 1, 2, 3, 4 and edges between them can be represented as a matrix:\n0 1 2 3 4 0 false true false false true 1 true false true true true 2 false true false true false 3 false true true false true 4 true true false true false In Swift, you can use a list of lists (2D array) to represent the matrix:\n[ [false, true, false, false, true], [true, false, true, true, true], [false, true, false, true, false], [false, true, true, false, true], [true, true, false, true, false] ] In any cell where true is found, the corresponding vertices are connected by an edge.\nCode Example final class Graph { private(set) var graph: [[Bool]] init(numVertices: Int) { self.graph = Array( repeating: Array( repeating: false, count: numVertices ), count: numVertices ) } func addEdge(u: Int, v: Int) { graph[u][v] = true graph[v][u] = true } } The addEdge method takes u and v vertices and adds an edge between them by setting the corresponding cells to true. There are two cells in the matrix for each pair of vertices. For example, (0, 1) corresponds to these cells:\n0 1 2 3 4 0 false true false false false 1 true false false false false 2 false false false false false 3 false false false false false 4 false false false false false Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-graph/","summary":"What is a graph? A graph is an abstract data type that represents vertices and edges that connect those vertices.\nSource\nImplementation A graph can be represented as a matrix with edges connecting each pair of vertices. For example, a graph with vertices 0, 1, 2, 3, 4 and edges between them can be represented as a matrix:\n0 1 2 3 4 0 false true false false true 1 true false true true true 2 false true false true false 3 false true true false true 4 true true false true false In Swift, you can use a list of lists (2D array) to represent the matrix:","title":"DSA - Graph"},{"content":"What is Breadth First Search? Breadth-first search (BFS) is an algorithm for traversing tree or graph data structures. It starts at the root and explores all the neighboring nodes at the current depth before moving on to nodes at the next depth level.\nSource\nImplementation The implementation of BFS may vary depending on the problem. The main idea of BFS is:\nIt has a visited array that collects all elements that have already been visited. It has a queue with all elements it\u0026rsquo;s going to visit. It loops through the queue, removes the first element, and appends it to the visited list. Finally, it loops through all the neighbors and appends the neighbor to the queue if it has not been visited and is not already in the queue. Code Example func bfs(_ value: String) -\u0026gt; [String] { let graph: [String: [String]] = [ \u0026#34;New York\u0026#34;: [\u0026#34;Buenos Aires\u0026#34;, \u0026#34;Cairo\u0026#34;, \u0026#34;Tokyo\u0026#34;, \u0026#34;London\u0026#34;] ] var visited: [String] = [] var queue: [String] = [] queue.append(value) while !queue.isEmpty { let tmp = queue.removeFirst() visited.append(tmp) if let neighbors = graph[tmp] { for neighbor in neighbors.sorted() { if !visited.contains(neighbor) \u0026amp;\u0026amp; !queue.contains(neighbor) { queue.append(neighbor) } } } } return visited } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-breadth-first-search/","summary":"What is Breadth First Search? Breadth-first search (BFS) is an algorithm for traversing tree or graph data structures. It starts at the root and explores all the neighboring nodes at the current depth before moving on to nodes at the next depth level.\nSource\nImplementation The implementation of BFS may vary depending on the problem. The main idea of BFS is:\nIt has a visited array that collects all elements that have already been visited.","title":"DSA - Breadth First Search"},{"content":"What is Backtracking? Backtracking is a class of algorithms for finding solutions to complex problems. A backtracking algorithm uses recursion and is based on depth-first search (DFS).\nDepth First Search (DFS) Depth First Search (DFS) is an essential part of backtracking. DFS is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (or an arbitrary node in the case of a graph) and explores as far as possible along each branch before backtracking.\nCode Example The implementation of the DFS algorithm for a graph looks like this:\nfunc dfs(_ r: Int, _ c: Int, _ visited: inout [[Int]]) { guard r \u0026gt;= 0, r \u0026lt; visited.count, c \u0026gt;= 0, c \u0026lt; visited[0].count, visited[r][c] == 0 else { return } visited[r][c] = 1 dfs(r - 1, c, \u0026amp;visited) dfs(r + 1, c, \u0026amp;visited) dfs(r, c - 1, \u0026amp;visited) dfs(r, c + 1, \u0026amp;visited) } It can vary depending on the problem, but the main idea is that it first checks if the r and c parameters are within bounds and if the value has not been visited before. After that, it recursively walks between the top, bottom, left, and right neighboring cells.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-backtracking/","summary":"What is Backtracking? Backtracking is a class of algorithms for finding solutions to complex problems. A backtracking algorithm uses recursion and is based on depth-first search (DFS).\nDepth First Search (DFS) Depth First Search (DFS) is an essential part of backtracking. DFS is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (or an arbitrary node in the case of a graph) and explores as far as possible along each branch before backtracking.","title":"DSA - Backtracking"},{"content":"What is a Trie? A Trie is a data structure usually called a \u0026ldquo;prefix tree,\u0026rdquo; often represented as a nested tree of dictionaries where each key is a character that maps to the next character in a word.\nLet\u0026rsquo;s look at some examples of a Trie. The Trie consists of two main classes: the TrieNode class and the Trie class.\nTrieNode The TrieNode class has two properties:\nchildren - a property that represents all characters in a given word and points to the next character. isEndSymbol - a property that indicates the end of the word in a given sequence of characters. final class TrieNode { var children: [Character: TrieNode?] var isEndSymbol: Bool init() { self.children = [:] self.isEndSymbol = false } } Trie The Trie class has two main operations, insert and exists, and a root property that stores all possible combinations of words.\nfinal class Trie { var root: TrieNode init() { self.root = TrieNode() } } Insert extension Trie { func insert(_ word: String) { var current = self.root for c in word { if current.children[c] == nil { let newNode = TrieNode() current.children[c] = newNode current = newNode } else { current = current.children[c]!! } } current.isEndSymbol = true } } The insert operation loops through all the characters of word and checks if the character exists in the current node:\nIf it does not exist, it creates a newNode, sets it in the current.children node, and updates the current node. If it does exist, it updates the current node with the children node containing that character. Exists extension Trie { func exists(_ word: String) -\u0026gt; Bool { var current = self.root for c in word { if current.children[c] == nil { return false } else { current = current.children[c]!! } } return current.isEndSymbol } } The exists operation loops over all the characters in the input word and checks if the current node contains the character:\nIf the current node does not have the character, it returns false. If the current node does have the character, it updates the current node with the node containing that character. When the loop completes, it returns the result based on whether the current node\u0026rsquo;s isEndSymbol is true. Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-trie/","summary":"What is a Trie? A Trie is a data structure usually called a \u0026ldquo;prefix tree,\u0026rdquo; often represented as a nested tree of dictionaries where each key is a character that maps to the next character in a word.\nLet\u0026rsquo;s look at some examples of a Trie. The Trie consists of two main classes: the TrieNode class and the Trie class.\nTrieNode The TrieNode class has two properties:\nchildren - a property that represents all characters in a given word and points to the next character.","title":"DSA - Trie"},{"content":"What is a Tree? A Tree is a data structure that has a root and subtrees of children, representing a set of linked nodes. Trees behave similarly to a LinkedList in that they have a collection of nodes starting with a head (root). The main difference is that Trees can have multiple children, whereas a LinkedList, on the other hand, can have only one next child.\nI‚Äôm going to focus on a commonly used type of tree, the Binary Search Tree.\nBinary Search Tree A Binary Search Tree (BST) is also called an ordered tree. A BST has two children, left and right. The left child value is always less than its parent value, and the right child value is always greater than its parent value. Duplicate values are not allowed. These constraints help to add, remove, and find nodes very quickly (on average O(log n), worst case O(n)).\nCode Example final class BSTNode { let val: Int var left: BSTNode? var right: BSTNode? init( val: Int, left: BSTNode? = nil, right: BSTNode? = nil ) { self.val = val self.left = left self.right = right } } BST - Insert Let‚Äôs look at how binary search tree insertion works:\nOne of the BST constraints is that duplicate values are not allowed, so we need to check for duplicates before adding any logic. The next step is to check if the inserting value is less than self.val and recursively insert this value into the left child node, or create a new left child node if it does not exist. The final step is to recursively insert the value into the right child if it exists, or create a new node. func insert(_ val: Int) { if self.val == val { return } if val \u0026lt; self.val { if self.left != nil { self.left!.insert(val) return } else { self.left = BSTNode(val: val) return } } if self.right != nil { self.right!.insert(val) return } self.right = BSTNode(val: val) } BST - Delete Let\u0026rsquo;s look at another operation, delete, which is slightly more complicated than insert:\nThe first step is to compare the value the user is trying to delete with self.val. If it is less and the left child exists, then delete the value from left recursively and update left. The second step is the opposite of the previous step but for the right child. The third and fourth steps are base cases, where we need to check if right and left children exist. If the right child does not exist, return the left child, and vice versa for the left child. The final step is to find the minLargerNode, update the value, and replace the right child with this node. func delete(_ val: Int) -\u0026gt; BSTNode? { if val \u0026lt; self.val { if self.left != nil { self.left = self.left!.delete(val) } return self } if val \u0026gt; self.val { if self.right != nil { self.right = self.right!.delete(val) } return self } if self.right == nil { return self.left } if self.left == nil { return self.right } var minLargerNode = self.right while minLargerNode?.left != nil { minLargerNode = minLargerNode!.left } self.val = minLargerNode!.val self.right = self.right?.delete(minLargerNode!.val) return self } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-binary-search-tree/","summary":"What is a Tree? A Tree is a data structure that has a root and subtrees of children, representing a set of linked nodes. Trees behave similarly to a LinkedList in that they have a collection of nodes starting with a head (root). The main difference is that Trees can have multiple children, whereas a LinkedList, on the other hand, can have only one next child.\nI‚Äôm going to focus on a commonly used type of tree, the Binary Search Tree.","title":"DSA - Binary Search Tree"},{"content":"What is the sliding window technique? The sliding window technique is a common algorithmic approach used to create a fixed-sized window that moves through the data one step at a time, typically from left to right, to perform specific operations or computations on the elements within the window.\nWhat is the sliding window algorithm? The sliding window algorithm is a method for finding a subset of elements that satisfy certain conditions in a given problem.\nHow does the sliding window algorithm work? Let‚Äôs look at the \u0026ldquo;maximum sum of a subarray\u0026rdquo; problem to better understand how it works:\nProblem: Given an array of integers, find the maximum sum of a subarray with a fixed window size.\nIn this case, the sliding window algorithm uses a fixed size window that the user can pass to a function as a parameter. It iterates through all the elements inside that window by accessing the current value(nums[i]) and previous value(nums[i - k]) and calculates the window sum, which is needed to determine the max sum result.\nCode Example func maxSubArraySum(_ nums: [Int], _ k: Int) -\u0026gt; Int { var maxSum = Int.min var windowSum = nums[0 ..\u0026lt; k].reduce(0, +) for i in k ..\u0026lt; nums.count { windowSum += nums[i] - nums[i - k] maxSum = max(maxSum, windowSum) } return maxSum } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-sliding-window/","summary":"What is the sliding window technique? The sliding window technique is a common algorithmic approach used to create a fixed-sized window that moves through the data one step at a time, typically from left to right, to perform specific operations or computations on the elements within the window.\nWhat is the sliding window algorithm? The sliding window algorithm is a method for finding a subset of elements that satisfy certain conditions in a given problem.","title":"DSA - Sliding Window"},{"content":"What is a Linked List? A linked list is a common data structure that is similar to an array, but its order is based on pointers to the next element in memory instead of using physical placement (indices).\nA linked list has two main components:\nListNode class: This class has a val property that represents the value and a next property that represents a pointer to the next element in memory. LinkedList class: This class stores a collection of ListNode elements and provides operations like add to tail and add to head. The add to tail operation takes O(n) time because it needs to iterate through the list to find the last element. The add to head operation takes O(1) time because it only needs to set the next pointer of the new node to the current head and update the head with the new node. Where can it be used? A linked list can be used in stacks, queues, and lists.\nCode Example final class ListNode { let val: Int var next: ListNode? init(val: Int, next: ListNode? = nil) { self.val = val self.next = next } } final class LinkedList { private(set) var head: ListNode? init(head: ListNode? = nil) { self.head = head } func addToTail(_ newNode: ListNode?) { if self.head == nil { self.head = newNode return } var node: ListNode? = self.head while node?.next != nil { node = node!.next } node?.next = newNode } func addToHead(_ newNode: ListNode?) { newNode?.next = self.head self.head = newNode } } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-linked-list/","summary":"What is a Linked List? A linked list is a common data structure that is similar to an array, but its order is based on pointers to the next element in memory instead of using physical placement (indices).\nA linked list has two main components:\nListNode class: This class has a val property that represents the value and a next property that represents a pointer to the next element in memory.","title":"DSA - Linked List"},{"content":"What is binary search? Binary search is an algorithm that helps find an element in a sorted array in O(log n) time.\nWhy should the input be sorted before performing binary search? The input array for binary search needs to be sorted because the algorithm eliminates half of the choices at each step. If the guessed value is greater than the target value, it knows that the right part can‚Äôt contain the target value.\nHow does binary search work? It uses the two pointers technique, which helps divide the input into two halves with each iteration, compares the middle array element with the target value, and shifts the pointers based on which half contains the target value.\nCode Example func binarySearch(_ arr: [Int], _ target: Int) -\u0026gt; Int? { var l: Int = 0 var r: Int = arr.count - 1 while l \u0026lt;= r { let m = (l + r) / 2 if arr[m] \u0026lt; target { l = m + 1 } else if arr[m] \u0026gt; target { r = m - 1 } else { return m } } return nil } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-binary-search/","summary":"What is binary search? Binary search is an algorithm that helps find an element in a sorted array in O(log n) time.\nWhy should the input be sorted before performing binary search? The input array for binary search needs to be sorted because the algorithm eliminates half of the choices at each step. If the guessed value is greater than the target value, it knows that the right part can‚Äôt contain the target value.","title":"DSA - Binary Search"},{"content":"What is a Stack? A stack is an abstract data type that serves as a collection of elements and implements operations like push, pop, and peek at the end in O(1) time. It uses the LIFO (last in, first out) order. For example, a stack can be a collection of items where adding or removing is practical at the top.\nCode Example struct Stack\u0026lt;Element\u0026gt; { private var array: [Element] init(array: [Element] = []) { self.array = array } mutating func push(_ element: Element) { array.append(element) } mutating func pop() -\u0026gt; Element? { if array.isEmpty { return nil } return array.popLast() } func peek() -\u0026gt; Element? { if array.isEmpty { return nil } return array.last } } Practical Applications of Stacks You can observe stack-like behavior in many places, such as redo-undo features in text editors, Photoshop, and the forward and backward navigation features in web browsers.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-stack/","summary":"What is a Stack? A stack is an abstract data type that serves as a collection of elements and implements operations like push, pop, and peek at the end in O(1) time. It uses the LIFO (last in, first out) order. For example, a stack can be a collection of items where adding or removing is practical at the top.\nCode Example struct Stack\u0026lt;Element\u0026gt; { private var array: [Element] init(array: [Element] = []) { self.","title":"DSA - Stack"},{"content":"What is the Two Pointers Technique? The two pointers technique helps track indices in a collection of elements to access objects in memory by index with O(1) space. This technique is very handy when you need to optimize the time and space of a solution.\nWhat Problems Does It Solve? The two pointers technique solves problems involving collections. For example, it is useful when you need to compare each element to other elements in that collection.\nWhat Are the Ways to Use It? The first way to use the two pointers technique is to set the left pointer at the beginning of the array and the right pointer at the end, then increment the left and decrement the right pointer until they meet.\nwhile l \u0026lt; r { l += 1 r -= 1 } The second way is to use slow and fast pointers for cycle detection in a LinkedList. It is called fast and slow because the fast pointer moves twice as fast as the slow pointer.\nclass Node { var val: Int var next: Node? init(val: Int, next: Node? = nil) { self.val = val self.next = next } } func hasCycle(_ head: Node?) -\u0026gt; Bool { var fast = head var slow = head while fast != nil \u0026amp;\u0026amp; fast?.next != nil { fast = fast?.next?.next slow = slow?.next if fast == slow { return true } } return false } Problem As an example, let\u0026rsquo;s look at the Two Sum II - Input Array Is Sorted problem.\nGiven a¬†1-indexed¬†array of integers¬†numbers¬†that is already¬†sorted in non-decreasing order, find two numbers such that they add up to a specific¬†target¬†number. Let these two numbers be¬†numbers[index1]¬†and¬†numbers[index2]¬†where¬†1 \u0026lt;= index1 \u0026lt; index2 \u0026lt;= numbers.length. Return¬†the indices of the two numbers,¬†index1¬†and¬†index2,¬†added by one,¬†as an integer array¬†[index1, index2]¬†of length 2. The tests are generated such that there is¬†exactly one solution. You¬†may not¬†use the same element twice. Your solution must use only constant extra space.\nSolution Let\u0026rsquo;s look at the solution to the Two Sum II - Input Array Is Sorted problem that uses the two pointers technique, where the left pointer is initialized with the first index in the array and the right pointer is initialized with the last index.\nclass Solution { func twoSum(_ numbers: [Int], _ target: Int) -\u0026gt; [Int] { var l: Int = 0 var r: Int = numbers.count - 1 while l \u0026lt; r { if numbers[l] + numbers[r] \u0026lt; target { l += 1 } else if numbers[l] + numbers[r] \u0026gt; target { r -= 1 } else { return [l+1,r+1] } } return [] } } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-two-pointers-technique/","summary":"What is the Two Pointers Technique? The two pointers technique helps track indices in a collection of elements to access objects in memory by index with O(1) space. This technique is very handy when you need to optimize the time and space of a solution.\nWhat Problems Does It Solve? The two pointers technique solves problems involving collections. For example, it is useful when you need to compare each element to other elements in that collection.","title":"DSA - Two Pointers Technique"},{"content":"Introduction In the previous chapter, we discussed Data Structures and Algorithms, delved into an overview of Dynamic Arrays, and solved the \u0026ldquo;Remove Element\u0026rdquo; problem.\nIn this article, I\u0026rsquo;m going to show one of the ways to solve the 88. Merge Sorted Array problem.\nProblem You are given two integer arrays,¬†nums1¬†and¬†nums2, sorted in¬†non-decreasing order, and two integers,¬†m¬†and¬†n, representing the number of elements in¬†nums1¬†and¬†nums2, respectively. Merge¬†nums1¬†and¬†nums2¬†into a single array sorted in¬†non-decreasing order. The final sorted array should not be returned by the function but should instead be¬†stored inside the array¬†nums1. To accommodate this,¬†nums1¬†has a length of¬†m + n, where the first¬†m¬†elements denote the elements that should be merged, and the last¬†n¬†elements are set to¬†0¬†and should be ignored.¬†nums2¬†has a length of¬†n.\nSolution class Solution { func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) { if m == 0 { nums1 = nums2 } else if n == 0 { let tmp = nums1 nums1 = tmp } else { var num1result: [Int] = [] for i in 0 ..\u0026lt; m { num1result.append(nums1[i]) } var num2result: [Int] = [] for i in 0 ..\u0026lt; n { num2result.append(nums2[i]) } var result = num1result + num2result result.sort() nums1 = result } } } Approach The brute-force way to solve this problem is to check the lengths of m and n, and if it\u0026rsquo;s 0, assign a copy of nums2 or nums1 appropriately. In case m and n are not equal to 0, create additional arrays and loop through nums1 and nums2, taking into account the number of elements in the m and n properties.\nTime Complexity: O(logn) because it uses the underlying sort method. Space Complexity: O(m+n) because it uses additional arrays for num1 and num2 results. Optimized Approach I found a more optimal solution that uses Time Complexity: O(m + n), Space Complexity: O(1), and a three-pointer technique. In this solution, the i pointer reads values from nums1, the j pointer reads values from nums2, and the w pointer writes values to nums1. Loop backward through the sum of m + n elements and update the nums1 values. Decrement the i pointer if i is greater than or equal to 0 and the value of nums1[i] is greater than nums2[j]. If not, update the value in nums1 and decrement the j pointer.\nclass Solution { func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) { var i = m - 1 var j = n - 1 for w in stride(from:n+m-1, through:0, by:-1) { if j \u0026lt; 0 { break } if i \u0026gt;= 0 \u0026amp;\u0026amp; nums1[i] \u0026gt; nums2[j] { nums1[w] = nums1[i] i -= 1 } else { nums1[w] = nums2[j] j -= 1 } } } } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/dsa-merge-sorted-array-problem/","summary":"Introduction In the previous chapter, we discussed Data Structures and Algorithms, delved into an overview of Dynamic Arrays, and solved the \u0026ldquo;Remove Element\u0026rdquo; problem.\nIn this article, I\u0026rsquo;m going to show one of the ways to solve the 88. Merge Sorted Array problem.\nProblem You are given two integer arrays,¬†nums1¬†and¬†nums2, sorted in¬†non-decreasing order, and two integers,¬†m¬†and¬†n, representing the number of elements in¬†nums1¬†and¬†nums2, respectively.","title":"DSA - Merge Sorted Array Problem"},{"content":"Introduction I‚Äôve always been curious about data structures and algorithms, and how they can improve user experiences while saving money for businesses through optimized computations.\nIn this series of articles, I‚Äôm going to solve LeetCode problems and share my approach with you.\nI‚Äôve just started my journey in solving LeetCode problems, so my solutions might not be as efficient as they could be, but I‚Äôm always looking for improvement.\nBefore each topic, I‚Äôll provide a brief introduction to the data structure, algorithm, or technique I‚Äôll be using to solve a specific problem.\nData Structure Let‚Äôs actually find out what a data structure is.\nA data structure is a way of organizing and storing data that is chosen for efficient access and modification. A data structure is a collection of data values and the relationships among them.\nAlgorithm An algorithm is a finite set of instructions that helps solve a specific problem. A real-world example could be a cooking recipe or the steps to prepare coffee with a coffee machine.\nArrays In the Swift programming language, arrays are dynamic by default. A dynamic array is a commonly used data structure that consists of a collection of elements of the same memory size, with each element identified by an index or key. You can access, remove, and add new elements to the tail by index in O(1) time.\nTime Complexity Peak Index Insert or Delete from Beginning Insert or Delete from End Insert or Delete from Middle O(1) O(n) O(1) O(n) Resizing a Dynamic Array A dynamic array increases its underlying capacity and resizes to double its size only when the array size equals its capacity, to avoid the expensive cost of resizing frequently.\nProblem 27. Remove Element. Given an integer array¬†nums¬†and an integer¬†val, remove all occurrences of¬†val¬†in¬†nums¬†in-place. The order of the elements may be changed. Then return¬†the number of elements in¬†nums¬†which are not equal to¬†val. Consider the number of elements in¬†nums¬†which are not equal to¬†val¬†be¬†k, to get accepted, you need to do the following things:\nChange the array¬†nums¬†such that the first¬†k¬†elements of¬†nums¬†contain the elements which are not equal to¬†val. The remaining elements of¬†nums¬†are not important as well as the size of¬†nums. Return¬†k. Solution class Solution { func removeElement(_ nums: inout [Int], _ val: Int) -\u0026gt; Int { var i = 0 while i \u0026lt; nums.count { if nums[i] == val { nums.remove(at: i) } else { i += 1 } } return nums.count } } Approach to Solving Problems One brute-force way to solve this problem is to loop through all values and check if a number is equal to a value. If it is, then remove the element with this index from the array; if not, increment the index.\nTime Complexity: O(n) because the value can be at the end of the array, requiring a loop through all values.\nSpace Complexity: O(1) because no additional space is required; all occurrences of the value are removed in-place.\nResources I‚Äôm very grateful for the NeetCode roadmap and in-depth algorithm explanations. I‚Äôve learned a lot about new techniques and ways to solve problems more efficiently. I recommend checking out the NeetCode site and YouTube channel.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/data-structures-and-algorithms-arrays-swift/","summary":"Introduction I‚Äôve always been curious about data structures and algorithms, and how they can improve user experiences while saving money for businesses through optimized computations.\nIn this series of articles, I‚Äôm going to solve LeetCode problems and share my approach with you.\nI‚Äôve just started my journey in solving LeetCode problems, so my solutions might not be as efficient as they could be, but I‚Äôm always looking for improvement.\nBefore each topic, I‚Äôll provide a brief introduction to the data structure, algorithm, or technique I‚Äôll be using to solve a specific problem.","title":"Data Structures and Algorithms Arrays Swift"},{"content":"Introduction A well-performing application is the heart of a good user experience. If an application responds well, it helps attract more users and grow the business around it. On the other hand, if it performs poorly, it frustrates users and leads them to uninstall the app. To solve these issues, we need tools to monitor app behavior. Luckily for us, Xcode provides a list of tools that will help us resolve these problems.\nCommon Problems If I could generalize common problems that every iOS developer deals with while working on a multi-user app, it would be:\nUnresponsiveness and hangs Memory issues Power-consumption issues I/O issues Network-related issues Slow app launch time Ways to Address Common Problems If you want to improve any of these categories, Apple provides developers multiple ways to do it:\nThe first way is to use Xcode Organizer to view metrics for launch time, memory usage, energy consumption, etc. The second way is to collect health information about your app using MetricKit. The third way is to get feedback from TestFlight testers about their experience using the beta version of your app. The fourth way is to get feedback from real users through email or an interface inside your app. Tools That Can Help Solve Problems If you have Unresponsiveness and hangs, you can use the Time Profiler tool to find what causes the problem.\nFor Memory issues, you can use Allocations and Leaks. For Power-consumption issues, you can use the Energy Log tool. For I/O issues, you can use the File Activity tool. For Network-related issues, you can use the Network Template tool. Resources If you want more detailed information about optimizing app performance, I recommend reading the official Apple documentation. It describes techniques in depth and has a lot of related resources and recommendations.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/optimizing-ios-app-performance-common-techniques/","summary":"Introduction A well-performing application is the heart of a good user experience. If an application responds well, it helps attract more users and grow the business around it. On the other hand, if it performs poorly, it frustrates users and leads them to uninstall the app. To solve these issues, we need tools to monitor app behavior. Luckily for us, Xcode provides a list of tools that will help us resolve these problems.","title":"Optimizing iOS App Performance - Common Techniques"},{"content":"Introduction Previously, I worked with a healthcare app that used the HealthKit framework, but I did not get the opportunity to implement it myself. I decided to look into it and share what I found. In this article, I will focus on the steps to integrate HealthKit, write, and access its data.\nPreparation Before we dive into implementation, I assume that you have an active Apple Developer account; without it, you will not be able to access the HealthKit Store. Let‚Äôs add:\nHealthKit Capability to the project Privacy permission Privacy ‚Äì Health Share Usage Description, Privacy ‚Äì Health Update Usage Description keys to Info.plist. Implementation First Step The first step is to call the isHealthDataAvailable method and make sure that it is available.\nguard HKHealthStore.isHealthDataAvailable() else { throw HealthkitSetupError.notAvailableOnDevice } Data Type Preparation Next, you need to prepare the data types that you will be reading and writing from the HealthKit central repository.\nguard let height = HKObjectType.quantityType(forIdentifier: .height), let bodyMass = HKObjectType.quantityType(forIdentifier: .bodyMass), let activeEnergyBurned = HKObjectType.quantityType(forIdentifier: .activeEnergyBurned) else { throw HealthkitSetupError.dataTypeNotAvailable } let typesToWrite: Set\u0026lt;HKSampleType\u0026gt; = [height, bodyMass, HKObjectType.workoutType()] let typesToRead: Set\u0026lt;HKObjectType\u0026gt; = [height, bodyMass, activeEnergyBurned, HKObjectType.workoutType()] Request Authorization Next, you need to request authorization with the data types that you defined above.\ntry await HKHealthStore().requestAuthorization(toShare: typesToWrite, read: typesToRead) import Inject import SwiftUI public struct ContentView: View { @ObserveInjection var inject @State var healthKitService: HealthKitService = .init() public init() {} public var body: some View { VStack {}.onAppear { Task { do { try await healthKitService.requestAuthorization() print(\u0026#34;HealthKit authorization request success\u0026#34;) } catch { print(\u0026#34;HealthKit authorization request failed error: \\(error)\u0026#34;) } } } .enableInjection() } } Reading/Saving Data Reading Data When you need to read/save data using HealthKit, you can do it by applying the HKHealthStore object.\n\u0026#x1f4a1; HKHealthStore - The access point for all data managed by HealthKit.\nAs an example, you can read characteristic data by utilizing HKHealthStore-defined methods such as biologicalSex, bloodType, dateOfBirthComponents, etc.\nfunc getProfileData() throws -\u0026gt; ProfileData { let healthStore = HKHealthStore() let dateOfBirthComponents = try healthStore.dateOfBirthComponents() let today = Date() let calendar = Calendar.current let todayDateComponents = calendar.dateComponents([.year], from: today) let thisYear = todayDateComponents.year! let age = thisYear - dateOfBirthComponents.year! let biologicalSex = try healthStore.biologicalSex() let bloodType = try healthStore.bloodType() let profileData = ProfileData(age: age, biologicalSex: biologicalSex.biologicalSex, bloodType: bloodType.bloodType) return profileData } struct ProfileData { var age: Int? var biologicalSex: HKBiologicalSex? var bloodType: HKBloodType? } Saving Data In the case of saving data, you need to specify the quantity type, quantity, and create a sample.\nfunc saveHeight(height: Double, date: Date) async throws { let quantityType = HKQuantityType.quantityType(forIdentifier: .height)! let quantity = HKQuantity(unit: .meter(), doubleValue: height) let sample = HKQuantitySample(type: quantityType, quantity: quantity, start: date, end: date) try await HKHealthStore().save(sample) } \u0026#x1f4a1; HKQuantityType - A type that identifies samples that store numerical values.\n\u0026#x1f4a1; HKQuantity - An object that stores a value for a given unit.\n\u0026#x1f4a1; HKQuantitySample - A sample that represents a quantity, including the value and the units.\nComplete Example import HealthKit enum HealthkitSetupError: Error { case notAvailableOnDevice case dataTypeNotAvailable } final class HealthKitService { func requestAuthorization() async throws { guard HKHealthStore.isHealthDataAvailable() else { throw HealthkitSetupError.notAvailableOnDevice } guard let height = HKObjectType.quantityType(forIdentifier: .height), let bodyMass = HKObjectType.quantityType(forIdentifier: .bodyMass), let activeEnergyBurned = HKObjectType.quantityType(forIdentifier: .activeEnergyBurned), let dateOfBirth = HKObjectType.characteristicType(forIdentifier: .dateOfBirth), let bloodType = HKObjectType.characteristicType(forIdentifier: .bloodType), let biologicalSex = HKObjectType.characteristicType(forIdentifier: .biologicalSex) else { throw HealthkitSetupError.dataTypeNotAvailable } let typesToWrite: Set\u0026lt;HKSampleType\u0026gt; = [height, bodyMass, HKObjectType.workoutType()] let typesToRead: Set\u0026lt;HKObjectType\u0026gt; = [height, bodyMass, activeEnergyBurned, HKObjectType.workoutType(), dateOfBirth, bloodType, biologicalSex] try await HKHealthStore().requestAuthorization(toShare: typesToWrite, read: typesToRead) } func getProfileData() throws -\u0026gt; ProfileData { let healthStore = HKHealthStore() let dateOfBirthComponents = try healthStore.dateOfBirthComponents() let today = Date() let calendar = Calendar.current let todayDateComponents = calendar.dateComponents([.year], from: today) let thisYear = todayDateComponents.year! let age = thisYear - dateOfBirthComponents.year! let biologicalSex = try healthStore.biologicalSex() let bloodType = try healthStore.bloodType() let profileData = ProfileData(age: age, biologicalSex: biologicalSex.biologicalSex, bloodType: bloodType.bloodType) return profileData } func saveHeight(height: Double, date: Date) async throws { let quantityType = HKQuantityType.quantityType(forIdentifier: .height)! let quantity = HKQuantity(unit: .meter(), doubleValue: height) let sample = HKQuantitySample(type: quantityType, quantity: quantity, start: date, end: date) try await HKHealthStore().save(sample) } } struct ProfileData { var age: Int? var biologicalSex: HKBiologicalSex? var bloodType: HKBloodType? } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/implementing-healthkit-in-an-ios-app/","summary":"Introduction Previously, I worked with a healthcare app that used the HealthKit framework, but I did not get the opportunity to implement it myself. I decided to look into it and share what I found. In this article, I will focus on the steps to integrate HealthKit, write, and access its data.\nPreparation Before we dive into implementation, I assume that you have an active Apple Developer account; without it, you will not be able to access the HealthKit Store.","title":"Implementing HealthKit in an iOS App"},{"content":"Introduction Nowadays, location is an essential feature in almost every application. It\u0026rsquo;s very important to know the best ways to implement it without affecting performance and user experience. In this article, I will focus on how to implement general methods in location service.\nPreparation Before we begin, let\u0026rsquo;s add location permission keys to Info.plist:\nPrivacy - Location When In Use Usage Description Privacy - Location Always and When In Use Usage Description First Step The first step is to create LocationService with the requestPermissions method to be able to receive location events.\nprivate let locationManager: CLLocationManager override init() { self.locationManager = CLLocationManager() super.init() requestPermissions() } func requestPermissions() { locationManager.requestWhenInUseAuthorization() } üí° Use requestWhenInUseAuthorization only if you need location updates when the user is using your app.\nSecond Step The second step is to add locationManager.delegate to be able to handle location updates or errors.\n// MARK: - CLLocationManagerDelegate extension LocationService: CLLocationManagerDelegate { func locationManager( _ manager: CLLocationManager, didUpdateLocations locations: [CLLocation] ) { guard let location = locations.first else { return } let latitude = location.coordinate.latitude let longitude = location.coordinate.longitude print(\u0026#34;Location: \\(latitude), \\(longitude)\u0026#34;) } func locationManager( _ manager: CLLocationManager, didFailWithError error: Error ) { print(\u0026#34;Error: \\(error)\u0026#34;) } } üí° CLLocationManager - The object you use to start and stop the delivery of location-related events to your app.\nüí° CLLocationManagerDelegate - The methods you use to receive events from an associated location-manager object.\nAuthorization Status Sometimes you need to know about authorization status and create logic around it. In this case, you can check the status by using the authorizationStatus property.\nfunc authorizationStatus() { switch locationManager.authorizationStatus { case .notDetermined: print(\u0026#34;Not determined\u0026#34;) case .restricted: print(\u0026#34;Restricted\u0026#34;) case .denied: print(\u0026#34;Denied\u0026#34;) case .authorizedAlways: print(\u0026#34;Authorized always\u0026#34;) case .authorizedWhenInUse: print(\u0026#34;Authorized when in use\u0026#34;) @unknown default: print(\u0026#34;Unknown\u0026#34;) } } One-Time Location Update In case you want to ask the user for location only once, you can call the locationManager.requestLocation() method.\nfunc requestLocationOnce() { locationManager.requestLocation() } Real-Time Location Updates In case you need to get real-time location updates, you can use the startUpdatingLocation and stopUpdatingLocation methods.\nfunc requestRealTimeLocationUpdates() { locationManager.startUpdatingLocation() DispatchQueue.main.asyncAfter(deadline: .now() + 10) { self.locationManager.stopUpdatingLocation() } } ‚ö†Ô∏è Do not forget to call the stopUpdatingLocation method, as it can cause performance issues.\nComplete Example import CoreLocation final class LocationService: NSObject { private let locationManager: CLLocationManager override init() { locationManager = CLLocationManager() super.init() locationManager.delegate = self requestPermissions() } func requestPermissions() { locationManager.requestWhenInUseAuthorization() } func requestLocationOnce() { locationManager.requestLocation() } func requestRealTimeULocationUpdates() { locationManager.startUpdatingLocation() DispatchQueue.main.asyncAfter(deadline: .now() + 10) { self.locationManager.stopUpdatingLocation() } } func authorizationStatus() { switch locationManager.authorizationStatus { case .notDetermined: print(\u0026#34;Not determined\u0026#34;) case .restricted: print(\u0026#34;Restricted\u0026#34;) case .denied: print(\u0026#34;Denied\u0026#34;) case .authorizedAlways: print(\u0026#34;Authorized always\u0026#34;) case .authorizedWhenInUse: print(\u0026#34;Authorized when in use\u0026#34;) @unknown default: print(\u0026#34;Unknown\u0026#34;) } } } // MARK: - CLLocationManagerDelegate extension LocationService: CLLocationManagerDelegate { func locationManager( _: CLLocationManager, didUpdateLocations locations: [CLLocation] ) { guard let location = locations.first else { return } let lattitude = location.coordinate.latitude let longitude = location.coordinate.longitude print(\u0026#34;Location: \\(lattitude), \\(longitude)\u0026#34;) } func locationManager( _: CLLocationManager, didFailWithError error: Error ) { print(\u0026#34;Error: \\(error)\u0026#34;) } } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/implementing-location-service/","summary":"Introduction Nowadays, location is an essential feature in almost every application. It\u0026rsquo;s very important to know the best ways to implement it without affecting performance and user experience. In this article, I will focus on how to implement general methods in location service.\nPreparation Before we begin, let\u0026rsquo;s add location permission keys to Info.plist:\nPrivacy - Location When In Use Usage Description Privacy - Location Always and When In Use Usage Description First Step The first step is to create LocationService with the requestPermissions method to be able to receive location events.","title":"Implementing Location Service"},{"content":"Introduction I haven\u0026rsquo;t had the opportunity to build a chatbot before. This topic was trending some time ago, and I always wanted to implement it myself. In this article, I will focus on the steps you need to know to successfully build and run a chatbot application.\nFirst Step The first step is to add the OpenAI dependency to your project:\n.package(url: \u0026#34;https://github.com/MacPaw/OpenAI.git\u0026#34;, branch: \u0026#34;main\u0026#34;) dependencies: [ .byNameItem( name: \u0026#34;OpenAI\u0026#34;, condition: .when(platforms: [ .iOS, ]) ), ], Second Step The second step is to generate an OpenAI key and replace it inside your project.\nThird Step The third step is to create ChatGPTService and add the getAssistantResponse method that will be receiving responses from the GPT model:\nimport Foundation import OpenAI final class ChatGPTService { private let client: OpenAI init() { client = OpenAI(apiToken: \u0026#34;YOUR_TOKEN\u0026#34;) } func getAssistantResponse(_ messages: [Message], _ completion: @escaping (Message?) -\u0026gt; Void) { let query = ChatQuery( messages: messages.map { .init(role: .user, content: $0.content)! }, model: .gpt3_5Turbo ) client.chats(query: query) { result in switch result { case let .success(success): guard let choice = success.choices.first, let message = choice.message.content?.string else { completion(nil); return } DispatchQueue.main.async { completion(Message(content: message, isUser: false)) } case let .failure(error): print(error) completion(nil) } } } } Fourth Step The fourth step is to add ChatService that will be responsible for adding, sending messages, and redrawing the UI:\nimport Foundation struct Message: Identifiable { var id: UUID = .init() var content: String var isUser: Bool } final class ChatService: ObservableObject { @Published private(set) var messages: [Message] = [] private let chatGPTService: ChatGPTService = .init() func sendMessage(_ message: Message) { messages.append(message) chatGPTService.getAssistantResponse(messages) { [unowned self] message in if let message = message { messages.append(message) } } } } Fifth Step The fifth step is to connect the UI and ChatService:\nimport SwiftUI struct ChatView: View { @StateObject private var chatService: ChatService = .init() @State private var message: String = \u0026#34;\u0026#34; var body: some View { VStack { ScrollView { ForEach(chatService.messages) { message in Text(message.content) } } HStack { TextField(\u0026#34;Message\u0026#34;, text: $message) Button(\u0026#34;Send\u0026#34;) { chatService.sendMessage(Message(content: message, isUser: true)) } } } } } Caveats Be aware of API quota limits; you can exceed your limits very quickly.\nResources https://www.youtube.com/watch?v=fkg3UzopiHY\u0026ab_channel=JaredDavidson\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/implementing-chatgpt-in-an-ios-app/","summary":"Introduction I haven\u0026rsquo;t had the opportunity to build a chatbot before. This topic was trending some time ago, and I always wanted to implement it myself. In this article, I will focus on the steps you need to know to successfully build and run a chatbot application.\nFirst Step The first step is to add the OpenAI dependency to your project:\n.package(url: \u0026#34;https://github.com/MacPaw/OpenAI.git\u0026#34;, branch: \u0026#34;main\u0026#34;) dependencies: [ .byNameItem( name: \u0026#34;OpenAI\u0026#34;, condition: .","title":"Implementing ChatGPT in an iOS App"},{"content":"Introduction The Apple Sign-In feature is very helpful and offers users login functionality with one click. It could be highly beneficial from a business perspective to attract more potential customers by providing easy and secure access to application functionality. In this article, I will focus on how to implement Apple Sign-In.\nBefore implementation, let‚Äôs set up the necessary options to be able to run the app without errors.\nAdd Sign in with Apple Capability to the project \u0026#x1f4dd; Before testing on the simulator, you need to be signed in to an account with enabled two-factor authentication.\nImplementing Apple Sign-In Apple offers a built-in solution that uses the¬†Authentication Services¬†framework with ASAuthorizationAppleIDButton.\nFirst Step The first step is to set up the Sign-In button.\nfunc setupAppleIDButton() { let authButton = ASAuthorizationAppleIDButton() authButton.frame = CGRect(origin: view.center, size: CGSize(width: 128, height: 56)) authButton.addTarget(self, action: #selector(handleAuthorizationAppleIDButtonPress), for: .touchUpInside) view.addSubview(authButton) } \u0026#x1f4a1; ASAuthorizationAppleIDButton - A control that enables users to initiate the Sign In with Apple flow.\nSecond Step The second step is to handle the authorization Apple ID button press.\n@objc func handleAuthorizationAppleIDButtonPress() { let appleIdProvider = ASAuthorizationAppleIDProvider() let request = appleIdProvider.createRequest() request.requestedScopes = [.fullName, .email] let authorizationController = ASAuthorizationController(authorizationRequests: [request]) authorizationController.delegate = self authorizationController.presentationContextProvider = self authorizationController.performRequests() } \u0026#x1f4a1; ASAuthorizationAppleIDProvider - A mechanism for generating requests to authenticate users based on their Apple ID.\n\u0026#x1f4a1; ASAuthorizationController - A controller that manages authorization requests that a provider creates.\nThird Step The third step is to implement authorizationController.delegate and authorizationController.presentationContextProvider.\n// MARK: - ASAuthorizationControllerDelegate extension LoginViewController: ASAuthorizationControllerDelegate { /// - Tag: did_complete_authorization public func authorizationController(controller _: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) { switch authorization.credential { case let appleIDCredential as ASAuthorizationAppleIDCredential: // Create an account in your system. let userIdentifier = appleIDCredential.user let fullName = appleIDCredential.fullName let email = appleIDCredential.email case let passwordCredential as ASPasswordCredential: // Sign in using an existing iCloud Keychain credential. let username = passwordCredential.user let password = passwordCredential.password default: break } } /// - Tag: did_complete_error public func authorizationController(controller _: ASAuthorizationController, didCompleteWithError error: any Error) { // Handle error. print(error) } } \u0026#x1f4a1; ASAuthorizationControllerDelegate - An interface for providing information about the outcome of an authorization request.\n// MARK: - ASAuthorizationControllerPresentationContextProviding extension LoginViewController: ASAuthorizationControllerPresentationContextProviding { /// - Tag: provide_presentation_anchor public func presentationAnchor(for _: ASAuthorizationController) -\u0026gt; ASPresentationAnchor { view.window! } } \u0026#x1f4a1; ASAuthorizationControllerPresentationContextProviding - An interface the controller uses to ask a delegate for a presentation context.\nResources Implementing User Authentication with Sign In with Apple\nDownload Materials Download\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/implementing-apple-sign-in-to-an-ios-app/","summary":"Introduction The Apple Sign-In feature is very helpful and offers users login functionality with one click. It could be highly beneficial from a business perspective to attract more potential customers by providing easy and secure access to application functionality. In this article, I will focus on how to implement Apple Sign-In.\nBefore implementation, let‚Äôs set up the necessary options to be able to run the app without errors.\nAdd Sign in with Apple Capability to the project \u0026#x1f4dd; Before testing on the simulator, you need to be signed in to an account with enabled two-factor authentication.","title":"Implementing Apple Sign-In to an iOS App"},{"content":"Introduction I\u0026rsquo;ve never had the chance to use this technology before. I\u0026rsquo;ve always wondered how gRPC operates. In this article, I will explore what gRPC is, how to install and use it, and when to use gRPC.\nWhat is gRPC? gRPC is an open-source, high-performance framework that facilitates efficient communication in distributed systems. gRPC is an implementation of the RPC (Remote Procedure Call) protocol, which enables services to call functions on other machines as if they were local software methods. gRPC was developed by Google in 2015, and it includes several features that enhance the way remote procedure calls are made. For instance, its use of Protocol Buffers (Protobuf) supports strongly typed service contracts, data serialization, and code generation in a variety of programming languages. It also uses HTTP/2 as its transport protocol, which facilitates bi-directional streaming and reduces latency.\nInstallation Process Prerequisites Swift Version gRPC requires Swift 5.8 or higher.\nInstall Protocol Buffers Install the protoc compiler that is used to generate gRPC service code. The simplest way to do this is to download pre-compiled binaries for your platform (protoc-\u0026lt;version\u0026gt;-\u0026lt;platform\u0026gt;.zip) from here: https://github.com/google/protobuf/releases.\nUnzip this file. Update the environment variable PATH to include the path to the protoc binary file. Download the Example You\u0026rsquo;ll need a local copy of the example code to work through this quickstart. Download the example code from our GitHub repository (the following command clones the entire repository, but you just need the examples for this quickstart and other tutorials):\n# Clone the repository at the latest release to get the example code (replacing x.y.z with the latest release, for example 1.13.0): git clone -b x.y.z https://github.com/grpc/grpc-swift # Navigate to the repository cd grpc-swift/ Implementation Process Run a gRPC Application From the grpc-swift directory:\nCompile and run the server:\nswift run HelloWorldServer In another terminal, compile and run the client:\nswift run HelloWorldClient Greeter received: Hello stranger! Congratulations! You\u0026rsquo;ve just run a client-server application with gRPC.\nUpdate a gRPC Service Now let\u0026rsquo;s look at how to update the application with an extra method on the server for the client to call. Our gRPC service is defined using protocol buffers; you can find out lots more about how to define a service in a .proto file in What is gRPC?. For now, all you need to know is that both the server and the client \u0026ldquo;stub\u0026rdquo; have a SayHello RPC method that takes a HelloRequest parameter from the client and returns a HelloReply from the server, and that this method is defined like this:\n// The greeting service definition. service Greeter { // Sends a greeting. rpc SayHello (HelloRequest) returns (HelloReply) {} } // The request message containing the user\u0026#39;s name. message HelloRequest { string name = 1; } // The response message containing the greetings. message HelloReply { string message = 1; } Let\u0026rsquo;s update this so that the Greeter service has two methods. Edit Protos/upstream/grpc/examples/helloworld.proto and update it with a new SayHelloAgain method, with the same request and response types:\n// The greeting service definition. service Greeter { // Sends a greeting. rpc SayHello (HelloRequest) returns (HelloReply) {} // Sends another greeting. rpc SayHelloAgain (HelloRequest) returns (HelloReply) {} } // The request message containing the user\u0026#39;s name. message HelloRequest { string name = 1; } // The response message containing the greetings. message HelloReply { string message = 1; } (Don\u0026rsquo;t forget to save the file!)\nUpdate and Run the Application We need to regenerate Sources/Examples/v1/HelloWorld/Model/helloworld.grpc.swift, which contains our generated gRPC client and server classes. From the grpc-swift directory run:\nProtos/generate.sh This also regenerates classes for populating, serializing, and retrieving our request and response types. However, we still need to implement and call the new method in the human-written parts of our example application.\nUpdate the Server In the same directory, open Sources/Examples/v1/HelloWorld/Server/GreeterProvider.swift. Implement the new method like this:\nfinal class GreeterProvider: Helloworld_GreeterAsyncProvider { let interceptors: Helloworld_GreeterServerInterceptorFactoryProtocol? = nil func sayHello( request: Helloworld_HelloRequest, context: GRPCAsyncServerCallContext ) async throws -\u0026gt; Helloworld_HelloReply { let recipient = request.name.isEmpty ? \u0026#34;stranger\u0026#34; : request.name return Helloworld_HelloReply.with { $0.message = \u0026#34;Hello \\(recipient)!\u0026#34; } } func sayHelloAgain( request: Helloworld_HelloRequest, context: GRPCAsyncServerCallContext ) async throws -\u0026gt; Helloworld_HelloReply { let recipient = request.name.isEmpty ? \u0026#34;stranger\u0026#34; : request.name return Helloworld_HelloReply.with { $0.message = \u0026#34;Hello again \\(recipient)!\u0026#34; } } } Update the Client In the same directory, open Sources/Examples/v1/HelloWorld/Client/HelloWorldClient.swift. Call the new method like this:\nfunc run() async throws { // Setup an `EventLoopGroup` for the connection to run on. // // See: https://github.com/apple/swift-nio#eventloops-and-eventloopgroups let group = MultiThreadedEventLoopGroup(numberOfThreads: 1) // Make sure the group is shutdown when we\u0026#39;re done with it. defer { try! group.syncShutdownGracefully() } // Configure the channel, we\u0026#39;re not using TLS so the connection is `insecure`. let channel = try GRPCChannelPool.with( target: .host(\u0026#34;localhost\u0026#34;, port: self.port), transportSecurity: .plaintext, eventLoopGroup: group ) // Close the connection when we\u0026#39;re done with it. defer { try! channel.close().wait() } // Provide the connection to the generated client. let greeter = Helloworld_GreeterAsyncClient(channel: channel) // Form the request with the name, if one was provided. let request = Helloworld_HelloRequest.with { $0.name = self.name ?? \u0026#34;\u0026#34; } do { let greeting = try await greeter.sayHello(request) print(\u0026#34;Greeter received: \\(greeting.message)\u0026#34;) } catch { print(\u0026#34;Greeter failed: \\(error)\u0026#34;) } do { let greetingAgain = try await greeter.sayHelloAgain(request) print(\u0026#34;Greeter received: \\(greetingAgain.message)\u0026#34;) } catch { print(\u0026#34;Greeter failed: \\(error)\u0026#34;) } } Run! Just like we did before, from the top-level grpc-swift directory:\nCompile and run the server:\nswift run HelloWorldServer In another terminal, compile and run the client:\nswift run HelloWorldClient Greeter received: Hello stranger! Greeter received: Hello again stranger! When to Use gRPC gRPC was designed to support highly efficient, language-agnostic communication in distributed systems. It is therefore better suited than REST for microservice-based architectures, in which individual services may be developed in different programming languages and may face varying workloads. Additionally, gRPC‚Äôs use of Protobuf for binary data serialization makes it the better choice for applications that demand low latency and high throughput, while its support for different streaming patterns makes it ideal for real-time chat and video applications.\nResources gRPC vs. REST gRPC Swift Quick Start Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/implementing-grpc-swift/","summary":"Introduction I\u0026rsquo;ve never had the chance to use this technology before. I\u0026rsquo;ve always wondered how gRPC operates. In this article, I will explore what gRPC is, how to install and use it, and when to use gRPC.\nWhat is gRPC? gRPC is an open-source, high-performance framework that facilitates efficient communication in distributed systems. gRPC is an implementation of the RPC (Remote Procedure Call) protocol, which enables services to call functions on other machines as if they were local software methods.","title":"Implementing gRPC Swift"},{"content":"Introduction I never had a chance to work with NFC (Near Field Communication), but I have always been curious to find out how it works. In this article, I will focus on scanning NFC tags using CoreNFC with NFCNDEFReaderSession.\nPreparation Before we begin, let\u0026rsquo;s add the necessary objects:\nNear Field Communication Tag Reading capability to the project. Privacy - NFC Scan Usage Description key to Info.plist. Near Field Communication Tag Reader Session Formats to the entitlements file. First Step The first step before starting scanning is to check if the device supports NFC reading by using the NFCNDEFReaderSession.readingAvailable property.\nguard NFCNDEFReaderSession.readingAvailable else { let alertController = UIAlertController( title: \u0026#34;Scanning Not Supported\u0026#34;, message: \u0026#34;This device doesn\u0026#39;t support tag scanning.\u0026#34;, preferredStyle: .alert ) alertController.addAction(UIAlertAction(title: \u0026#34;OK\u0026#34;, style: .default, handler: nil)) self.present(alertController, animated: true, completion: nil) return } Second Step The second step is to create an NFCNDEFReaderSession object by calling the¬†init(delegate:queue:invalidateAfterFirstRead:)¬†initializer method. Set up alertMessage to give users instructions while the phone is scanning NFC tags. Finally, call begin() to start the reader session.\nsession = NFCNDEFReaderSession(delegate: self, queue: nil, invalidateAfterFirstRead: false) session?.alertMessage = \u0026#34;Hold your iPhone near the item to learn more about it.\u0026#34; session?.begin() Third Step The third step is to implement NFCNDEFReaderSessionDelegate to be able to receive notifications from the reader session when it reads an NDEF message or becomes invalid due to ending the session or encountering an error.\n// MARK: - NFCNDEFReaderSessionDelegate /// - Tag: processingTagData func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage]) { DispatchQueue.main.async { // Process detected NFCNDEFMessage objects. self.detectedMessages.append(contentsOf: messages) self.tableView.reloadData() } } /// - Tag: endScanning func readerSession(_ session: NFCNDEFReaderSession, didInvalidateWithError error: Error) { // Check the invalidation reason from the returned error. if let readerError = error as? NFCReaderError { // Show an alert when the invalidation reason is not because of a // successful read during a single-tag read session, or because the // user canceled a multiple-tag read session from the UI or // programmatically using the invalidate method call. if (readerError.code != .readerSessionInvalidationErrorFirstNDEFTagRead) \u0026amp;\u0026amp; (readerError.code != .readerSessionInvalidationErrorUserCanceled) { let alertController = UIAlertController( title: \u0026#34;Session Invalidated\u0026#34;, message: error.localizedDescription, preferredStyle: .alert ) alertController.addAction(UIAlertAction(title: \u0026#34;OK\u0026#34;, style: .default, handler: nil)) DispatchQueue.main.async { self.present(alertController, animated: true, completion: nil) } } } // To read new tags, a new session instance is required. self.session = nil } Resources You can find a more detailed article in the Apple Developer Documentation, where each step is explained in depth.\nDownload Materials Download\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/scanning-nfc-tags-using-corenfc-in-an-ios-app/","summary":"Introduction I never had a chance to work with NFC (Near Field Communication), but I have always been curious to find out how it works. In this article, I will focus on scanning NFC tags using CoreNFC with NFCNDEFReaderSession.\nPreparation Before we begin, let\u0026rsquo;s add the necessary objects:\nNear Field Communication Tag Reading capability to the project. Privacy - NFC Scan Usage Description key to Info.plist. Near Field Communication Tag Reader Session Formats to the entitlements file.","title":"Scanning NFC tags using CoreNFC in an iOS app"},{"content":"Introduction I had the chance to work on a project where communication via BLE was at the heart of the project.\nBefore adding any code to application, I always asked myself about two scenarios:\nThe first scenario is when the device acts as a central device while searching for and connecting to peripheral devices. The second scenario is when the device acts as a peripheral device by using CBCharacteristic and changes its value. In this article, I will focus on the first scenario and will show how to scan for peripheral devices.\nFirst Step The first step is to add permission for Bluetooth: Privacy - Bluetooth Always Usage Description Second Step The second step is to initialize centralManager:\nprivate var centralManager: CBCentralManager! override init() { super.init() centralManager = CBCentralManager(delegate: self, queue: nil, options: [CBCentralManagerOptionShowPowerAlertKey: true]) } CBCentralManager - CBCentralManager objects manage discovered or connected remote peripheral devices (represented by CBPeripheral objects), including scanning for, discovering, and connecting to advertising peripherals.\nCBCentralManagerDelegate - The single required centralManagerDidUpdateState method indicates the availability of the central manager, while the optional methods allow for the discovery and connection of peripherals.\nCBCentralManagerOptionShowPowerAlertKey - An NSNumber (Boolean) indicating that the system should, if Bluetooth is powered off when CBCentralManager is instantiated, display a warning dialog to the user.\nThird Step The third step is to scanForPeripherals after centralManager changes its state to poweredOn.\nfunc centralManagerDidUpdateState(_ central: CBCentralManager) { switch central.state { case .poweredOn: print(\u0026#34;CBManager is powered on\u0026#34;) centralManager.scanForPeripherals(withServices: nil) case .poweredOff: print(\u0026#34;CBManager is not powered on\u0026#34;) return case .resetting: print(\u0026#34;CBManager is resetting\u0026#34;) return case .unauthorized: print(\u0026#34;CBManager is unauthorized\u0026#34;) return case .unknown: print(\u0026#34;CBManager state is unknown\u0026#34;) return case .unsupported: print(\u0026#34;Bluetooth is not supported on this device\u0026#34;) return @unknown default: print(\u0026#34;A previously unknown central manager state occurred\u0026#34;) return } } Fourth Step The fourth step is to implement the didDiscover method that is called when the central manager discovers a peripheral.\nfunc centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { // Reject if the signal strength is too low. // Change the minimum RSSI value depending on your app‚Äôs use case. guard RSSI.intValue \u0026gt;= -50 else { print(\u0026#34;Discovered peripheral not in expected range, at \\(RSSI.intValue)\u0026#34;) return } print(\u0026#34;Discovered \\(String(describing: peripheral.name)) at \\(RSSI.intValue)\u0026#34;) } The sample implementation of this method uses the RSSI (Received Signal Strength Indicator) parameter to determine whether the signal is strong enough. RSSI values are provided as negative numbers, with a theoretical maximum of 0.\nComplete Example import Foundation import CoreBluetooth final class CentralManager: NSObject { private var centralManager: CBCentralManager! override init() { super.init() centralManager = CBCentralManager(delegate: self, queue: nil, options: [CBCentralManagerOptionShowPowerAlertKey: true]) } } // MARK: - CBCentralManagerDelegate extension CentralManager: CBCentralManagerDelegate { func centralManagerDidUpdateState(_ central: CBCentralManager) { switch central.state { case .poweredOn: print(\u0026#34;CBManager is powered on\u0026#34;) centralManager.scanForPeripherals(withServices: nil) case .poweredOff: print(\u0026#34;CBManager is not powered on\u0026#34;) return case .resetting: print(\u0026#34;CBManager is resetting\u0026#34;) return case .unauthorized: print(\u0026#34;CBManager is unauthorized\u0026#34;) return case .unknown: print(\u0026#34;CBManager state is unknown\u0026#34;) return case .unsupported: print(\u0026#34;Bluetooth is not supported on this device\u0026#34;) return @unknown default: print(\u0026#34;A previously unknown central manager state occurred\u0026#34;) return } } func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { // Reject if the signal strength is too low. // Change the minimum RSSI value depending on your app‚Äôs use case. guard RSSI.intValue \u0026gt;= -50 else { print(\u0026#34;Discovered perhiperal not in expected range, at %d\u0026#34;, RSSI.intValue) print(\u0026#34;Discovered %s at %d\u0026#34;, String(describing: peripheral.name), RSSI.intValue) return } print(\u0026#34;Discovered %s at %d\u0026#34;, String(describing: peripheral.name), RSSI.intValue) } } Resources https://developer.apple.com/documentation/corebluetooth/transferring-data-between-bluetooth-low-energy-devices\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/scanning-for-peripheral-devices-using-ble-in-an-ios-app/","summary":"Introduction I had the chance to work on a project where communication via BLE was at the heart of the project.\nBefore adding any code to application, I always asked myself about two scenarios:\nThe first scenario is when the device acts as a central device while searching for and connecting to peripheral devices. The second scenario is when the device acts as a peripheral device by using CBCharacteristic and changes its value.","title":"Scanning for peripheral devices using BLE in an iOS app"},{"content":"Introduction Working with batteries on iOS devices for large applications has always been tricky. The amount of energy consumed by the screen, location services, network calls, processing, background tasks, etc., is significant. From a developer\u0026rsquo;s perspective, it seems complicated, but Xcode provides tools to address this problem.\nTo find the issue, you need to open Xcode and go to the Debug Navigator.\nIn the Debug Navigator, you will see the Energy Impact gauge. In the histogram, blue indicates good performance, while red indicates overhead. Based on this information, you can analyze the overhead and resolve potential issues by utilizing Instruments such as Network, Location, CPU Profile, etc. For each case, Xcode provides instruments that allow you to dive deeper and understand what is happening in detail. Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/battery-performance-testing-for-ios-app/","summary":"Introduction Working with batteries on iOS devices for large applications has always been tricky. The amount of energy consumed by the screen, location services, network calls, processing, background tasks, etc., is significant. From a developer\u0026rsquo;s perspective, it seems complicated, but Xcode provides tools to address this problem.\nTo find the issue, you need to open Xcode and go to the Debug Navigator.\nIn the Debug Navigator, you will see the Energy Impact gauge.","title":"Battery Performance Testing for iOS App"},{"content":"Introduction In the previous chapter, I started talking about the video game creation process, from project setup to adding the background. Now, I\u0026rsquo;m going to add the player and physics to it.\nYou can download the project here.\nFirst Step The first step is to initialize player using SKSpriteNode, set up player.position, and add player as a child node.\nSKSpriteNode - is an onscreen graphical element that can be initialized from an image or a solid color.\nself.player = SKSpriteNode(imageNamed: \u0026#34;shuttle\u0026#34;) player.position = CGPoint(x: self.frame.size.width / 2, y: player.size.height / 2 + 20) self.addChild(player) Second Step The second step is to remove Earth\u0026rsquo;s gravity effect from the physics world, because the player will be looking into the screen from a top-down perspective and gravity effects make no difference for it.\nself.physicsWorld.gravity = CGVector(dx: 0, dy: 0) Third Step The third step is to add contactDelegate to be able to respond when physics bodies come into contact.\nSKPhysicsContactDelegate - An object that implements the SKPhysicsContactDelegate protocol can respond when two physics bodies with overlapping contactTestBitMask values are in contact with each other in a physics world. You can use the contact delegate to play a sound or execute game logic, such as increasing a player‚Äôs score when a contact event occurs.\nself.physicsWorld.contactDelegate = self private let alienCategory: UInt32 = 0x1 \u0026lt;\u0026lt; 1 private let photonTorpedoCategory: UInt32 = 0x1 \u0026lt;\u0026lt; 0 alien.physicsBody?.categoryBitMask = alienCategory alien.physicsBody?.contactTestBitMask = photonTorpedoCategory alien.physicsBody?.collisionBitMask = 0 torpedoNode.physicsBody?.categoryBitMask = photonTorpedoCategory torpedoNode.physicsBody?.contactTestBitMask = alienCategory torpedoNode.physicsBody?.collisionBitMask = 0 torpedoNode.physicsBody?.usesPreciseCollisionDetection = true // MARK: - SKPhysicsContactDelegate extension GameScene: SKPhysicsContactDelegate { func didBegin(_ contact: SKPhysicsContact) { var firstBody: SKPhysicsBody var secondBody: SKPhysicsBody if contact.bodyA.categoryBitMask \u0026lt; contact.bodyB.categoryBitMask { firstBody = contact.bodyA secondBody = contact.bodyB } else { firstBody = contact.bodyB secondBody = contact.bodyA } if (firstBody.categoryBitMask \u0026amp; photonTorpedoCategory) != 0 \u0026amp;\u0026amp; (secondBody.categoryBitMask \u0026amp; alienCategory) != 0 { torpedoDidCollideWithAlien(torpedoNode: firstBody.node as! SKSpriteNode, alienNode: secondBody.node as! SKSpriteNode) } } } didBegin(_:) is an instance method called when two bodies first contact each other.\nAdditionally We need to add scoreLabel to track the player\u0026rsquo;s score:\nself.scoreLabel = SKLabelNode(text: \u0026#34;Score: 0\u0026#34;) scoreLabel.position = CGPoint(x: self.frame.size.width / 2, y: self.frame.size.height - 50) scoreLabel.fontName = \u0026#34;AmericanTypewriter-Bold\u0026#34; scoreLabel.fontSize = 36 scoreLabel.fontColor = UIColor.white score = 0 self.addChild(scoreLabel) gameTimer to add an alien every 0.75 milliseconds:\nself.gameTimer = Timer.scheduledTimer(timeInterval: 0.75, target: self, selector: #selector(addAlien), userInfo: nil, repeats: true) motionManager to change the user\u0026rsquo;s position using the accelerometer:\nself.motionManager = CMMotionManager() motionManager.accelerometerUpdateInterval = 0.1 motionManager.startAccelerometerUpdates(to: OperationQueue.current!) { (data: CMAccelerometerData?, error: Error?) in if let accelerometerData = data { let acceleration = accelerometerData.acceleration self.xAcceleration = CGFloat(acceleration.x) * 0.75 + self.xAcceleration * 0.25 } } touchesEnded method to fire a torpedo:\noverride func touchesEnded(_ touches: Set\u0026lt;UITouch\u0026gt;, with event: UIEvent?) { fireTorpedo() } didSimulatePhysics method to change the player\u0026rsquo;s position:\noverride func didSimulatePhysics() { player.position.x += xAcceleration * 50 if player.position.x \u0026lt; 0 { player.position = CGPoint(x: self.frame.size.width, y: player.position.y) } else if player.position.x \u0026gt; self.frame.size.width { player.position = CGPoint(x: 0, y: player.position.y) } } Summarizing It was an amazing experience. I was surprised that the entire game was less than 200 lines of code. I tried my best to create a step-by-step instruction of the game creation process. I hope this article will be helpful for you.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/creating-2d-space-game-for-ios-using-spritekit-part-2/","summary":"Introduction In the previous chapter, I started talking about the video game creation process, from project setup to adding the background. Now, I\u0026rsquo;m going to add the player and physics to it.\nYou can download the project here.\nFirst Step The first step is to initialize player using SKSpriteNode, set up player.position, and add player as a child node.\nSKSpriteNode - is an onscreen graphical element that can be initialized from an image or a solid color.","title":"Creating a 2D Space Game for iOS Using SpriteKit - Part 2"},{"content":"Introduction I have never tried creating a game before; it feels like magic to me. I know that games have an enormous amount of underlying layers of abstractions and tools such as game engines, rendering, and so on. I have always been eager to learn at least 1% of the game creation process. In this article, I\u0026rsquo;m going to explore step-by-step instructions for creating a game for the iOS platform using SpriteKit.\nFirst Step The first step is to create an Xcode project using the iOS game template and SpriteKit Game Technology. Second Step The second step is to add resources like images and sounds. You can find assets inside the Assets folder Download Project.\nThird Step The third step is to override the didMove(to:) method - it tells you when the scene is presented by a view. This method is similar to viewDidLoad for UIViewController. We will be implementing logic inside it.\noverride func didMove(to view: SKView) { } Creating and Adding Starfield Background The next step is to create and add a starfield using SKEmitterNode as a child to SKScene. After that, you will be able to see the starfield in the background.\nself.starfield = SKEmitterNode(fileNamed: \u0026#34;Starfield\u0026#34;) starfield.position = CGPoint(x: self.frame.size.width / 2, y: self.frame.size.height) starfield.advanceSimulationTime(10) self.addChild(starfield) starfield.zPosition = -1 Let\u0026rsquo;s Dive a Little Deeper Custom Particles Creation If you were wondering how to create custom particles similar to the starfield background, you need to:\nCreate a new SpriteKit Particle File: Choose a particle template: Select the created file -\u0026gt; Open the Inspectors side menu and configure it with settings that you like. SKEmitterNode Initialization of SKEmitterNode(fileNamed: \u0026quot;Starfield\u0026quot;) helps create a starfield background.\nSKEmitterNode is a node that automatically creates and renders small particle sprites. Particles are privately owned by SpriteKit‚Äîyour game cannot access the generated sprites. For example, you cannot add physics shapes to particles. Emitter nodes are often used to create smoke, fire, sparks, and other particle effects.\nadvanceSimulationTime advanceSimulationTime(10) - Advances the emitter particle simulation. In other words, you do not need to wait until the particles reach the bottom of the screen. addChild self.addChild(starfield) - Adds a node to the end of the receiver‚Äôs list of child nodes. After that, you will be able to see the starfield background.\nzPosition zPosition = -1 - Moves the starfield to the back of the screen.\nResources Enormous appreciation for Brian Advent for his comprehensive video. Without it, I would still be surfing the internet and collecting pieces of the puzzle.\nDownload Materials Download Project\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/creating-2d-space-game-for-ios-using-spritekit-part-1/","summary":"Introduction I have never tried creating a game before; it feels like magic to me. I know that games have an enormous amount of underlying layers of abstractions and tools such as game engines, rendering, and so on. I have always been eager to learn at least 1% of the game creation process. In this article, I\u0026rsquo;m going to explore step-by-step instructions for creating a game for the iOS platform using SpriteKit.","title":"Creating a 2D Space Game for iOS Using SpriteKit - Part 1"},{"content":"Introduction When working in a large codebase with a significant number of async events, I often found myself in situations where I couldn\u0026rsquo;t combine events effectively. This resulted in optimization problems and inefficient consumption of OS resources.\nThe codebase contained closures and async/await, so it wasn\u0026rsquo;t possible to use operators like merge or combineLatest. After discovering this limitation, I decided to add new methods using Combine.\nI will be demonstrating this with a simple NetworkService responsible only for executing and validating requests using Combine. Let\u0026rsquo;s dive into the implementation.\nFirst Step The first step is to create the NetworkService with request(_ endpoint: Endpoint) method.\nfunc request\u0026lt;T: Decodable\u0026gt;(_ endpoint: Endpoint) -\u0026gt; AnyPublisher\u0026lt;T, Error\u0026gt; {} Quick Explanation of What AnyPublisher Is The AnyPublisher returns a publisher from a method without exposing the specific type of publisher you are using internally. It helps hide implementation details.\nSecond Step The second step is to add a few helpers such as Endpoint and NetworkError.\nstruct Endpoint { let url: String let headers: [String: String]? let body: Data? let httpMethod: HTTPMethod func urlRequest(with url: URL) -\u0026gt; URLRequest { var urlRequest = URLRequest(url: url) urlRequest.httpMethod = httpMethod.rawValue urlRequest.allHTTPHeaderFields = headers ?? [:] urlRequest.httpBody = body return urlRequest } enum HTTPMethod: String { case GET case POST case PUT case DELETE } } enum NetworkError: Error { case invalidURL case invalidResponseType case jsonDecoderError(_ error: Error) } Third Step The third step is to implement the request method.\nfunc request\u0026lt;T: Decodable\u0026gt;(_ endpoint: Endpoint) -\u0026gt; AnyPublisher\u0026lt;T, Error\u0026gt; { guard let url = URL(string: endpoint.url) else { return Fail\u0026lt;T, Error\u0026gt;(error: NetworkError.invalidURL).eraseToAnyPublisher() } return URLSession.shared .dataTaskPublisher(for: endpoint.urlRequest(with: url)) .tryMap { output in guard output.response is HTTPURLResponse else { throw NetworkError.invalidResponseType } return output.data } .decode(type: T.self, decoder: JSONDecoder()) .mapError { error in NetworkError.jsonDecoderError(error) } .eraseToAnyPublisher() } Fourth Step The fourth step is to test if NetworkService works as expected.\nimport Combine import Inject import SwiftUI public struct ContentView: View { @ObserveInjection var inject private let networkService: NetworkService = .init() @State private var cancellables = Set\u0026lt;AnyCancellable\u0026gt;() @State private var post: Post? public init() {} public var body: some View { VStack { Button(\u0026#34;Fetch Data\u0026#34;) { networkService .request(Endpoint(url: \u0026#34;https://jsonplaceholder.typicode.com/posts/1\u0026#34;, httpMethod: .GET)) .sink(receiveCompletion: { completion in switch completion { case .finished: break case let .failure(error): print(error) } }, receiveValue: { (post: Post) in self.post = post }) .store(in: \u0026amp;cancellables) } Text(post?.title ?? \u0026#34;\u0026#34;) } .enableInjection() } } Summary Combine is best suited for handling multiple async events by using event-processing operators. Before integrating it into your codebase, make sure to weigh all the pros and cons.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/combine-practical-usage-examples/","summary":"Introduction When working in a large codebase with a significant number of async events, I often found myself in situations where I couldn\u0026rsquo;t combine events effectively. This resulted in optimization problems and inefficient consumption of OS resources.\nThe codebase contained closures and async/await, so it wasn\u0026rsquo;t possible to use operators like merge or combineLatest. After discovering this limitation, I decided to add new methods using Combine.\nI will be demonstrating this with a simple NetworkService responsible only for executing and validating requests using Combine.","title":"Combine practical usage examples"},{"content":"Introduction I always wondered how I could automate testing the push notification process. Even when Apple introduced the possibility of dragging a configured file to the simulator to display a notification, it is still a manual process. I\u0026rsquo;ll skip testing via the terminal because I think it takes more time than using an APNS file or the RocketSim app.\nBefore I was first introduced to the RocketSim app, I used an APNS file for testing push notifications. It worked for me and my teammates, but I knew it could be better. It looks something like this:\nTesting Using an APNS File To test push notifications using an APNS file, you need to create a file with a .apns extension and put JSON into it.\n{ \u0026#34;Simulator Target Bundle\u0026#34;: \u0026#34;dev.mt.Demo\u0026#34;, \u0026#34;aps\u0026#34;: { \u0026#34;alert\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Title\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Body\u0026#34; } } } You also need to specify the Simulator Target Bundle; without it, you will receive an error. After that, you can drag this file to the simulator. When I found the RocketSim app and learned about its ability to send push notifications from the simulator side menu, it was a game changer for me. No more dragging files or terminal commands‚Äîit‚Äôs all in one place. The only thing you need to do is create the payload.\nTesting Using the RocketSim App To test push notifications using the RocketSim app, all you need to do is:\nOpen the RocketSim app. Go to the simulator side menu. Click on the bell button. Click on the ‚ÄúConfigure Push Notifications‚Äù button. The last step is to add groups, set the bundle identifier, switch to push notifications, and add a push notification. Now you have configured the push notification, and from now on, you can send it with just a tap in the RocketSim app\u0026rsquo;s simulator side menu. Summary Using the RocketSim app saved me a lot of time and effort. Without it, I would still be testing manually and spending time on work that could be automated. I would recommend this tool to anyone.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/testing-push-notifications-locally-in-an-ios-app/","summary":"Introduction I always wondered how I could automate testing the push notification process. Even when Apple introduced the possibility of dragging a configured file to the simulator to display a notification, it is still a manual process. I\u0026rsquo;ll skip testing via the terminal because I think it takes more time than using an APNS file or the RocketSim app.\nBefore I was first introduced to the RocketSim app, I used an APNS file for testing push notifications.","title":"Testing push notifications locally in an iOS app"},{"content":"Introduction If you start a project from scratch, you need to always create some kind of service like PushNotificationService that will be responsible for handling push notification events. In this article, I want to explore a simple implementation of PushNotificationService to be able to reuse and customize it in future projects.\nFirst Step The first step is to add the Push Notifications capability to your project. Go to your project -\u0026gt; Signing \u0026amp; Capabilities -\u0026gt; Tap + Capability -\u0026gt; Search for Push Notifications.\nSecond Step The second step is to register push notifications.\nfunc application(_: UIApplication, didFinishLaunchingWithOptions _: [UIApplication.LaunchOptionsKey: Any]? = nil) -\u0026gt; Bool { pushNotificationService.registerPushNotifications() return true } Third Step The third step is to add didRegisterForRemoteNotificationsWithDeviceToken and didFailToRegisterForRemoteNotificationsWithError to the AppDelegate file and pass the information that occurred to PushNotificationService.\nfunc application(_: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { pushNotificationService.didRegisterForRemoteNotificationsWithDeviceToken(deviceToken: deviceToken) } func application(_: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) { pushNotificationService.didFailToRegisterForRemoteNotificationsWithError(error: error) } Complete Example import UIKit class AppDelegate: NSObject, UIApplicationDelegate { private let pushNotificationService = PushNotificationService() func application(_: UIApplication, didFinishLaunchingWithOptions _: [UIApplication.LaunchOptionsKey: Any]? = nil) -\u0026gt; Bool { pushNotificationService.registerPushNotifications() return true } func application(_: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { pushNotificationService.didRegisterForRemoteNotificationsWithDeviceToken(deviceToken: deviceToken) } func application(_: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: any Error) { pushNotificationService.didFailToRegisterForRemoteNotificationsWithError(error: error) } } import UIKit public final class PushNotificationService: NSObject { public func registerPushNotifications() { UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, _ in guard granted else { return } DispatchQueue.main.async { UIApplication.shared.registerForRemoteNotifications() } } } public func didRegisterForRemoteNotificationsWithDeviceToken(deviceToken: Data) { let token = deviceToken.map { String(format: \u0026#34;%02.2hhx\u0026#34;, $0) }.joined() print(\u0026#34;Device token: \\(token)\u0026#34;) } public func didFailToRegisterForRemoteNotificationsWithError(error: any Error) { print(\u0026#34;Failed to register for remote notifications: \\(error)\u0026#34;) } } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/adding-push-notifications-to-an-ios-app/","summary":"Introduction If you start a project from scratch, you need to always create some kind of service like PushNotificationService that will be responsible for handling push notification events. In this article, I want to explore a simple implementation of PushNotificationService to be able to reuse and customize it in future projects.\nFirst Step The first step is to add the Push Notifications capability to your project. Go to your project -\u0026gt; Signing \u0026amp; Capabilities -\u0026gt; Tap + Capability -\u0026gt; Search for Push Notifications.","title":"Adding Push Notifications to an iOS App"},{"content":"Introduction I was curious about caching data using NSCache for an iOS app. So, I did some digging. Here is what I found:\nQuick Overview NSCache helps store data in memory. When the application gets killed, it frees memory; it‚Äôs not persisted on disk. Storing data is carried out using a key-value pair mechanism like Dictionary. You can set automatic eviction to delete objects automatically. NSCache has multi-platform support: iOS, iPadOS, watchOS, macOS, and tvOS. Caveats NSCache has Objective-C roots. It can‚Äôt use struct because it is constrained to conform to AnyObject, meaning you must use class and NSString instead of String.\nStore Object You can store an object by setting it in the cache:\nfunc storeImage(_ image: UIImage, for key: String) { cache.setObject(image, forKey: key as NSString) } Retrieve Object You can retrieve an object by getting the object for the key:\nfunc retrieveImage(for key: String) -\u0026gt; UIImage? { cache.object(forKey: key as NSString) } Removing Object You can remove an object by removing the object for the key, or remove all objects:\nfunc removeImage(for key: String) { cache.removeObject(forKey: key as NSString) } func removeAllImages() { cache.removeAllObjects() } Automatically Cache Cleaning You can limit the number of objects in memory by setting countLimit. countLimit depends on the size of the object that you need to store in the cache. If it‚Äôs a large image, the limit can be less.\ncache.countLimit = 5 Another way to do automatic cleaning is to set up totalCostLimit. NSCache will automatically delete objects until the total cost of the cache is under the totalCostLimit.\ncache.totalCostLimit = 10 * 1024 * 1024 // 10 MB Caveats Even if you don‚Äôt set any deletion conditions, NSCache will automatically clean up when the system really needs memory.\nNSCacheDelegate cache(_:willEvictObject:) notifies when an object is being removed. It helps in cases when you need to react to these changes.\nextension CacheService: NSCacheDelegate { func cache(_ cache: NSCache\u0026lt;AnyObject, AnyObject\u0026gt;, willEvictObject obj: Any) { print(\u0026#34;Object will be evicted: \\(obj)\u0026#34;) } } Complete Sample final class CacheService: NSObject { private let cache: NSCache\u0026lt;NSString, UIImage\u0026gt; override init() { cache = NSCache() cache.name = \u0026#34;Remote Image Cache\u0026#34; cache.countLimit = 5 cache.totalCostLimit = 10 * 1024 * 1024 // 10 MB } func storeImage(_ image: UIImage, for key: String) { cache.setObject(image, forKey: key as NSString) } func retrieveImage(for key: String) -\u0026gt; UIImage? { cache.object(forKey: key as NSString) } func removeImage(for key: String) { cache.removeObject(forKey: key as NSString) } func removeAllImages() { cache.removeAllObjects() } } // MARK: - NSCacheDelegate extension CacheService: NSCacheDelegate { func cache(_ cache: NSCache\u0026lt;AnyObject, AnyObject\u0026gt;, willEvictObject obj: Any) { print(\u0026#34;Object will be evicted: \\(obj)\u0026#34;) } } Resources Thanks to Andy Ibanez for his amazing straightforward explanation with examples. It helped a lot to quickly understand this topic.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/caching-data-using-nscache-in-ios/","summary":"Introduction I was curious about caching data using NSCache for an iOS app. So, I did some digging. Here is what I found:\nQuick Overview NSCache helps store data in memory. When the application gets killed, it frees memory; it‚Äôs not persisted on disk. Storing data is carried out using a key-value pair mechanism like Dictionary. You can set automatic eviction to delete objects automatically. NSCache has multi-platform support: iOS, iPadOS, watchOS, macOS, and tvOS.","title":"Caching data using NSCache in iOS"},{"content":"Introduction Previously, I posted about Accessibility for UIKit. The idea behind this post is to find differences between UIKit Accessibility and SwiftUI features.\nSimilarities: Both UIKit and SwiftUI have accessibilityLabel and accessibilityHints APIs.\nDifferences: To use dynamic type for fonts, you need additional modifiers in SwiftUI. struct ScaledFont: ViewModifier { @Environment(\\.sizeCategory) var sizeCategory var name: String var size: Double func body(content: Content) -\u0026gt; some View { let scaledSize = UIFontMetrics.default.scaledValue(for: size) return content.font(.custom(name, size: scaledSize)) } } extension View { func scaledFont(name: String, textSize size: Double) -\u0026gt; some View { return self.modifier(ScaledFont(name: name, size: size)) } } To step over elements in a list, you need to add .accessibilityElement(children: .combine) to each row in SwiftUI. struct FruitCaloriesCounter: View { var body: some View { NavigationView { List(fruits) { fruit in FruitRow(fruit: fruit) .accessibilityElement(children: .combine) } .navigationTitle(\u0026#34;Fruits Calories Counter\u0026#34;) .accessibilityElement(children: .contain) .navigationBarTitleDisplayMode(.inline) } } } In UIKit, you can insert and remove accessibilityTraits depending on the button state: if button.isSelected { button.accessibilityTraits.insert(.header) } else { button.accessibilityTraits.remove(.header) } In SwiftUI, you need to pass .accessibilityAddTraits(selected ? [.isSelected, .isButton] : .isButton) to one modifier. Button(action: { selected.toggle() }) { Image(systemName: selected ? \u0026#34;star.fill\u0026#34; : \u0026#34;star\u0026#34;) .frame(width: 44, height: 44) .accessibilityLabel(\u0026#34;favourite\u0026#34;) .accessibilityHint(selected ? \u0026#34;removes favourite\u0026#34; : \u0026#34;makes favourite\u0026#34;) .accessibilityAddTraits(selected ? [.isSelected, .isButton] : .isButton) } .buttonStyle(.plain) Complete Sample import SwiftUI let fruits = [ Fruit(name: \u0026#34;Apple\u0026#34;, calories: 52), Fruit(name: \u0026#34;Banana\u0026#34;, calories: 89), Fruit(name: \u0026#34;Orange\u0026#34;, calories: 47), Fruit(name: \u0026#34;Pineapple\u0026#34;, calories: 50), Fruit(name: \u0026#34;Strawberry\u0026#34;, calories: 32) ] struct Fruit: Identifiable { var id: String { name } let name: String let calories: Int } struct FruitRow: View { @State private var selected = false let fruit: Fruit var body: some View { HStack(spacing: 8) { VStack(alignment: .leading, spacing: 8) { Text(fruit.name) .scaledFont(name: \u0026#34;Helvetica\u0026#34;, textSize: 20) .accessibilityLabel(fruit.name) Text(\u0026#34;\\(fruit.calories) per 100g\u0026#34;) .scaledFont(name: \u0026#34;Helvetica\u0026#34;, textSize: 15) .accessibilityLabel(\u0026#34;\\(fruit.calories) calories per 100 grams\u0026#34;) } Spacer() Button(action: { selected.toggle() }) { Image(systemName: selected ? \u0026#34;star.fill\u0026#34; : \u0026#34;star\u0026#34;) .frame(width: 44, height: 44) .accessibilityLabel(\u0026#34;favourite\u0026#34;) .accessibilityHint(selected ? \u0026#34;removes favourite\u0026#34; : \u0026#34;makes favourite\u0026#34;) .accessibilityAddTraits(selected ? [.isSelected, .isButton] : .isButton) } .buttonStyle(.plain) } } } struct FruitCaloriesCounter: View { var body: some View { NavigationView { List(fruits) { fruit in FruitRow(fruit: fruit) .accessibilityElement(children: .combine) } .navigationTitle(\u0026#34;Fruits Calories Counter\u0026#34;) .accessibilityElement(children: .contain) .navigationBarTitleDisplayMode(.inline) } } } struct ContentView: View { var body: some View { FruitCaloriesCounter() } } #Preview { ContentView() } struct ScaledFont: ViewModifier { @Environment(\\.sizeCategory) var sizeCategory var name: String var size: Double func body(content: Content) -\u0026gt; some View { let scaledSize = UIFontMetrics.default.scaledValue(for: size) return content.font(.custom(name, size: scaledSize)) } } extension View { func scaledFont(name: String, textSize size: Double) -\u0026gt; some View { return self.modifier(ScaledFont(name: name, size: size)) } } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/accessibility-ios-swiftui/","summary":"Introduction Previously, I posted about Accessibility for UIKit. The idea behind this post is to find differences between UIKit Accessibility and SwiftUI features.\nSimilarities: Both UIKit and SwiftUI have accessibilityLabel and accessibilityHints APIs.\nDifferences: To use dynamic type for fonts, you need additional modifiers in SwiftUI. struct ScaledFont: ViewModifier { @Environment(\\.sizeCategory) var sizeCategory var name: String var size: Double func body(content: Content) -\u0026gt; some View { let scaledSize = UIFontMetrics.default.scaledValue(for: size) return content.","title":"Accessibility iOS SwiftUI"},{"content":"Introduction I was curious to find out how to make an application more accessible. You can look at popular applications like YouTube or Netflix; they all have accessibility features like VoiceOver and dynamic fonts. I decided to create this example for a fruit calorie counter. It contains a list of fruits with the fruit name, fruit calories, and a favorite button.\nWhere to Start Before diving into implementation details, I want to highlight some information about the existing accessibility features and what I will be focusing on.\nExisting Accessibility Features Apple provides a variety of tools; here are the most important ones:\nVoiceOver: A screen reader that allows visually impaired users to interact with their devices. Dynamic Type: Support for adjustable text sizes. Users can choose larger text sizes in the system settings, and apps should respond appropriately by scaling text and UI elements. Contrast and Color: Ensuring sufficient contrast between text and background to make content readable for users with visual impairments. Switch Control: A feature that allows users with limited mobility to control their device using adaptive accessories. AssistiveTouch: A feature that helps users with physical disabilities perform actions that would otherwise require gestures. Labels and Hints: Using accessibility labels and hints to provide descriptive text for UI elements, which helps VoiceOver users understand what an element does. Focus Areas I will be focusing on Labels and Hints, VoiceOver, and Dynamic Type.\nImplementation First Step The first step would be to mark yourUIElement.isAccessibilityElement = true to enable your component\u0026rsquo;s visibility for VoiceOver.\nSecond Step The second step would be to define accessibilityElements for UI components that you want to access for VoiceOver. VoiceOver will read elements from top to bottom.\noverride var accessibilityElements: [Any]? { get { return [ nameLabel as Any, caloriesLabel as Any, favouriteButton as Any ] } set { } } Third Step The third step would be to add an accessibilityLabel; it will help identify the control or view.\nfavouriteButton.accessibilityLabel = \u0026#34;favourite\u0026#34; Fourth Step The fourth step would be to add an accessibilityHint; it describes the result of performing an action on the element.\nfavouriteButton.accessibilityHint = favouriteButton.isSelected ? \u0026#34;makes favourite\u0026#34; : \u0026#34;removes favourite\u0026#34; Adding Dynamic Type to Font Size If you run your application and go to the Accessibility Inspector and Run Audit for it, you will probably see an error like Dynamic font sizes are unsupported. This means if you go and change the Text Size for your entire system, your application\u0026rsquo;s font size will not change.\nTo fix it, you need to add adjustsFontForContentSizeCategory = true - it indicates whether the corresponding element should automatically update its font when the device‚Äôs UIContentSizeCategory is changed.\nnameLabel.adjustsFontForContentSizeCategory = true caloriesLabel.adjustsFontForContentSizeCategory = true If you need a custom font in your application, you need to transform the custom font to Dynamic Type by using UIFontMetrics.default.scaledFont.\nNow you can actually test it from the Accessibility Inspector settings page.\nCaveats The last thing is to make the table view automatically calculate row size because your content can potentially be clipped, as it happened to me üòä You just need to add UITableView.automaticDimension to the heightForRowAt method of UITableViewDelegate.\nDownload Materials Download\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/accessibility-ios-uikit/","summary":"Introduction I was curious to find out how to make an application more accessible. You can look at popular applications like YouTube or Netflix; they all have accessibility features like VoiceOver and dynamic fonts. I decided to create this example for a fruit calorie counter. It contains a list of fruits with the fruit name, fruit calories, and a favorite button.\nWhere to Start Before diving into implementation details, I want to highlight some information about the existing accessibility features and what I will be focusing on.","title":"Accessibility iOS UIKit"},{"content":"Introduction I was eager to learn how converting Text To Speech works in iOS. Here is what I discovered:\nFirst Step The first step is to add AVSpeechSynthesizer, an object that produces synthesized speech from text utterances.\n@State private var speechSynthesizer = AVSpeechSynthesizer() Second Step The second step is to add AVSpeechUtterance, an object that encapsulates the text for speech synthesis.\nprivate var utterance: AVSpeechUtterance { let inputMessage = \u0026#34;Hello world!\u0026#34; let utterance = AVSpeechUtterance(string: inputMessage) utterance.voice = AVSpeechSynthesisVoice(language: \u0026#34;en-US\u0026#34;) return utterance } Optional You can configure pitch, rate, and voice parameters.\nThird Step The third step is to add a speak method that actually allows you to convert Text To Speech.\nspeechSynthesizer.speak(utterance) Complete Example import SwiftUI import AVFoundation struct ContentView: View { @State private var speechSynthesizer = AVSpeechSynthesizer() private var utterance: AVSpeechUtterance { let inputMessage = \u0026#34;Hello world!\u0026#34; let utterance = AVSpeechUtterance(string: inputMessage) utterance.voice = AVSpeechSynthesisVoice(language: \u0026#34;en-US\u0026#34;) return utterance } var body: some View { VStack { Button(\u0026#34;Speak\u0026#34;) { speechSynthesizer.speak(utterance) } } .padding() } } #Preview { ContentView() } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/text-to-speech-ios/","summary":"Introduction I was eager to learn how converting Text To Speech works in iOS. Here is what I discovered:\nFirst Step The first step is to add AVSpeechSynthesizer, an object that produces synthesized speech from text utterances.\n@State private var speechSynthesizer = AVSpeechSynthesizer() Second Step The second step is to add AVSpeechUtterance, an object that encapsulates the text for speech synthesis.\nprivate var utterance: AVSpeechUtterance { let inputMessage = \u0026#34;Hello world!","title":"Text To Speech iOS"},{"content":"Introduction I always wanted an iOS app that would allow me to economize my time by converting speech to text. I know this option is built into the keyboard, but you first need to click the text field, then tap on the microphone, and finally speak. I wanted a one-click option with the possibility to integrate it into all my daily routines. Here is what I discovered:\nFirst Step The first step is to request authorization to access the device\u0026rsquo;s microphone using the Privacy - Speech Recognition Usage Description key and the Privacy - Microphone Usage Description key.\nSecond Step The second step is to add a SpeechRecognizerService that will detect and transcribe speech. It consists of SFSpeechRecognizer, AVAudioSession, and AVAudioEngine. Your transcribed speech will be stored in the transcript property.\nimport Foundation import AVFoundation import Speech /// A helper for transcribing speech to text using SFSpeechRecognizer and AVAudioEngine. actor SpeechRecognizerService: ObservableObject { enum RecognizerError: Error { case nilRecognizer case notAuthorizedToRecognize case notPermittedToRecord case recognizerIsUnavailable var message: String { switch self { case .nilRecognizer: return \u0026#34;Can\u0026#39;t initialize speech recognizer\u0026#34; case .notAuthorizedToRecognize: return \u0026#34;Not authorized to recognize speech\u0026#34; case .notPermittedToRecord: return \u0026#34;Not permitted to record audio\u0026#34; case .recognizerIsUnavailable: return \u0026#34;Recognizer is unavailable\u0026#34; } } } @MainActor @Published private(set) var transcript: String = \u0026#34;\u0026#34; private var audioEngine: AVAudioEngine? private var request: SFSpeechAudioBufferRecognitionRequest? private var task: SFSpeechRecognitionTask? private let recognizer: SFSpeechRecognizer? /** Initializes a new speech recognizer. If this is the first time you\u0026#39;ve used the class, it requests access to the speech recognizer and the microphone. */ init() { recognizer = SFSpeechRecognizer() guard recognizer != nil else { transcribe(RecognizerError.nilRecognizer) return } Task { do { guard await SFSpeechRecognizer.hasAuthorizationToRecognize() else { throw RecognizerError.notAuthorizedToRecognize } guard await AVAudioSession.sharedInstance().hasPermissionToRecord() else { throw RecognizerError.notPermittedToRecord } } catch { transcribe(error) } } } @MainActor func startTranscribing() { Task { await transcribe() } } @MainActor func resetTranscript() { Task { await reset() } } @MainActor func stopTranscribing() { Task { await reset() } } } private extension SpeechRecognizerService { /** Begin transcribing audio. Creates a `SFSpeechRecognitionTask` that transcribes speech to text until you call `stopTranscribing()`. The resulting transcription is continuously written to the published `transcript` property. */ func transcribe() { guard let recognizer, recognizer.isAvailable else { self.transcribe(RecognizerError.recognizerIsUnavailable) return } do { let (audioEngine, request) = try Self.prepareEngine() self.audioEngine = audioEngine self.request = request self.task = recognizer.recognitionTask(with: request, resultHandler: { [weak self] result, error in self?.recognitionHandler(audioEngine: audioEngine, result: result, error: error) }) } catch { self.reset() self.transcribe(error) } } /// Reset the speech recognizer. func reset() { task?.cancel() audioEngine?.stop() audioEngine = nil request = nil task = nil } static func prepareEngine() throws -\u0026gt; (AVAudioEngine, SFSpeechAudioBufferRecognitionRequest) { let audioEngine = AVAudioEngine() let request = SFSpeechAudioBufferRecognitionRequest() request.shouldReportPartialResults = true let audioSession = AVAudioSession.sharedInstance() try audioSession.setCategory(.playAndRecord, mode: .measurement, options: .duckOthers) try audioSession.setActive(true, options: .notifyOthersOnDeactivation) let inputNode = audioEngine.inputNode let recordingFormat = inputNode.outputFormat(forBus: 0) inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) { (buffer: AVAudioPCMBuffer, when: AVAudioTime) in request.append(buffer) } audioEngine.prepare() try audioEngine.start() return (audioEngine, request) } nonisolated func recognitionHandler(audioEngine: AVAudioEngine, result: SFSpeechRecognitionResult?, error: Error?) { let receivedFinalResult = result?.isFinal ?? false let receivedError = error != nil if receivedFinalResult || receivedError { audioEngine.stop() audioEngine.inputNode.removeTap(onBus: 0) } if let result { transcribe(result.bestTranscription.formattedString) } } nonisolated func transcribe(_ message: String) { Task { @MainActor in transcript = message } } nonisolated func transcribe(_ error: Error) { var errorMessage = \u0026#34;\u0026#34; if let error = error as? RecognizerError { errorMessage += error.message } else { errorMessage += error.localizedDescription } Task { @MainActor [errorMessage] in transcript = \u0026#34;\u0026lt;\u0026lt; \\(errorMessage) \u0026gt;\u0026gt;\u0026#34; } } } extension SFSpeechRecognizer { static func hasAuthorizationToRecognize() async -\u0026gt; Bool { await withCheckedContinuation { continuation in requestAuthorization { status in continuation.resume(returning: status == .authorized) } } } } extension AVAudioSession { func hasPermissionToRecord() async -\u0026gt; Bool { await withCheckedContinuation { continuation in requestRecordPermission { authorized in continuation.resume(returning: authorized) } } } } Third Step The third step is to integrate speech recognition.\nimport SwiftUI struct ContentView: View { @StateObject private var speechRecognizerService: SpeechRecognizerService = SpeechRecognizerService() var body: some View { ScrollView { VStack { Button(\u0026#34;Start\u0026#34;) { speechRecognizerService.startTranscribing() } Divider() Button(\u0026#34;Stop\u0026#34;) { speechRecognizerService.stopTranscribing() } Divider() Text(speechRecognizerService.transcript) } } .padding() } } #Preview { ContentView() } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/speech-to-text-ios/","summary":"Introduction I always wanted an iOS app that would allow me to economize my time by converting speech to text. I know this option is built into the keyboard, but you first need to click the text field, then tap on the microphone, and finally speak. I wanted a one-click option with the possibility to integrate it into all my daily routines. Here is what I discovered:\nFirst Step The first step is to request authorization to access the device\u0026rsquo;s microphone using the Privacy - Speech Recognition Usage Description key and the Privacy - Microphone Usage Description key.","title":"Speech To Text iOS"},{"content":"Introduction I was curious about creating animations in UIKit. I wanted to animate different properties such as color and path. Here is what I found:\nIt‚Äôs impossible to create complex animations only by using the block-based animation API. To do that, you need the Core Animation API and CAPropertyAnimation with its various subclasses.\nComplex animation in UIKit is based on a few key components:\nCAShapeLayer - provides extensive customization options: path, stroke, fill, shadow CABasicAnimation - helps animate color or change the path Implementation First Step The first step is to create a shape layer that will draw an arrow using CAShapeLayer.\nprivate lazy var arrowShapeLayer: CAShapeLayer = { let arrowShapeLayer = CAShapeLayer() arrowShapeLayer.strokeColor = direction.arrowColour.cgColor arrowShapeLayer.lineWidth = ArrowView.arrowLineWidth arrowShapeLayer.lineCap = .round arrowShapeLayer.fillColor = UIColor.clear.cgColor return arrowShapeLayer }() Second Step The second step is to animate the arrow direction by changing the shape layer\u0026rsquo;s path and stroke color.\nvar direction: Direction = .up { didSet { guard oldValue != direction else { return } let pathAnimation = CABasicAnimation(keyPath: \u0026#34;path\u0026#34;) pathAnimation.fromValue = arrowShapeLayer.presentation()?.path pathAnimation.duration = 0.5 arrowShapeLayer.add(pathAnimation, forKey: \u0026#34;pathAnimation\u0026#34;) let strokeColourAnimation = CABasicAnimation(keyPath: \u0026#34;strokeColor\u0026#34;) strokeColourAnimation.fromValue = arrowShapeLayer.presentation()?.strokeColor strokeColourAnimation.duration = 0.5 arrowShapeLayer.add(strokeColourAnimation, forKey: \u0026#34;strokeColourAnimation\u0026#34;) arrowShapeLayer.path = direction.arrowPath(in: bounds).cgPath arrowShapeLayer.strokeColor = direction.arrowColour.cgColor } } Third Step The third step is to synchronize Core Animation with UIKit animation by requesting the CAAction property.\nvar direction: Direction = .up { didSet { guard oldValue != direction else { return } if let backgroundColourAnimation = action(for: layer, forKey: \u0026#34;backgroundColor\u0026#34;) as? CABasicAnimation { let pathAnimation = backgroundColourAnimation.copy(forKeyPath: \u0026#34;path\u0026#34;) pathAnimation.fromValue = arrowShapeLayer.presentation()?.path arrowShapeLayer.add(pathAnimation, forKey: \u0026#34;pathAnimation\u0026#34;) let strokeColourAnimation = backgroundColourAnimation.copy(forKeyPath: \u0026#34;strokeColor\u0026#34;) strokeColourAnimation.fromValue = arrowShapeLayer.presentation()?.strokeColor arrowShapeLayer.add(strokeColourAnimation, forKey: \u0026#34;strokeColourAnimation\u0026#34;) } arrowShapeLayer.path = direction.arrowPath(in: bounds).cgPath arrowShapeLayer.strokeColor = direction.arrowColour.cgColor } } Resources If you are curious, I would recommend you read a more detailed explanation from Darjeeling Steve\u0026rsquo;s blog. I found this resource incredible and full of comprehensive information.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/animation-uikit/","summary":"Introduction I was curious about creating animations in UIKit. I wanted to animate different properties such as color and path. Here is what I found:\nIt‚Äôs impossible to create complex animations only by using the block-based animation API. To do that, you need the Core Animation API and CAPropertyAnimation with its various subclasses.\nComplex animation in UIKit is based on a few key components:\nCAShapeLayer - provides extensive customization options: path, stroke, fill, shadow CABasicAnimation - helps animate color or change the path Implementation First Step The first step is to create a shape layer that will draw an arrow using CAShapeLayer.","title":"Animation - UIKit"},{"content":"Introduction I was eager to learn about creating complex animations in SwiftUI. The few questions that were on my mind included what types of animations exist and what I can animate. Here is what I found:\nTypes of Animation SwiftUI has explicit and implicit animation types.\nImplicit Animation: This is specified with the .animation() modifier. SwiftUI will animate changes in old and new values.\nstruct ImplicitAnimation: View { @State private var half = false @State private var dim = false var body: some View { Image(\u0026#34;tower\u0026#34;) .scaleEffect(half ? 0.5 : 1.0) .opacity(dim ? 0.2 : 1.0) .animation(.easeInOut(duration: 1.0)) .onTapGesture { self.dim.toggle() self.half.toggle() } } } Explicit Animation: This is specified with the withAnimation closure. Only those parameters that depend on a value changed inside the withAnimation closure will be animated.\nstruct ExplicitAnimation: View { @State private var half = false @State private var dim = false var body: some View { Image(\u0026#34;tower\u0026#34;) .scaleEffect(half ? 0.5 : 1.0) .opacity(dim ? 0.5 : 1.0) .onTapGesture { self.half.toggle() withAnimation(.easeInOut(duration: 1.0)) { self.dim.toggle() } } } } What is Possible to Animate You can animate single parameters such as size, offset, color, scale, etc. You can conform to the Animatable protocol and describe how to animate a property of a view. You can also animate multiple parameters with AnimatablePair. Resources An invaluable resource is The SwiftUI Lab, which has more than 5 posts only about animation in SwiftUI.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/animation-swiftui/","summary":"Introduction I was eager to learn about creating complex animations in SwiftUI. The few questions that were on my mind included what types of animations exist and what I can animate. Here is what I found:\nTypes of Animation SwiftUI has explicit and implicit animation types.\nImplicit Animation: This is specified with the .animation() modifier. SwiftUI will animate changes in old and new values.\nstruct ImplicitAnimation: View { @State private var half = false @State private var dim = false var body: some View { Image(\u0026#34;tower\u0026#34;) .","title":"Animation - SwiftUI"},{"content":"Introduction I previously never had a chance to work with GraphQL. I was excited to learn when to apply this technology, what tools I can use, and how I can implement it. Here‚Äôs what I found:\nFor testing, I used the Star Wars GraphQL API with AllFilmsQuery:\nquery AllFilmsQuery { allFilms { films { title director created producers releaseDate } } } I requested allFilms with title, director, created, producers, and releaseDate information.\nWhen to Apply This Technology The best way to use GraphQL is when you have multiple platform applications such as web, mobile, and TV, and each client needs to request the specific data they require. It\u0026rsquo;s also beneficial when you need to fetch complex, nested, or related data from multiple sources. What Tools to Use GraphiQL Live Demo - A graphical interactive in-browser GraphQL IDE. Apollo iOS Docs - Apollo iOS is an open-source GraphQL client for native client applications, written in Swift. Apollo iOS Code Generation CLI - A CLI to generate boilerplate code. Caveats Before diving into implementation, I would like to highlight a few nuances.\nYou need to add NetworkInterceptorProvider and AuthorizationInterceptor to authenticate your operations. Without them, you won\u0026rsquo;t be able to access the data on your server.\nHow to Implement It Client class NetworkInterceptorProvider: DefaultInterceptorProvider { override func interceptors\u0026lt;Operation\u0026gt;(for operation: Operation) -\u0026gt; [ApolloInterceptor] where Operation : GraphQLOperation { var interceptors = super.interceptors(for: operation) interceptors.insert(AuthorizationInterceptor(), at: 0) return interceptors } } class AuthorizationInterceptor: ApolloInterceptor { let id: String = UUID().uuidString func interceptAsync\u0026lt;Operation\u0026gt;( chain: RequestChain, request: HTTPRequest\u0026lt;Operation\u0026gt;, response: HTTPResponse\u0026lt;Operation\u0026gt;?, completion: @escaping (Result\u0026lt;GraphQLResult\u0026lt;Operation.Data\u0026gt;, Error\u0026gt;) -\u0026gt; Void ) where Operation : GraphQLOperation { chain.proceedAsync(request: request, response: response, completion: completion) } } private let apollo: ApolloClient = { let client = URLSessionClient() let cache = InMemoryNormalizedCache() let store = ApolloStore(cache: cache) let provider = NetworkInterceptorProvider(client: client, store: store) let url = URL(string: \u0026#34;https://swapi-graphql.netlify.app/.netlify/functions/index\u0026#34;)! let transport = RequestChainNetworkTransport(interceptorProvider: provider, endpointURL: url) return ApolloClient(networkTransport: transport, store: store) }() UI import SwiftUI import Apollo import StarWarsAPI struct ContentView: View { @State private var list: [AllFilmsQuery.Data.AllFilms.Film?] = [] var body: some View { VStack { ForEach(list, id: \\.self) { row in Text(row?.title ?? \u0026#34;\u0026#34;) } }.onAppear(perform: { apollo.fetch(query: AllFilmsQuery()) { result in switch result { case .success(let response): self.list = response.data?.allFilms?.films ?? [] case .failure(let error): print(error) } } }) .padding() } } #Preview { ContentView() } References You can find more detailed information in the amazing post Unleashing the Power of GraphQL in Your iOS App where you can find step-by-step instructions on how to use Apollo iOS and GraphQL. I also recommend watching the video ‚ÄúAdopting GraphQL\u0026quot; by Carola Nitz, hosted by Swiftable. Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/implementing-graphql-in-an-ios-application/","summary":"Introduction I previously never had a chance to work with GraphQL. I was excited to learn when to apply this technology, what tools I can use, and how I can implement it. Here‚Äôs what I found:\nFor testing, I used the Star Wars GraphQL API with AllFilmsQuery:\nquery AllFilmsQuery { allFilms { films { title director created producers releaseDate } } } I requested allFilms with title, director, created, producers, and releaseDate information.","title":"Implementing GraphQL in an iOS application"},{"content":"Introduction I was eager to learn about securing user data using Keychain and biometric authentication. Here are a few steps I found:\nCaveats You can test accessing Keychain data using Touch ID and Face ID only on a real device.\nFirst Step The first step is to add the Privacy - Face ID Usage Description key to your Info.plist. Without it, you would not be able to retrieve data from Keychain using Face ID.\nSecond Step The second step would be to add the addCredentials method to be able to save user data to Keychain.\n/// Stores credentials for the given server. func addCredentials(_ credentials: Credentials, server: String) throws { // Use the username as the account, and get the password as data. let account = credentials.username let password = credentials.password.data(using: String.Encoding.utf8)! // Create an access control instance that dictates how the item can be read later. let access = SecAccessControlCreateWithFlags(nil, // Use the default allocator. kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly, .userPresence, nil) // Ignore any error. // Allow a device unlock in the last 10 seconds to be used to get at keychain items. let context = LAContext() context.touchIDAuthenticationAllowableReuseDuration = 10 // Build the query for use in the add operation. let query: [String: Any] = [kSecClass as String: kSecClassInternetPassword, kSecAttrAccount as String: account, kSecAttrServer as String: server, kSecAttrAccessControl as String: access as Any, kSecUseAuthenticationContext as String: context, kSecValueData as String: password] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { throw KeychainError(status: status) } } Third Step The third step is to add the readCredentials method to be capable of retrieving user data from Keychain.\n/// Reads the stored credentials for the given server. func readCredentials(server: String) throws -\u0026gt; Credentials { let context = LAContext() context.localizedReason = \u0026#34;Access your password on the keychain\u0026#34; let query: [String: Any] = [kSecClass as String: kSecClassInternetPassword, kSecAttrServer as String: server, kSecMatchLimit as String: kSecMatchLimitOne, kSecReturnAttributes as String: true, kSecUseAuthenticationContext as String: context, kSecReturnData as String: true] var item: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, \u0026amp;item) guard status == errSecSuccess else { throw KeychainError(status: status) } guard let existingItem = item as? [String: Any], let passwordData = existingItem[kSecValueData as String] as? Data, let password = String(data: passwordData, encoding: String.Encoding.utf8), let account = existingItem[kSecAttrAccount as String] as? String else { throw KeychainError(status: errSecInternalError) } return Credentials(username: account, password: password) } Fourth Step The fourth step is to add the deleteCredentials method to have the ability to delete user data from Keychain.\n/// Deletes credentials for the given server. func deleteCredentials(server: String) throws { let query: [String: Any] = [kSecClass as String: kSecClassInternetPassword, kSecAttrServer as String: server] let status = SecItemDelete(query as CFDictionary) guard status == errSecSuccess else { throw KeychainError(status: status) } } UI import SwiftUI import LocalAuthentication struct ContentView: View { @State private var status: String = \u0026#34;\u0026#34; var body: some View { VStack { ForEach(Command.allCases) { command in Button(command.rawValue) { switch command { case .add: // Normally, username and password would come from the user interface. let credentials = Credentials(username: \u0026#34;appleseed\u0026#34;, password: \u0026#34;1234\u0026#34;) do { try addCredentials(credentials, server: server) status = statusMessage(.add, nil) } catch { status = error.localizedDescription } case .read: do { status = statusMessage(.read, try readCredentials(server: server)) } catch { status = error.localizedDescription } case .delete: do { try deleteCredentials(server: server) status = statusMessage(.delete, nil) } catch { status = error.localizedDescription } } } if command != .delete { Spacer() } } Spacer() Text(status) } } } Helpers enum Command: String, CaseIterable, Identifiable { var id: String { rawValue } case add case read case delete } /// The username and password that we want to store or read. struct Credentials { var username: String var password: String } /// Keychain errors we might encounter. struct KeychainError: Error { var status: OSStatus var localizedDescription: String { return SecCopyErrorMessageString(status, nil) as String? ?? \u0026#34;Unknown error.\u0026#34; } } /// The server we are accessing with the credentials. let server = \u0026#34;www.example.com\u0026#34; func statusMessage(_ command: Command, _ credentials: Credentials? = nil) -\u0026gt; String { switch command { case .add: return \u0026#34;Added credentials.\u0026#34; case .read: return \u0026#34;Read credentials: \\(credentials!.username)/\\(credentials!.password)\u0026#34; case .delete: return \u0026#34;Deleted credentials.\u0026#34; } } You can find more detailed information and project details in the Apple Developer Documentation.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/securing-user-data-with-keychain-touch-id-and-face-id/","summary":"Introduction I was eager to learn about securing user data using Keychain and biometric authentication. Here are a few steps I found:\nCaveats You can test accessing Keychain data using Touch ID and Face ID only on a real device.\nFirst Step The first step is to add the Privacy - Face ID Usage Description key to your Info.plist. Without it, you would not be able to retrieve data from Keychain using Face ID.","title":"Securing user data with Keychain, Touch ID, and Face ID"},{"content":"Introduction I was wondering how to add in-app purchases to my app. I chose non-consumable in-app purchase because you can pay one time for this item. Here are a few steps on how I did it.\nFirst Step Set up In-App Purchases for your app in App Store Connect account or add a .storekit configuration file and start from there. If you\u0026rsquo;ve already set up In-App Purchases in your account, you can sync the StoreKit config with that data.\nCaveats Be aware that if you choose to set up the StoreKit configuration file first, you will not find that file in the Xcode 15.3.0 iOS template. Instead, switch to macOS and search for it there.\nSecond Step fetchProducts by identifiers to retrieve data and by using an SKProductsRequestDelegate to receive and display products.\nfunc fetchProducts() { let productIDs: Set\u0026lt;String\u0026gt; = [\u0026#34;com.remove.ads.nonconsumable\u0026#34;] let request = SKProductsRequest(productIdentifiers: productIDs) request.delegate = self request.start() } // MARK: - SKProductsRequestDelegate extension ViewModel: SKProductsRequestDelegate { func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) { DispatchQueue.main.async { self.products = response.products.map { product in Product(id: product.productIdentifier, title: product.localizedTitle, price: product.price.doubleValue) } for product in response.products { self.productsMap[product.productIdentifier] = product } } } } Third Step Add a purchaseProduct method and connect the view model with the UI.\nfunc purchaseProduct(product: Product) { guard SKPaymentQueue.canMakePayments() else { errorMessage = \u0026#34;In-app purchases are disabled on this device.\u0026#34; return } guard let skProduct = productsMap[product.id] else { errorMessage = \u0026#34;Product information not available.\u0026#34; return } let payment = SKPayment(product: skProduct) SKPaymentQueue.default().add(payment) } UI var body: some View { ZStack(alignment: .top) { VStack(spacing: 10) { Text(\u0026#34;With StoreKit 2\u0026#34;) .padding() ForEach(viewModel.products) { product in Button { viewModel.purchaseProduct(product: product) } label: { Text(product.title) } } } .padding() } .onAppear(perform: { viewModel.fetchProducts() }) } ViewModel final class ViewModel: NSObject, ObservableObject { @Published var products: [Product] = [] private var productsMap: [String: SKProduct] = [:] @Published var errorMessage: String? func fetchProducts() { let productIDs: Set\u0026lt;String\u0026gt; = [\u0026#34;com.remove.ads.nonconsumable\u0026#34;] let request = SKProductsRequest(productIdentifiers: productIDs) request.delegate = self request.start() } func purchaseProduct(product: Product) { guard SKPaymentQueue.canMakePayments() else { errorMessage = \u0026#34;In-app purchases are disabled on this device.\u0026#34; return } guard let skProduct = productsMap[product.id] else { errorMessage = \u0026#34;Product information not available.\u0026#34; return } let payment = SKPayment(product: skProduct) SKPaymentQueue.default().add(payment) } } // MARK: - SKProductsRequestDelegate extension ViewModel: SKProductsRequestDelegate { func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) { DispatchQueue.main.async { self.products = response.products.map { product in Product(id: product.productIdentifier, title: product.localizedTitle, price: product.price.doubleValue) } for product in response.products { self.productsMap[product.productIdentifier] = product } } } } Helpers struct Product: Identifiable { let id: String let title: String let price: Double } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/implementing-in-app-purchases-to-swiftui-app-using-storekit-2/","summary":"Introduction I was wondering how to add in-app purchases to my app. I chose non-consumable in-app purchase because you can pay one time for this item. Here are a few steps on how I did it.\nFirst Step Set up In-App Purchases for your app in App Store Connect account or add a .storekit configuration file and start from there. If you\u0026rsquo;ve already set up In-App Purchases in your account, you can sync the StoreKit config with that data.","title":"Implementing In-App Purchases to SwiftUI app using StoreKit 2"},{"content":"Introduction Sometime ago, I was working on a marketplace app, and I needed to add Apple Pay to make purchases more easily. Here are a few steps on how I did it: First Step You need to add Apple Pay capability to your project. You will need to Register a Merchant ID. I will skip this step; you can find info by following this link Setting up Apple Pay. Second Step You will need to import PassKit and create PKPaymentRequest to interact with PKPaymentAuthorizationController and PKPaymentAuthorizationControllerDelegate. func initiateApplePay() { // Create payment request let paymentRequest = PKPaymentRequest() paymentRequest.merchantIdentifier = \u0026#34;your_merchant_identifier\u0026#34; paymentRequest.countryCode = \u0026#34;US\u0026#34; paymentRequest.currencyCode = \u0026#34;USD\u0026#34; paymentRequest.supportedNetworks = [.visa, .masterCard, .amex] paymentRequest.merchantCapabilities = .threeDSecure // Add payment items from cart for item in cartItems { let paymentItem = PKPaymentSummaryItem(label: item.name, amount: item.price) paymentRequest.paymentSummaryItems.append(paymentItem) } // Add total amount let totalItem = PKPaymentSummaryItem(label: \u0026#34;Total\u0026#34;, amount: totalAmount) paymentRequest.paymentSummaryItems.append(totalItem) // Present Apple Pay sheet let paymentController = PKPaymentAuthorizationController(paymentRequest: paymentRequest) paymentController.delegate = self paymentController.present(completion: nil) } Third Step Add UI and connect it with the view model.\nUI import SwiftUI struct ContentView: View { @StateObject private var viewModel = MarketplaceViewModel() var body: some View { VStack { List(viewModel.products) { product in HStack { Text(product.name) Spacer() Text(product.price.stringValue + \u0026#34;$\u0026#34;) Button(viewModel.inCart(product: product) ? \u0026#34;\u0026#34; : \u0026#34;Add to cart\u0026#34;) { viewModel.addToCart(product: product) } } } Text(\u0026#34;Total: \\(viewModel.totalAmount)\u0026#34;) Button(\u0026#34;Pay with Apple Pay\u0026#34;) { viewModel.initiateApplePay() } .padding() } } } #Preview { ContentView() } ViewModel final class MarketplaceViewModel: NSObject, ObservableObject { private var cartItems: [Product] = [] @Published private(set) var totalAmount: NSDecimalNumber = 0.0 @Published private(set) var products: [Product] = [] func fetchProducts() { Task { self.products = await ProductService.getProducts() } } func inCart(product: Product) -\u0026gt; Bool { cartItems.contains(product) } override init() { super.init() fetchProducts() } private func calculateTotalAmount() { totalAmount = cartItems.reduce(0) { $0.adding($1.price) } } func addToCart(product: Product) { cartItems.append(product) calculateTotalAmount() } func initiateApplePay() { // Create payment request let paymentRequest = PKPaymentRequest() paymentRequest.merchantIdentifier = \u0026#34;your_merchant_identifier\u0026#34; paymentRequest.countryCode = \u0026#34;US\u0026#34; paymentRequest.currencyCode = \u0026#34;USD\u0026#34; paymentRequest.supportedNetworks = [.visa, .masterCard, .amex] paymentRequest.merchantCapabilities = .threeDSecure // Add payment items from cart for item in cartItems { let paymentItem = PKPaymentSummaryItem(label: item.name, amount: item.price) paymentRequest.paymentSummaryItems.append(paymentItem) } // Add total amount let totalItem = PKPaymentSummaryItem(label: \u0026#34;Total\u0026#34;, amount: totalAmount) paymentRequest.paymentSummaryItems.append(totalItem) // Present Apple Pay sheet let paymentController = PKPaymentAuthorizationController(paymentRequest: paymentRequest) paymentController.delegate = self paymentController.present(completion: nil) } } // MARK: - PKPaymentAuthorizationControllerDelegate extension MarketplaceViewModel: PKPaymentAuthorizationControllerDelegate { func paymentAuthorizationController(_ controller: PKPaymentAuthorizationController, didAuthorizePayment payment: PKPayment, handler completion: @escaping (PKPaymentAuthorizationResult) -\u0026gt; Void) { let paymentResult = PKPaymentAuthorizationResult(status: .success, errors: nil) completion(paymentResult) } func paymentAuthorizationControllerDidFinish(_ controller: PKPaymentAuthorizationController) { controller.dismiss(completion: nil) } } Helpers struct Product: Identifiable, Equatable { let id: UUID let name: String let price: NSDecimalNumber } final class ProductService { static func getProducts() async -\u0026gt; [Product] { let products: [Product] = [ Product(id: UUID(), name: \u0026#34;Product 1\u0026#34;, price: 10.0), Product(id: UUID(), name: \u0026#34;Product 2\u0026#34;, price: 20.0), Product(id: UUID(), name: \u0026#34;Product 3\u0026#34;, price: 15.0) ] return products } } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/implementing-apple-pay-in-a-swiftui-app/","summary":"Introduction Sometime ago, I was working on a marketplace app, and I needed to add Apple Pay to make purchases more easily. Here are a few steps on how I did it: First Step You need to add Apple Pay capability to your project. You will need to Register a Merchant ID. I will skip this step; you can find info by following this link Setting up Apple Pay. Second Step You will need to import PassKit and create PKPaymentRequest to interact with PKPaymentAuthorizationController and PKPaymentAuthorizationControllerDelegate.","title":"Implementing Apple Pay in a SwiftUI app"},{"content":"Introduction I have been looking for information about implementation details of integration testing. I found a lot of information, but it was theoretical and all information looked the same. I did not find a meaningful example, so I tried to come up with my own definition and sample.\nIntegration testing means testing the behavior between modules or views to ensure they work as expected after user actions.\nThere are two ways of conducting integration testing: The first is by unit tests, where you try to test the flowing data between view models. The second is UI tests, where you try to test if the UI items exist and navigation works correctly. I will focus on testing the flowing data between view models.\nSample: List View and Detail View When you tap on a row in the list, you expect that:\nThe selected item will pass to the detail view. The detail view will receive this item. The selected item will be equal to the passed item. import XCTest @testable import IntegrationTesting final class IntegrationTestingTests: XCTestCase { func testItemSelection() { let viewModel = MockItemListViewModel(service: MockItemService()) let selectedIndex = 1 let itemListView = ItemListView(viewModel: viewModel, didSelectItem: { let itemDetailView = ItemDetailView(selectedItem: $0) XCTAssertEqual(itemDetailView.selectedItem?.name, viewModel.items[selectedIndex].name) }) itemListView.didSelectItem(viewModel.items[selectedIndex]) } } Helpers import Combine final class MockItemListViewModel: ItemListViewModel { var selectedItem: Item? = nil } class ItemListViewModel: ObservableObject { @Published var items: [Item] = [] private var cancellables: Set\u0026lt;AnyCancellable\u0026gt; = [] private let service: ItemService init(service: ItemService) { self.service = service fetchItems() } func fetchItems() { service.fetchItems() .sink { completion in // Handle error or completion if necessary } receiveValue: { [weak self] items in self?.items = items } .store(in: \u0026amp;cancellables) } } import Combine protocol ItemService { func fetchItems() -\u0026gt; AnyPublisher\u0026lt;[Item], Error\u0026gt; } final class MockItemService: ItemService { func fetchItems() -\u0026gt; AnyPublisher\u0026lt;[Item], Error\u0026gt; { return Just([Item(name: \u0026#34;Item 1\u0026#34;), Item(name: \u0026#34;Item 2\u0026#34;)]) .setFailureType(to: Error.self) .eraseToAnyPublisher() } } import SwiftUI struct ItemListView: View { @ObservedObject var viewModel: ItemListViewModel var didSelectItem: (Item) -\u0026gt; Void var body: some View { List(viewModel.items) { item in Button(action: { didSelectItem(item) }) { Text(item.name) } }.accessibilityIdentifier(\u0026#34;ItemListView\u0026#34;) } } import SwiftUI struct ItemDetailView: View { var selectedItem: Item? var body: some View { if let item = selectedItem { Text(\u0026#34;Item Detail: \\(item.name)\u0026#34;) } else { Text(\u0026#34;No item selected\u0026#34;) } } } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/integration-testing-for-swiftui-views/","summary":"Introduction I have been looking for information about implementation details of integration testing. I found a lot of information, but it was theoretical and all information looked the same. I did not find a meaningful example, so I tried to come up with my own definition and sample.\nIntegration testing means testing the behavior between modules or views to ensure they work as expected after user actions.\nThere are two ways of conducting integration testing: The first is by unit tests, where you try to test the flowing data between view models.","title":"Integration testing for SwiftUI views"},{"content":"Introduction After spending some time developing my personal iOS app, I found myself in a position where I needed to add UI tests to my application. The reason behind this decision was the necessity to change the architecture to make it more scalable. However, this task proved to be challenging due to certain parts of the code being tightly coupled. The situation was quite frustrating. To address this problem, I decided to incorporate UI tests that could help identify issues during the refactoring process.\nCaveats Make sure to run UI tests from a generated bundle specifically designed for UI testing. If you attempt to test the UI using a bundle intended for Unit tests, you will consistently encounter the error: No target application path specified via test configuration: \u0026lt;XCTestConfiguration: 0x102b051f0\u0026gt;. Also, don\u0026rsquo;t forget to hide the keyboard when necessary. If you need to tap on the tab bar and forget to close it, the operation will not succeed because it won\u0026rsquo;t be able to locate the tab bar button. To resolve this, simply add the following code: app.buttons[\u0026#34;Return\u0026#34;].tap() Implementation Here\u0026rsquo;s an example of a To-Do list with functionalities for listing and adding tasks.\nUI Tests var app: XCUIApplication! override func setUpWithError() throws { continueAfterFailure = false app = XCUIApplication() app.launch() } func testAddTask() throws { let addTaskTab = app.tabBars.buttons[\u0026#34;Add Task\u0026#34;] addTaskTab.tap() let textField = app.textFields[\u0026#34;Enter task\u0026#34;] textField.tap() textField.typeText(\u0026#34;New Task\u0026#34;) // Dismiss the keyboard app.buttons[\u0026#34;Return\u0026#34;].tap() let addTaskButton = app.buttons[\u0026#34;AddTaskButton\u0026#34;] addTaskButton.tap() app.tabBars.buttons[\u0026#34;Tasks\u0026#34;].tap() XCTAssertTrue(app.staticTexts[\u0026#34;New Task\u0026#34;].exists) } UI struct ContentView: View { @StateObject var viewModel = TaskViewModel() var body: some View { TabView { TaskListView(viewModel: viewModel) .tabItem { Image(systemName: \u0026#34;list.bullet\u0026#34;) Text(\u0026#34;Tasks\u0026#34;) } AddTaskView(viewModel: viewModel) .tabItem { Image(systemName: \u0026#34;plus.circle\u0026#34;) Text(\u0026#34;Add Task\u0026#34;) } } } } struct TaskListView: View { @ObservedObject var viewModel: TaskViewModel var body: some View { NavigationView { List(viewModel.tasks) { task in Text(task.title) } .navigationBarTitle(\u0026#34;Tasks\u0026#34;) } } } struct AddTaskView: View { @ObservedObject var viewModel: TaskViewModel @State private var newTaskTitle = \u0026#34;\u0026#34; var body: some View { VStack { TextField(\u0026#34;Enter task\u0026#34;, text: $newTaskTitle) .padding() Button(\u0026#34;Add Task\u0026#34;) { viewModel.addTask(title: newTaskTitle) newTaskTitle = \u0026#34;\u0026#34; } .accessibilityIdentifier(\u0026#34;AddTaskButton\u0026#34;) .padding() } .navigationTitle(\u0026#34;Add Task\u0026#34;) } } final class TaskViewModel: ObservableObject { @Published var tasks: [Task] = [] func addTask(title: String) { let newTask = Task(title: title) tasks.append(newTask) } } struct Task: Identifiable { let id = UUID() var title: String var isCompleted: Bool = false } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/ui-testing-swiftui-views-using-xctest-framework/","summary":"Introduction After spending some time developing my personal iOS app, I found myself in a position where I needed to add UI tests to my application. The reason behind this decision was the necessity to change the architecture to make it more scalable. However, this task proved to be challenging due to certain parts of the code being tightly coupled. The situation was quite frustrating. To address this problem, I decided to incorporate UI tests that could help identify issues during the refactoring process.","title":"UI testing SwiftUI views using XCTest Framework"},{"content":"Introduction I was curious about how to add Dynamic Island and implement it into a Video Streaming App. Here are a few steps on how you can achieve this.\nCaveats Debugging Dynamic Island can be a bit tricky; it only works when the main app is running. If you try to run it separately, you will encounter the error SendProcessControlEvent:toPid: encountered an error: Error Domain=com.apple.dt.deviceprocesscontrolservice Code=8 \u0026quot;Failed to show Widget\u0026quot;. The solution is to configure live activities and run them through the main app. Be aware that when you add a widget to the project, in some cases, it adds all main target files to Compile Sources. Implementation Dynamic Islands are divided into different sizes: minimal, compactTrailing, compactLeading, and expanded. Before proceeding, you need to add LiveActivityManager to be able to display Dynamic Islands.\nimport Foundation import ActivityKit struct VideoStreamingWidgetActivityAttributes: ActivityAttributes { struct ContentState: Codable, Hashable { var isPlaying: String = \u0026#34;0\u0026#34; } } final class LiveActivityManager { @discardableResult static func startActivity(isPlaying: String) throws -\u0026gt; String { var activity: Activity\u0026lt;VideoStreamingWidgetActivityAttributes\u0026gt;? let initialState = VideoStreamingWidgetActivityAttributes.ContentState(isPlaying: isPlaying) do { activity = try Activity.request(attributes: VideoStreamingWidgetActivityAttributes(), contentState: initialState, pushType: nil) guard let id = activity?.id else { throw LiveActivityErrorType.failedToGetID } return id } catch { throw error } } } enum LiveActivityErrorType: Error { case failedToGetID } UI compactTrailing compactTrailing: { Text(\u0026#34;0:33\u0026#34;) .foregroundColor(.red) .padding(.trailing, 8) } compactLeading compactLeading: { Image(systemName: \u0026#34;waveform\u0026#34;) .resizable() .aspectRatio(contentMode: .fit) .foregroundColor(.red) .padding(.leading, 8) } expanded DynamicIsland { DynamicIslandExpandedRegion(.center) { HStack { Text(\u0026#34;0:33\u0026#34;) .foregroundStyle(.gray) .frame(height: 4) ProgressView(value: 33, total: 344) .progressViewStyle(.linear) Text(\u0026#34;-2:33\u0026#34;) .foregroundStyle(.gray) .frame(height: 4) } } DynamicIslandExpandedRegion(.bottom) { HStack(spacing: 24) { ForEach(Command.allCases) { command in Button(intent: ButtonIntent(id: command.id)) { Image(systemName: imageSystemName(isPlaying: true, command: command)) } } } } } Helpers enum Command: String, CaseIterable { case previous case playPause case next } extension Command: Identifiable { var id: String { rawValue } } func imageSystemName(isPlaying: Bool, command: Command) -\u0026gt; String { switch command { case .playPause: if isPlaying { return \u0026#34;pause.fill\u0026#34; } else { return \u0026#34;play.fill\u0026#34; } case .next: return \u0026#34;forward.fill\u0026#34; case .previous: return \u0026#34;backward.fill\u0026#34; } } import AppIntents struct ButtonIntent: AppIntent { static let title: LocalizedStringResource = \u0026#34;ButtonIntent\u0026#34; @Parameter(title: \u0026#34;id\u0026#34;) var id: String init(id: String) { self.id = id } init() {} func perform() async throws -\u0026gt; some IntentResult { if id == Command.playPause.rawValue { } return .result() } } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/building-dynamic-island-for-video-streaming-app/","summary":"Introduction I was curious about how to add Dynamic Island and implement it into a Video Streaming App. Here are a few steps on how you can achieve this.\nCaveats Debugging Dynamic Island can be a bit tricky; it only works when the main app is running. If you try to run it separately, you will encounter the error SendProcessControlEvent:toPid: encountered an error: Error Domain=com.apple.dt.deviceprocesscontrolservice Code=8 \u0026quot;Failed to show Widget\u0026quot;. The solution is to configure live activities and run them through the main app.","title":"Building Dynamic Island for Video Streaming App"},{"content":"Introduction I was exploring the idea of creating a YouTube-like widget for the lock screen on iOS devices. It wasn\u0026rsquo;t easy because most articles on the Internet discussed general implementations, such as for a coffee shop or a to-do list. Even when I found some similar versions, the project wouldn\u0026rsquo;t compile. I made the decision to approach it my way, so here\u0026rsquo;s what I found out:\nCaveats After being stuck for two or more hours without understanding why, after tapping on a button, I wasn't able to receive a callback from it and the widget always opened the main iOS app, I realized that I forgot to add AppIntent - without it, you can\u0026rsquo;t handle actions for iOS 17. import AppIntents struct ButtonIntent: AppIntent { static let title: LocalizedStringResource = \u0026#34;ButtonIntent\u0026#34; @Parameter(title: \u0026#34;id\u0026#34;) var id: String func perform() async throws -\u0026gt; some IntentResult { if id == Command.playPause.rawValue { DataModel.shared.isPlaying.toggle() } return .result() } } Another crucial point is not to forget to add an explicit init. If you don\u0026rsquo;t implement it explicitly, it will not work. import AppIntents struct ButtonIntent: AppIntent { static let title: LocalizedStringResource = \u0026#34;ButtonIntent\u0026#34; @Parameter(title: \u0026#34;id\u0026#34;) var id: String init(id: String) { self.id = id } init() {} func perform() async throws -\u0026gt; some IntentResult { if id == Command.playPause.rawValue { DataModel.shared.isPlaying.toggle() } return .result() } } Lastly, I attempted to add a Slider, but I found that it\u0026rsquo;s not supported by the widget. My solution was to choose a ProgressView instead. Implementation struct YouTubeLockScreenWidget: View { var body: some View { VStack { Spacer() ProgressView(value: DataModel.shared.currentTime, total: DataModel.shared.totalTime) .progressViewStyle(.linear) Spacer() HStack { ForEach(Command.allCases) { command in Button(intent: ButtonIntent(id: command.id)) { Image(systemName: imageSystemName(isPlaying: DataModel.shared.isPlaying, command: command)) } } } } } } final class DataModel { static let shared = DataModel() var isPlaying: Bool = false var currentTime: TimeInterval = 34 var totalTime: TimeInterval = 304 } enum Command: String, CaseIterable { case previous case playPause case next } extension Command: Identifiable { var id: String { rawValue } } func imageSystemName(isPlaying: Bool, command: Command) -\u0026gt; String { switch command { case .playPause: if isPlaying { return \u0026#34;pause.fill\u0026#34; } else { return \u0026#34;play.fill\u0026#34; } case .next: return \u0026#34;forward.fill\u0026#34; case .previous: return \u0026#34;backward.fill\u0026#34; } } I had not replaced default generated code when I was adding widget to the project. I just added YouTubeLockScreenWidget to generated VideoStreamingWidgetEntryView.\nstruct VideoStreamingWidgetEntryView : View { var entry: Provider.Entry var body: some View { YouTubeLockScreenWidget() } } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/building-video-streaming-widget-for-ios-app/","summary":"Introduction I was exploring the idea of creating a YouTube-like widget for the lock screen on iOS devices. It wasn\u0026rsquo;t easy because most articles on the Internet discussed general implementations, such as for a coffee shop or a to-do list. Even when I found some similar versions, the project wouldn\u0026rsquo;t compile. I made the decision to approach it my way, so here\u0026rsquo;s what I found out:\nCaveats After being stuck for two or more hours without understanding why, after tapping on a button, I wasn't able to receive a callback from it and the widget always opened the main iOS app, I realized that I forgot to add AppIntent - without it, you can\u0026rsquo;t handle actions for iOS 17.","title":"Building Video Streaming Widget for iOS App"},{"content":"Introduction I was looking for a way to add a video player to my iOS app that could be able to play remote videos.\nCaveats Problem I found that you can\u0026rsquo;t open Vimeo or Youtube videos because of AVFoundationErrorDomain Code=-11850 \u0026quot;Operation Stopped\u0026quot; UserInfo={NSLocalizedFailureReason=The server is not correctly configured Domain=NSOSStatusErrorDomain Code=-12939 error. I don‚Äôt know exactly what this means, but I\u0026rsquo;m speculating it\u0026rsquo;s related to some protection.\nSolution My solution was to find another video that is not related to those platforms.\nImplementation AVKit has a built-in video player called VideoPlayer. All you need to play a video is to pass AVPlayer with videoURL.\n@ViewBuilder var fullScreenVideoPlayer: some View { let avPlayer = AVPlayer(url: videoURL) VideoPlayer(player: avPlayer) .edgesIgnoringSafeArea(.all) .onAppear { avPlayer.play() } } I will dive a little deeper with widgets in the next chapters.\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/building-video-streaming-ios-app/","summary":"Introduction I was looking for a way to add a video player to my iOS app that could be able to play remote videos.\nCaveats Problem I found that you can\u0026rsquo;t open Vimeo or Youtube videos because of AVFoundationErrorDomain Code=-11850 \u0026quot;Operation Stopped\u0026quot; UserInfo={NSLocalizedFailureReason=The server is not correctly configured Domain=NSOSStatusErrorDomain Code=-12939 error. I don‚Äôt know exactly what this means, but I\u0026rsquo;m speculating it\u0026rsquo;s related to some protection.\nSolution My solution was to find another video that is not related to those platforms.","title":"Building Video Streaming iOS App"},{"content":"Introduction I never had a chance to work with WebSockets, so I decided to take a look and create a group chat. Here\u0026rsquo;s what I discovered:\nTo be able to send and receive messages, you need to create an interface for communication between a server and your application. In my case, I chose sendMessage and receiveMessage methods. For the server-side, I chose Node.js. For the iOS application, I chose the Socket.IO library. Implementation Let‚Äôs dive deeper into the implementation.\nFirst step The first step would be to create a server.js file to be able to handle incoming events.\nconst express = require(\u0026#39;express\u0026#39;); const app = express(); const server = require(\u0026#39;http\u0026#39;).Server(app); const io = require(\u0026#39;socket.io\u0026#39;)(server); const { randomUUID } = require(\u0026#39;crypto\u0026#39;); const users = new Map(); io.on(\u0026#39;connection\u0026#39;, (socket) =\u0026gt; { let username = socket.handshake.auth.username; console.log(\u0026#39;a user connected\u0026#39;); users.set(socket.id, username); io.emit(\u0026#39;receiveNewUser\u0026#39;, username, Object.fromEntries(users)); socket.on(\u0026#39;sendMessage\u0026#39;, (message) =\u0026gt; { const username = users.get(socket.id); io.emit(\u0026#39;receiveMessage\u0026#39;, randomUUID(), username, message); }); socket.on(\u0026#39;disconnect\u0026#39;, () =\u0026gt; { console.log(\u0026#39;user disconnected\u0026#39;); users.delete(socket.id); }); }); server.listen(3000, () =\u0026gt; { console.log(\u0026#39;listening on *:3000\u0026#39;); }); Second step The next step would be creating a ChatService that will be responsible for connect, disconnect, send, and receive data.\nimport SocketIO final class ChatService { private var manager: SocketManager! private var socket: SocketIOClient! private var username: String! init() { manager = SocketManager(socketURL: URL(string: \u0026#34;http://localhost:3000\u0026#34;)!) socket = manager.defaultSocket } func connect(username: String) { self.username = username socket.connect(withPayload: [\u0026#34;username\u0026#34;: username]) } func disconnect() { socket.disconnect() } func sendMessage(_ message: String) { socket.emit(\u0026#34;sendMessage\u0026#34;, message) } func sendUsername(_ username: String) { socket.emit(\u0026#34;sendUsername\u0026#34;, username) } func receiveMessage(_ completion: @escaping (String, String, UUID) -\u0026gt; Void) { socket.on(\u0026#34;receiveMessage\u0026#34;) { data, _ in if let text = data[2] as? String, let id = data[0] as? String, let username = data[1] as? String { completion(username, text, UUID.init(uuidString: id) ?? UUID()) } } } func receiveNewUser(_ completion: @escaping (String, [String:String]) -\u0026gt; Void) { socket.on(\u0026#34;receiveNewUser\u0026#34;) { data, _ in if let username = data[0] as? String, let users = data[1] as? [String:String] { completion(username, users) } } } } Third step The next step would be creating a ViewModel communicating with the ChatService.\nimport Foundation final class ViewModel: ObservableObject { private let chatService: ChatService = ChatService() @Published var message: String = \u0026#34;\u0026#34; @Published var messages: [Message] = [] @Published var username: String = \u0026#34;\u0026#34; @Published var users: [String:String] = [:] @Published var newUser: String = \u0026#34;\u0026#34; @Published var showUsernamePrompt: Bool = true @Published var isShowingNewUserAlert = false } extension ViewModel { func connect() { chatService.connect(username: username) chatService.receiveMessage { username, text, id in self.receiveMessage(username: username, text: text, id: id) } chatService.receiveNewUser { username, users in self.receiveNewUser(username: username, users: users) } showUsernamePrompt = false } func sendMessage() { chatService.sendMessage(message) message = \u0026#34;\u0026#34; } func receiveMessage(username: String, text: String, id: UUID) { messages.append(Message(username: username, text: text, id: id)) } func receiveNewUser(username: String, users: [String:String]) { self.users = users self.newUser = username self.isShowingNewUserAlert = self.username != username } func disconnect() { chatService.disconnect() message = \u0026#34;\u0026#34; messages = [] username = \u0026#34;\u0026#34; users = [:] newUser = \u0026#34;\u0026#34; showUsernamePrompt = true isShowingNewUserAlert = false } } Fourth step The last step would be creating UI and connecting it with the ViewModel.\nimport SwiftUI struct ChatView: View { @StateObject private var viewModel = ViewModel() var body: some View { NavigationView { VStack { if viewModel.showUsernamePrompt { HStack { TextField(\u0026#34;Enter your username\u0026#34;, text: $viewModel.username) .textFieldStyle(RoundedBorderTextFieldStyle()) Button(action: viewModel.connect) { Text(\u0026#34;Connect\u0026#34;) } } .padding() } else { List { ForEach(viewModel.messages, id: \\.self) { message in HStack { if message.username == viewModel.username { Text(\u0026#34;Me:\u0026#34;) .font(.subheadline) .foregroundColor(.blue) } else { Text(\u0026#34;\\(message.username):\u0026#34;) .font(.subheadline) .foregroundColor(.green) } Text(message.text) } } } HStack { TextField(\u0026#34;Enter a message\u0026#34;, text: $viewModel.message) .textFieldStyle(RoundedBorderTextFieldStyle()) HStack { Button(action: viewModel.sendMessage) { Text(\u0026#34;Send\u0026#34;) } Button(action: viewModel.disconnect) { Text(\u0026#34;Disconnect\u0026#34;) } } } .padding() } } .navigationBarTitle(\u0026#34;Group Chat \\(viewModel.users.count \u0026gt; 0 ? \u0026#34;(\\(viewModel.users.count) connected)\u0026#34; : \u0026#34;\u0026#34;)\u0026#34;) .navigationBarTitleDisplayMode(.inline) .alert(\u0026#34;\\(viewModel.newUser) just joined the chat!\u0026#34;, isPresented: $viewModel.isShowingNewUserAlert) { Button(\u0026#34;OK\u0026#34;, role: .cancel) { viewModel.isShowingNewUserAlert = false } } } } } #Preview { ChatView() } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/building-group-chat-using-websockets/","summary":"Introduction I never had a chance to work with WebSockets, so I decided to take a look and create a group chat. Here\u0026rsquo;s what I discovered:\nTo be able to send and receive messages, you need to create an interface for communication between a server and your application. In my case, I chose sendMessage and receiveMessage methods. For the server-side, I chose Node.js. For the iOS application, I chose the Socket.","title":"Building Group Chat using WebSockets"},{"content":"Introduction I find myself fascinated by the idea of creating an app for visionOS where I could possibly display 3D AirPods that I like. Here are a few steps on how you can do the same:\nFirst step The first step that you need to do is to create a visionOS project.\nSecond step The next step would be adding a 3D object to Reality Composer Pro and exporting it as a .usdz file. You can download free 3D objects here. All you need to do to download content is to register on this site.\nThird step The final step would be adding code to display the 3D object. To do that, we need to add Model3D. It helps asynchronously load and display a 3D model.\nimport SwiftUI import RealityKit import RealityKitContent struct AirPodsMaxAnimation: View { var body: some View { NavigationStack { VStack { Model3D(named: \u0026#34;Airpods_Max_Pink\u0026#34;) { model in model .resizable() .aspectRatio(contentMode: .fit) .scaleEffect(0.5) .phaseAnimator([false, true]) { AirPodsMax, threeDYRotate in AirPodsMax .rotation3DEffect(.degrees(threeDYRotate ? 0 : -360 * 5), axis: (x: 0, y: 1, z: 0)) } animation: { threeDYRotate in .linear(duration: 25).repeatForever(autoreverses: false) } } placeholder: { ProgressView() } } .navigationTitle(\u0026#34;Airpods Max Pink\u0026#34;) } } } #Preview(windowStyle: .automatic) { AirPodsMaxAnimation() } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/exploring-visionos/","summary":"Introduction I find myself fascinated by the idea of creating an app for visionOS where I could possibly display 3D AirPods that I like. Here are a few steps on how you can do the same:\nFirst step The first step that you need to do is to create a visionOS project.\nSecond step The next step would be adding a 3D object to Reality Composer Pro and exporting it as a .","title":"Exploring visionOS"},{"content":"Introduction I was searching for an AR implementation of a 3D guitar inside an iOS app. Here\u0026rsquo;s what I discovered:\nFirst Step The first step is not related to building the app. Before that you need to create a project using the Reality Composer Pro app (you can find it through Spotlight search).\nSecond Step After that, you need to visit https://developer.apple.com/augmented-reality/quick-look/ and download one of the USDZ files. In my case, I chose the 3D guitar.\nThird Step Now, you can start diving into AR implementation inside the iOS project:\nYou need to add the Privacy - Camera Usage Description key to be able to use the camera Put your_file_name.usdz into the iOS project Create an ARViewRepresentable struct ARViewRepresentable: UIViewRepresentable { func makeUIView(context: Context) -\u0026gt; some ARView { let arView = ARView(frame: .zero) return arView } func updateUIView(_ uiView: UIViewType, context: Context) { } } Load, and anchor the 3D model func makeUIView(context: Context) -\u0026gt; some ARView { let arView = ARView(frame: .zero) // Load 3D model guard let guitarModelURL = Bundle.main.url(forResource: \u0026#34;fender_stratocaster\u0026#34;, withExtension: \u0026#34;usdz\u0026#34;) else { fatalError(\u0026#34;Failed to load model file.\u0026#34;) } let guitarModel = try! Entity.load(contentsOf: guitarModelURL) // Anchor 3D model let anchorEntity = AnchorEntity(.plane(.horizontal, classification: .any, minimumBounds: .zero)) anchorEntity.addChild(guitarModel) return arView } and finally add it to arView.scene func makeUIView(context: Context) -\u0026gt; some ARView { let arView = ARView(frame: .zero) // Load 3D model guard let guitarModelURL = Bundle.main.url(forResource: \u0026#34;fender_stratocaster\u0026#34;, withExtension: \u0026#34;usdz\u0026#34;) else { fatalError(\u0026#34;Failed to load model file.\u0026#34;) } let guitarModel = try! Entity.load(contentsOf: guitarModelURL) // Anchor 3D model let anchorEntity = AnchorEntity(.plane(.horizontal, classification: .any, minimumBounds: .zero)) anchorEntity.addChild(guitarModel) // Add anchor to scene arView.scene.addAnchor(anchorEntity) return arView } That\u0026rsquo;s it! Play and enjoy üòä\nThank you for reading! üòä ","permalink":"http://localhost:1313/posts/ios-ar-app-experience-3d-guitar/","summary":"Introduction I was searching for an AR implementation of a 3D guitar inside an iOS app. Here\u0026rsquo;s what I discovered:\nFirst Step The first step is not related to building the app. Before that you need to create a project using the Reality Composer Pro app (you can find it through Spotlight search).\nSecond Step After that, you need to visit https://developer.apple.com/augmented-reality/quick-look/ and download one of the USDZ files. In my case, I chose the 3D guitar.","title":"iOS AR App: Experience 3D Guitar"},{"content":"Introduction I was wondering about how to create movie recommendations, so I decided to take a closer look and find out more about this topic. This is what I found:\nFirst step: You need to create a JSON file with the data that you will use to train the model and define the parameters for training the model.\n[ { \u0026#34;title\u0026#34;: \u0026#34;Avatar\u0026#34;, \u0026#34;year\u0026#34;: \u0026#34;2009\u0026#34;, \u0026#34;rated\u0026#34;: \u0026#34;PG-13\u0026#34;, \u0026#34;released\u0026#34;: \u0026#34;18 Dec 2009\u0026#34;, \u0026#34;runtime\u0026#34;: \u0026#34;162 min\u0026#34;, \u0026#34;genre\u0026#34;: \u0026#34;Action, Adventure, Fantasy\u0026#34;, \u0026#34;director\u0026#34;: \u0026#34;James Cameron\u0026#34;, \u0026#34;writer\u0026#34;: \u0026#34;James Cameron\u0026#34;, \u0026#34;actors\u0026#34;: \u0026#34;Sam Worthington, Zoe Saldana, Sigourney Weaver, Stephen Lang\u0026#34;, \u0026#34;plot\u0026#34;: \u0026#34;A paraplegic marine dispatched to the moon Pandora on a unique mission becomes torn between following his orders and protecting the world he feels is his home.\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;English, Spanish\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;USA, UK\u0026#34;, \u0026#34;awards\u0026#34;: \u0026#34;Won 3 Oscars. Another 80 wins \u0026amp; 121 nominations.\u0026#34;, \u0026#34;poster\u0026#34;: \u0026#34;https://ia.media-imdb.com/images/M/MV5BMTYwOTEwNjAzMl5BMl5BanBnXkFtZTcwODc5MTUwMw@@._V1_SX300.jpg\u0026#34;, \u0026#34;metascore\u0026#34;: \u0026#34;83\u0026#34;, \u0026#34;imdbrating\u0026#34;: \u0026#34;7.9\u0026#34;, \u0026#34;imdbvotes\u0026#34;: \u0026#34;890,617\u0026#34;, \u0026#34;imdbid\u0026#34;: \u0026#34;tt0499549\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;movie\u0026#34;, \u0026#34;response\u0026#34;: \u0026#34;True\u0026#34;, \u0026#34;keywords\u0026#34;: [\u0026#34;alien\u0026#34;, \u0026#34;avatar\u0026#34;, \u0026#34;fantasy world\u0026#34;, \u0026#34;soldier\u0026#34;, \u0026#34;battle\u0026#34;] }, ] When you have created the data, you can proceed to the next step.\nCreating a model with parameters Creating a model with parameters is essential for training. As an example, I chose the following parameters to create more realistic recommendations: director, actors, language, country, metascore, IMDb rating, and IMDb votes.\nstruct Movie: Decodable { var id: String { return imdbid } let title: String let keywords: [String] let director: String let actors: String let language: String let country: String let poster: String let metascore: String let imdbrating: String let imdbvotes: String let imdbid: String } extension Movie: Identifiable, TextImageProviding { var url: URL { return URL(string: poster)! } } When you have created the model, you can proceed to the next step:\nCreating a Recommendations service In this step, it\u0026rsquo;s important to specify the ML model you\u0026rsquo;ll utilize. I chose the MLLinearRegressor model because linear regression computes an output value for a given input value. I selected \u0026lsquo;favorite\u0026rsquo; as the target column for this model to create predictions based on the films I like.\nimport Foundation import TabularData #if canImport(CreateML) import CreateML #endif final class RecommendationService { private let queue = DispatchQueue(label: \u0026#34;com.recommendation-service.queue\u0026#34;, qos: .userInitiated) func computeRecommendations(basedOn items: [FavoriteWrapper\u0026lt;Movie\u0026gt;]) async throws -\u0026gt; [Movie] { return try await withCheckedThrowingContinuation { continuation in queue.async { #if targetEnvironment(simulator) continuation.resume(throwing: NSError(domain: \u0026#34;Simulator Not Supported\u0026#34;, code: -1)) #else let trainingData = items.filter { $0.isFavorite != nil } let trainingDataFrame = self.dataFrame(for: trainingData) let testData = items let testDataFrame = self.dataFrame(for: testData) do { let regressor = try MLLinearRegressor(trainingData: trainingDataFrame, targetColumn: \u0026#34;favorite\u0026#34;) let predictionsColumn = (try regressor.predictions(from: testDataFrame)).compactMap { value in value as? Double } let sorted = zip(testData, predictionsColumn) .sorted { lhs, rhs -\u0026gt; Bool in lhs.1 \u0026gt; rhs.1 } .filter { $0.1 \u0026gt; 0 } .prefix(10) print(sorted.map(\\.1)) let result = sorted.map(\\.0.model) continuation.resume(returning: result) } catch { continuation.resume(throwing: error) } #endif } } } private func dataFrame(for data: [FavoriteWrapper\u0026lt;Movie\u0026gt;]) -\u0026gt; DataFrame { var dataFrame = DataFrame() dataFrame.append( column: Column(name: \u0026#34;keywords\u0026#34;, contents: data.flatMap(\\.model.keywords).joined(separator: \u0026#34;, \u0026#34;)) ) dataFrame.append( column: Column(name: \u0026#34;director\u0026#34;, contents: data.map(\\.model.director)) ) dataFrame.append( column: Column(name: \u0026#34;actors\u0026#34;, contents: data.map(\\.model.actors)) ) dataFrame.append( column: Column(name: \u0026#34;language\u0026#34;, contents: data.map(\\.model.language)) ) dataFrame.append( column: Column(name: \u0026#34;country\u0026#34;, contents: data.map(\\.model.country)) ) dataFrame.append( column: Column\u0026lt;Int\u0026gt;( name: \u0026#34;metascore\u0026#34;, contents: data.map { return Int($0.model.metascore) } ) ) dataFrame.append( column: Column\u0026lt;Double\u0026gt;( name: \u0026#34;imdbrating\u0026#34;, contents: data.map { return Double($0.model.imdbrating) } ) ) dataFrame.append( column: Column(name: \u0026#34;imdbvotes\u0026#34;, contents: data.map(\\.model.imdbvotes)) ) dataFrame.append( column: Column\u0026lt;Int\u0026gt;( name: \u0026#34;favorite\u0026#34;, contents: data.map { if let isFavorite = $0.isFavorite { return isFavorite ? 1 : -1 } else { return 0 } } ) ) return dataFrame } } Once you\u0026rsquo;ve finished with the ML part, proceed to the next step:\nCreating a ViewModel to assemble all components At this stage, you handle user input and recompute recommendations based on user input.\n@MainActor final class MainViewModel: ObservableObject { private var allMovies: [FavoriteWrapper\u0026lt;Movie\u0026gt;] = [] @Published private(set) var movies: [Movie] = [] @Published private(set) var recommendations: [Movie] = [] private let recommendationService: RecommendationService private var recommendationsTask: Task\u0026lt;Void, Never\u0026gt;? init(recommendationService: RecommendationService = RecommendationService()) { self.recommendationService = recommendationService } func loadAllMovies() async { guard let url = Bundle.main.url(forResource: \u0026#34;movies\u0026#34;, withExtension: \u0026#34;json\u0026#34;) else { return } do { let data = try Data(contentsOf: url) allMovies = (try JSONDecoder().decode([Movie].self, from: data)).shuffled().map { FavoriteWrapper(model: $0) } movies = allMovies.map(\\.model) } catch { print(error.localizedDescription) } } func didRemove(_ item: Movie, isLiked: Bool) { movies.removeAll { $0.id == item.id } if let index = allMovies.firstIndex(where: { $0.model.id == item.id }) { allMovies[index] = FavoriteWrapper(model: item, isFavorite: isLiked) } recommendationsTask?.cancel() recommendationsTask = Task { do { let result = try await recommendationService.computeRecommendations(basedOn: allMovies) if !Task.isCancelled { recommendations = result } } catch { print(error.localizedDescription) } } } func resetUserChoices() { movies = allMovies.map(\\.model) recommendations = [] } } The final step The final step is to create the UI and connect it with the ViewModel.\nimport SwiftUI struct ContentView: View { @StateObject private var viewModel: MainViewModel init() { _viewModel = StateObject(wrappedValue: MainViewModel()) } var body: some View { NavigationView { ScrollView { VStack(alignment: .leading) { SectionTitleView(text: \u0026#34;Swipe to Like or Dislike\u0026#34;) if viewModel.movies.isEmpty { HStack { Spacer() VStack { Text(\u0026#34;All Done!\u0026#34;) .multilineTextAlignment(.center) .font(.callout) .foregroundColor(.secondary) Button(\u0026#34;Try Again\u0026#34;) { withAnimation { viewModel.resetUserChoices() } } .font(.headline) .buttonStyle(.borderedProminent) } Spacer() } .padding(.horizontal) .padding(.vertical, 32) } else { CardsStackView(models: viewModel.movies) { item, isLiked in withAnimation(.spring()) { viewModel.didRemove(item, isLiked: isLiked) } } .zIndex(1) } RecommendationsView(recommendations: viewModel.recommendations) } } .navigationTitle(\u0026#34;Tmovie¬¥inder!\u0026#34;) .task { await viewModel.loadAllMovies() } } .navigationViewStyle(.stack) } } Resources üîó GitHub project üì• Download materials Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/building-movie-recommendations-using-ml/","summary":"Introduction I was wondering about how to create movie recommendations, so I decided to take a closer look and find out more about this topic. This is what I found:\nFirst step: You need to create a JSON file with the data that you will use to train the model and define the parameters for training the model.\n[ { \u0026#34;title\u0026#34;: \u0026#34;Avatar\u0026#34;, \u0026#34;year\u0026#34;: \u0026#34;2009\u0026#34;, \u0026#34;rated\u0026#34;: \u0026#34;PG-13\u0026#34;, \u0026#34;released\u0026#34;: \u0026#34;18 Dec 2009\u0026#34;, \u0026#34;runtime\u0026#34;: \u0026#34;162 min\u0026#34;, \u0026#34;genre\u0026#34;: \u0026#34;Action, Adventure, Fantasy\u0026#34;, \u0026#34;director\u0026#34;: \u0026#34;James Cameron\u0026#34;, \u0026#34;writer\u0026#34;: \u0026#34;James Cameron\u0026#34;, \u0026#34;actors\u0026#34;: \u0026#34;Sam Worthington, Zoe Saldana, Sigourney Weaver, Stephen Lang\u0026#34;, \u0026#34;plot\u0026#34;: \u0026#34;A paraplegic marine dispatched to the moon Pandora on a unique mission becomes torn between following his orders and protecting the world he feels is his home.","title":"Building movie recommendations using ML"},{"content":"Introduction If you\u0026rsquo;re wondering how to test an Xcode project using GitHub Actions, here are a few steps:\nFirst, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.3.app/Contents/Developer - name: Install xcpretty run: gem install xcpretty - name: Test project run: xcodebuild -project /Users/runner/work/YourProjectName/YourProjectName/YourProjectName/YourProjectName.xcodeproj -scheme YourSchemeName -destination \u0026#39;platform=iOS Simulator,OS=17.4,name=iPhone 15 Pro\u0026#39; clean build test | xcpretty Caveats If you don\u0026rsquo;t specify the path to the Xcode project, you will receive an error like this: xcodebuild: error: ‚ÄòYourProjectName.xcodeproj' does not exist.\nYou can debug project directory by adding this line to your config:\n- name: Debug Directory Contents run: ls -la /Users/runner/work/YourProjectName/YourProjectName Thank you for reading!\n","permalink":"http://localhost:1313/posts/testing-xcode-project-using-github-actions/","summary":"Introduction If you\u0026rsquo;re wondering how to test an Xcode project using GitHub Actions, here are a few steps:\nFirst, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.","title":"Testing Xcode project using Github Actions"},{"content":"Introduction If you\u0026rsquo;re wondering how to build an Xcode project using GitHub Actions, here are a few steps:\nFirst, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.3.app/Contents/Developer - name: Install xcpretty run: gem install xcpretty - name: Build project run: xcodebuild -project /Users/runner/work/YourProjectName/YourProjectName/YourProjectName/YourProjectName.xcodeproj -scheme YourSchemeName -sdk iphonesimulator -destination \u0026#39;platform=iOS Simulator,name=iPhone 15 Pro\u0026#39; clean build | xcpretty Caveats If you don\u0026rsquo;t specify the path to the Xcode project, you will receive an error like this: xcodebuild: error: ‚ÄòYourProjectName.xcodeproj' does not exist.\nYou can debug project directory by adding this line to your config:\n- name: Debug Directory Contents run: ls -la /Users/runner/work/YourProjectName/YourProjectName Thank you for reading!\n","permalink":"http://localhost:1313/posts/building-xcode-project-using-github-actions/","summary":"Introduction If you\u0026rsquo;re wondering how to build an Xcode project using GitHub Actions, here are a few steps:\nFirst, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.","title":"Building Xcode project using Github Actions"},{"content":"Introduction You can easily deliver an iOS app in two ways: through beta and release lanes.\nThe First Way - TestFlight By creating a beta lane inside the Fastfile. It utilizes:\nbuild_app: To easily build and sign your app (via gym). pilot: Makes it easier to manage your app on Apple‚Äôs TestFlight. lane :beta do build_app(scheme: \u0026#34;YourScheme\u0026#34;) pilot end To run Fastlane:\nfastlane beta Attention Before proceeding, you need to have the ipa or pkg file generated.\nThe Second Way - App Store Connect By creating a release lane inside the Fastfile. It utilizes:\ngym: To build and package iOS apps for you. deliver: To upload screenshots, metadata, and binaries to App Store Connect. lane :release do gym # Builds the app deliver # Uploads the app to App Store Connect end To run Fastlane:\nfastlane release If you haven\u0026rsquo;t installed Fastlane yet, here are the steps: Outline of the Process\nInstall Fastlane: You can do so using RubyGems, which is the Ruby package manager: brew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running: fastlane init ","permalink":"http://localhost:1313/posts/delivering-ios-app-using-fastlane/","summary":"Introduction You can easily deliver an iOS app in two ways: through beta and release lanes.\nThe First Way - TestFlight By creating a beta lane inside the Fastfile. It utilizes:\nbuild_app: To easily build and sign your app (via gym). pilot: Makes it easier to manage your app on Apple‚Äôs TestFlight. lane :beta do build_app(scheme: \u0026#34;YourScheme\u0026#34;) pilot end To run Fastlane:\nfastlane beta Attention Before proceeding, you need to have the ipa or pkg file generated.","title":"Delivering iOS app using Fastlane"},{"content":"Introduction When you are working on different projects sometimes you need to use different IDE‚Äôs. You need to find a way to archive a project in the fastest way.\nOne of such ways is by using the xcodebuild archive command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild archive: Once you\u0026rsquo;re in the project directory, you can run xcodebuild archive with the appropriate parameters to build your project. Example: xcodebuild archive -scheme YourSchemeName -archivePath ~/Desktop/YourAppName.xcarchive Another way is by integrating fastlane into your workflow: Outline of the process Install Fastlane: If you haven\u0026rsquo;t already installed Fastlane, you can do so using RubyGems, which is the Ruby package manager:\nbrew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running:\nfastlane init Create a lane for archiving: Open your Fastfile located in the fastlane directory of your project, and add a new lane for archiving:\nlane :archive do gym( scheme: \u0026#34;YourSchemeName\u0026#34;, output_directory: \u0026#34;/path/to/your/archive/directory\u0026#34;, output_name: \u0026#34;YourAppName\u0026#34; ) end Run the archive lane: Once you\u0026rsquo;ve defined the archive lane, you can run it using the following command:\nfastlane archive ","permalink":"http://localhost:1313/posts/archiving-xcode-project-using-the-cli/","summary":"Introduction When you are working on different projects sometimes you need to use different IDE‚Äôs. You need to find a way to archive a project in the fastest way.\nOne of such ways is by using the xcodebuild archive command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project.","title":"Archiving Xcode project using the CLI"},{"content":"Introduction When you are working on different projects sometimes you need to use different IDE‚Äôs. You need to find a way to test a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project. Example: xcodebuild -project YourProject.xcodeproj -scheme YourSchemeName test Another way is by integrating fastlane into your workflow: Outline of the process Install Fastlane: If you haven\u0026rsquo;t already installed Fastlane, you can do so using RubyGems, which is the Ruby package manager:\nbrew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running:\nfastlane init Define a Lane for Testing: Open your Fastfile and define a lane for running tests. Here\u0026rsquo;s a basic example:\nlane :run_tests do scan(scheme: \u0026#34;YourSchemeName\u0026#34;) end Run Tests Using Fastlane: You can now run your tests using the lane you defined. In the terminal, navigate to your project directory and run:\nfastlane run_tests Testing a project through a project generation tools If you are testing a project through a project generation tool like tuist you do not need anything that was mentioned above because it already has build-in commands:\ntuist test YourSchemeName ","permalink":"http://localhost:1313/posts/testing-xcode-project-using-the-cli/","summary":"Introduction When you are working on different projects sometimes you need to use different IDE‚Äôs. You need to find a way to test a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project.","title":"Testing Xcode project using the CLI"},{"content":"Introduction When you are working on different projects sometimes you need to use different IDE‚Äôs. You need to find a way to build a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project. Example: xcodebuild -project YourProjectName.xcodeproj -scheme YourSchemeName Another way is by integrating fastlane into your workflow: Outline of the process Install Fastlane: If you haven\u0026rsquo;t already installed Fastlane, you can do so using RubyGems, which is the Ruby package manager:\nbrew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running:\nfastlane init Build with Fastlane: Once Fastlane is set up, you can use it to build your Xcode project. Fastlane provides a lane named build_app for building your app. You can run this lane with the following command:\nfastlane build_app Building a project through a project generation tools If you are building a project through a project generation tool like tuist you do not need anything that was mentioned above because it already has build-in commands tuist build.\n","permalink":"http://localhost:1313/posts/building-xcode-project-using-the-cli/","summary":"Introduction When you are working on different projects sometimes you need to use different IDE‚Äôs. You need to find a way to build a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project.","title":"Building Xcode project using the CLI"},{"content":"What is a Visitor Pattern? The Visitor Pattern helps add new capabilities to a composite of objects.\nSource\nWhat problems does it solve? The Visitor Pattern helps solve following problems:\nSeparation of Concerns: The Visitor Pattern separates algorithms from the objects on which they operate. This allows for clean code organization by keeping algorithms and operations separate from the data structures they operate on. Extensibility: It allows you to add new operations to existing object structures without modifying those structures. This is especially useful when dealing with complex object hierarchies where adding new functionality directly to the classes would lead to code bloat and tight coupling. Traversal of Object Structures: It provides a way to traverse complex object structures while performing some action on each element of the structure. This is particularly useful in scenarios where you need to process every element of a data structure in a specific order or with a specific algorithm. Real-world code example // Element protocol representing the items on the menu protocol MenuItem { func accept(visitor: OrderVisitor) } // Concrete item types class Coffee: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } class Tea: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } class Pastry: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } // Visitor protocol defining the operations to be performed on menu items protocol OrderVisitor { func visit(_ item: Coffee) func visit(_ item: Tea) func visit(_ item: Pastry) } // Concrete visitor implementing operations on menu items class TotalCostVisitor: OrderVisitor { var totalCost = 0.0 func visit(_ item: Coffee) { totalCost += item.price } func visit(_ item: Tea) { totalCost += item.price } func visit(_ item: Pastry) { totalCost += item.price } } class ItemDetailsVisitor: OrderVisitor { var details = \u0026#34;\u0026#34; func visit(_ item: Coffee) { details += \u0026#34;Coffee: \\(item.name), Price: $\\(item.price)\\n\u0026#34; } func visit(_ item: Tea) { details += \u0026#34;Tea: \\(item.name), Price: $\\(item.price)\\n\u0026#34; } func visit(_ item: Pastry) { details += \u0026#34;Pastry: \\(item.name), Price: $\\(item.price)\\n\u0026#34; } } // Example usage let items: [MenuItem] = [Coffee(name: \u0026#34;Espresso\u0026#34;, price: 2.5), Tea(name: \u0026#34;Green Tea\u0026#34;, price: 2.0), Pastry(name: \u0026#34;Croissant\u0026#34;, price: 3.0)] let totalCostVisitor = TotalCostVisitor() for item in items { item.accept(visitor: totalCostVisitor) } print(\u0026#34;Total cost of the order: $\\(totalCostVisitor.totalCost)\u0026#34;) let itemDetailsVisitor = ItemDetailsVisitor() for item in items { item.accept(visitor: itemDetailsVisitor) } print(\u0026#34;Order details:\u0026#34;) print(itemDetailsVisitor.details) ","permalink":"http://localhost:1313/posts/the-visitor-pattern/","summary":"What is a Visitor Pattern? The Visitor Pattern helps add new capabilities to a composite of objects.\nSource\nWhat problems does it solve? The Visitor Pattern helps solve following problems:\nSeparation of Concerns: The Visitor Pattern separates algorithms from the objects on which they operate. This allows for clean code organization by keeping algorithms and operations separate from the data structures they operate on. Extensibility: It allows you to add new operations to existing object structures without modifying those structures.","title":"The Visitor Pattern"},{"content":"What is a Memento Pattern? The Memento Pattern helps return an object to one of its previous states; for instance, if the user requests an ‚Äúundo‚Äù operation.\nSource\nWhat problems does it solve? The Memento Pattern helps solve following problems:\nUndo/Redo Functionality: Memento allows you to capture an object‚Äôs state at a specific point in time and store it externally. This enables you to implement undo/redo functionality by restoring the object to its previous state. Checkpointing: In applications where users need to save progress or create checkpoints (such as in games or long processes), the Memento Pattern allows you to save the state of an object at various intervals so that users can return to those points later. Real-world code example // Memento: Represents the state of the TextEditor struct TextEditorMemento { let text: String } // Originator: Creates and stores states in Memento objects class TextEditor { private var text: String = \u0026#34;\u0026#34; func setText(_ text: String) { self.text = text } func getText() -\u0026gt; String { return text } func save() -\u0026gt; TextEditorMemento { return TextEditorMemento(text: text) } func restore(fromMemento memento: TextEditorMemento) { self.text = memento.text } } // Caretaker: Manages the mementos class TextEditorHistory { private var history: [TextEditorMemento] = [] private let editor: TextEditor init(editor: TextEditor) { self.editor = editor } func save() { let snapshot = editor.save() history.append(snapshot) } func undo() { guard let lastSnapshot = history.popLast() else { print(\u0026#34;Nothing to undo.\u0026#34;) return } editor.restore(fromMemento: lastSnapshot) } func printHistory() { print(\u0026#34;Text Editor History:\u0026#34;) for (index, snapshot) in history.enumerated() { print(\u0026#34;Step \\(index + 1): \\(snapshot.text)\u0026#34;) } print(\u0026#34;Current text: \\(editor.getText())\u0026#34;) } } // Example usage let textEditor = TextEditor() let history = TextEditorHistory(editor: textEditor) textEditor.setText(\u0026#34;Hello, World!\u0026#34;) history.save() textEditor.setText(\u0026#34;This is a Swift example.\u0026#34;) history.save() textEditor.setText(\u0026#34;Using Memento Pattern.\u0026#34;) history.save() history.printHistory() history.undo() print(\u0026#34;After Undo:\u0026#34;) history.printHistory() Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/the-memento-pattern/","summary":"What is a Memento Pattern? The Memento Pattern helps return an object to one of its previous states; for instance, if the user requests an ‚Äúundo‚Äù operation.\nSource\nWhat problems does it solve? The Memento Pattern helps solve following problems:\nUndo/Redo Functionality: Memento allows you to capture an object‚Äôs state at a specific point in time and store it externally. This enables you to implement undo/redo functionality by restoring the object to its previous state.","title":"The Memento Pattern"},{"content":"What is an Interpreter Pattern? The Interpreter Pattern helps implement a simple language and defines a class based representation for its grammar along with an interpreter to interpret its sentences.\nSource\nWhat problems does it solve? The Interpreter Pattern helps solve following problems:\nLanguage Interpretation: When you have a language or syntax that needs to be interpreted, such as mathematical expressions, regular expressions, or domain-specific languages (DSLs), the Interpreter Pattern helps in implementing the logic to interpret and execute these expressions. Extensibility: The Interpreter Pattern allows for easy addition of new grammar rules or language constructs without modifying the core interpreter logic. This promotes extensibility, enabling the interpreter to support new features or languages with minimal changes. Separation of Concerns: It separates the grammar definition from the interpretation logic. This separation of concerns makes the codebase modular and easier to maintain. Changes to the grammar or language rules do not affect the interpretation logic, and vice versa. Real-world code example // Define the protocol for the expression protocol Expression { func interpret() -\u0026gt; Int } // Concrete expression for a number class NumberExpression: Expression { private var value: Int init(_ value: Int) { self.value = value } func interpret() -\u0026gt; Int { return value } } // Concrete expression for addition class AdditionExpression: Expression { private var left: Expression private var right: Expression init(_ left: Expression, _ right: Expression) { self.left = left self.right = right } func interpret() -\u0026gt; Int { return left.interpret() + right.interpret() } } // Concrete expression for subtraction class SubtractionExpression: Expression { private var left: Expression private var right: Expression init(_ left: Expression, _ right: Expression) { self.left = left self.right = right } func interpret() -\u0026gt; Int { return left.interpret() - right.interpret() } } // Concrete expression for multiplication class MultiplicationExpression: Expression { private var left: Expression private var right: Expression init(_ left: Expression, _ right: Expression) { self.left = left self.right = right } func interpret() -\u0026gt; Int { return left.interpret() * right.interpret() } } // Concrete expression for division class DivisionExpression: Expression { private var left: Expression private var right: Expression init(_ left: Expression, _ right: Expression) { self.left = left self.right = right } func interpret() -\u0026gt; Int { let divisor = right.interpret() if divisor != 0 { return left.interpret() / divisor } else { // Handle division by zero error fatalError(\u0026#34;Division by zero\u0026#34;) } } } // Usage let expression = AdditionExpression( MultiplicationExpression(NumberExpression(2), NumberExpression(3)), DivisionExpression(NumberExpression(10), NumberExpression(5)) ) // Interpret the expression let result = expression.interpret() print(\u0026#34;Result: \\(result)\u0026#34;) Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/the-interpreter-pattern/","summary":"What is an Interpreter Pattern? The Interpreter Pattern helps implement a simple language and defines a class based representation for its grammar along with an interpreter to interpret its sentences.\nSource\nWhat problems does it solve? The Interpreter Pattern helps solve following problems:\nLanguage Interpretation: When you have a language or syntax that needs to be interpreted, such as mathematical expressions, regular expressions, or domain-specific languages (DSLs), the Interpreter Pattern helps in implementing the logic to interpret and execute these expressions.","title":"The Interpreter Pattern"},{"content":"What is a Flyweight Pattern? The Flyweight Pattern refers to an object that minimizes memory usage by sharing some of its data with other similar objects.\nSource\nWhat problems does it solve? The Flyweight Pattern helps solve following problems:\nLarge Memory Footprint: When dealing with a large number of objects, especially if these objects share a significant amount of common state, traditional object creation can lead to excessive memory consumption. The Flyweight Pattern reduces memory usage by sharing this common state among multiple objects. Performance Overhead: Creating and managing a large number of objects can also introduce performance overhead due to memory allocation, deallocation, and initialization. By reusing shared objects and minimizing the creation of new objects, the Flyweight Pattern can improve performance. Object Creation Cost: Creating new objects can be costly in terms of time and resources, especially if the objects require complex initialization. By reusing existing objects, the Flyweight Pattern reduces the need for creating new objects, thereby reducing object creation costs. Real-world code example // Flyweight protocol defining the interface for shapes protocol Shape { func draw(at point: CGPoint) } // Concrete flyweight class representing a circle class Circle: Shape { private let radius: CGFloat private let fillColor: UIColor init(radius: CGFloat, fillColor: UIColor) { self.radius = radius self.fillColor = fillColor } func draw(at point: CGPoint) { print(\u0026#34;Drawing Circle at (\\(point.x), \\(point.y)) with radius \\(radius) and fill color \\(fillColor)\u0026#34;) // Actual drawing logic would go here } } // Flyweight factory class responsible for creating and managing flyweight objects class ShapeFactory { private var flyweights = [String: Shape]() func getCircle(radius: CGFloat, fillColor: UIColor) -\u0026gt; Shape { let key = \u0026#34;Circle-\\(radius)-\\(fillColor)\u0026#34; if let existingShape = flyweights[key] { return existingShape } else { let newShape = Circle(radius: radius, fillColor: fillColor) flyweights[key] = newShape return newShape } } } // Client code let shapeFactory = ShapeFactory() // Request for circles with different properties let circle1 = shapeFactory.getCircle(radius: 10, fillColor: .red) let circle2 = shapeFactory.getCircle(radius: 10, fillColor: .red) // Reusing the same circle object let circle3 = shapeFactory.getCircle(radius: 20, fillColor: .blue) // Drawing circles circle1.draw(at: CGPoint(x: 100, y: 100)) circle2.draw(at: CGPoint(x: 200, y: 200)) circle3.draw(at: CGPoint(x: 300, y: 300)) Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/the-flyweight-pattern/","summary":"What is a Flyweight Pattern? The Flyweight Pattern refers to an object that minimizes memory usage by sharing some of its data with other similar objects.\nSource\nWhat problems does it solve? The Flyweight Pattern helps solve following problems:\nLarge Memory Footprint: When dealing with a large number of objects, especially if these objects share a significant amount of common state, traditional object creation can lead to excessive memory consumption. The Flyweight Pattern reduces memory usage by sharing this common state among multiple objects.","title":"The Flyweight Pattern"},{"content":"What is a Chain Of Responsibility Pattern? The Chain Of Responsibility Pattern helps create a chain of objects to examine requests. Each object in turn examines a request and either handles it or passes onto the next object in the chain.\nSource\nWhat problems does it solve? The Chain Of Responsibility Pattern (CoR) helps solve following problems:\nDynamic Request Handling: It enables dynamic assignment of responsibilities at runtime. Handlers can be added, removed, or reordered without affecting the client‚Äôs code. This flexibility allows for easier maintenance and extension of the system. Decoupling Sender and Receiver: In traditional systems, a sender often needs to know the exact receiver of a request, leading to tight coupling between them. The CoR pattern decouples senders from receivers by allowing multiple objects to handle a request without the sender knowing the specific handler. Real-world code example // Protocol defining the handler interface protocol PurchaseHandler { var next: PurchaseHandler? { get set } func handleRequest(amount: Double) } // Concrete handlers class SmallPurchaseHandler: PurchaseHandler { var next: PurchaseHandler? let maxAmount: Double = 100.0 func handleRequest(amount: Double) { if amount \u0026lt;= maxAmount { print(\u0026#34;SmallPurchaseHandler: Purchase approved for $\\(amount)\u0026#34;) } else if let nextHandler = next { print(\u0026#34;SmallPurchaseHandler: Passing request to next handler\u0026#34;) nextHandler.handleRequest(amount: amount) } else { print(\u0026#34;SmallPurchaseHandler: No handler available, purchase rejected\u0026#34;) } } } class MediumPurchaseHandler: PurchaseHandler { var next: PurchaseHandler? let maxAmount: Double = 500.0 func handleRequest(amount: Double) { if amount \u0026lt;= maxAmount { print(\u0026#34;MediumPurchaseHandler: Purchase approved for $\\(amount)\u0026#34;) } else if let nextHandler = next { print(\u0026#34;MediumPurchaseHandler: Passing request to next handler\u0026#34;) nextHandler.handleRequest(amount: amount) } else { print(\u0026#34;MediumPurchaseHandler: No handler available, purchase rejected\u0026#34;) } } } class LargePurchaseHandler: PurchaseHandler { var next: PurchaseHandler? func handleRequest(amount: Double) { print(\u0026#34;LargePurchaseHandler: Purchase approved for $\\(amount)\u0026#34;) } } // Usage func main() { let smallHandler = SmallPurchaseHandler() let mediumHandler = MediumPurchaseHandler() let largeHandler = LargePurchaseHandler() // Connecting handlers into a chain smallHandler.next = mediumHandler mediumHandler.next = largeHandler smallHandler.handleRequest(amount: 50.0) smallHandler.handleRequest(amount: 200.0) smallHandler.handleRequest(amount: 1000.0) } Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/the-chain-of-responsibility-pattern/","summary":"What is a Chain Of Responsibility Pattern? The Chain Of Responsibility Pattern helps create a chain of objects to examine requests. Each object in turn examines a request and either handles it or passes onto the next object in the chain.\nSource\nWhat problems does it solve? The Chain Of Responsibility Pattern (CoR) helps solve following problems:\nDynamic Request Handling: It enables dynamic assignment of responsibilities at runtime. Handlers can be added, removed, or reordered without affecting the client‚Äôs code.","title":"The Chain Of Responsibility Pattern"},{"content":"What is a State Pattern? The State Pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.\nSource\nWhat problems does it solve? Complex conditional logic: When an object‚Äôs behavior depends on its internal state, it often leads to complex conditional statements. The State pattern simplifies this by encapsulating each state and its behavior in separate classes, making the code more readable and maintainable. State-specific behavior: Objects often need to change their behavior based on their state. The State pattern allows objects to delegate behavior to state objects, which can vary independently. This promotes better encapsulation and separation of concerns. Adding new states: When new states need to be added, the State pattern makes it easier to extend the functionality without modifying existing code. New states can be added by creating new state classes and integrating them into the existing context, without changing the context class itself. Real-world code example // Define the VendingMachine protocol protocol VendingMachineState { func insertCoin() func dispenseItem() } // Define concrete states class NoCoinState: VendingMachineState { private let vendingMachine: VendingMachine init(vendingMachine: VendingMachine) { self.vendingMachine = vendingMachine } func insertCoin() { print(\u0026#34;Coin inserted\u0026#34;) // Transition to the HasCoinState vendingMachine.changeState(newState: vendingMachine.hasCoinState) } func dispenseItem() { print(\u0026#34;Please insert a coin first\u0026#34;) } } class HasCoinState: VendingMachineState { private let vendingMachine: VendingMachine init(vendingMachine: VendingMachine) { self.vendingMachine = vendingMachine } func insertCoin() { print(\u0026#34;Coin already inserted\u0026#34;) } func dispenseItem() { if vendingMachine.inventoryCount \u0026gt; 0 { print(\u0026#34;Item dispensed\u0026#34;) vendingMachine.decreaseInventory() // Transition to the NoCoinState vendingMachine.changeState(newState: vendingMachine.noCoinState) } else { print(\u0026#34;Out of stock\u0026#34;) } } } // Define the VendingMachine class class VendingMachine { var inventoryCount: Int = 5 var currentState: VendingMachineState! var noCoinState: VendingMachineState! var hasCoinState: VendingMachineState! init() { noCoinState = NoCoinState(vendingMachine: self) hasCoinState = HasCoinState(vendingMachine: self) currentState = noCoinState } func changeState(newState: VendingMachineState) { currentState = newState } func insertCoin() { currentState.insertCoin() } func dispenseItem() { currentState.dispenseItem() } func decreaseInventory() { inventoryCount -= 1 } } // Usage let vendingMachine = VendingMachine() vendingMachine.dispenseItem() vendingMachine.insertCoin() vendingMachine.insertCoin() vendingMachine.dispenseItem() vendingMachine.dispenseItem() Thank you for reading!\n","permalink":"http://localhost:1313/posts/the-state-pattern/","summary":"What is a State Pattern? The State Pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.\nSource\nWhat problems does it solve? Complex conditional logic: When an object‚Äôs behavior depends on its internal state, it often leads to complex conditional statements. The State pattern simplifies this by encapsulating each state and its behavior in separate classes, making the code more readable and maintainable.","title":"The State Pattern"},{"content":"What is a Dependency Inversion Principle? The Dependency Inversion Principle means that high-level modules should not depend on low-level modules.\nSource\nSource\nWhat problems does it solve? The Dependency Inversion Principle (DIP) helps solve:\nRigidity Fragility Immobility problems Real-world code example Violation of DIP // High-level module directly depending on low-level modules class MessageService { func sendMessageViaEmail(message: String) { let emailSender = EmailSender() emailSender.sendMessage(message: message) } func sendMessageViaSMS(message: String) { let smsSender = SMSSender() smsSender.sendMessage(message: message) } func sendMessageViaPushNotification(message: String) { let pushNotificationSender = PushNotificationSender() pushNotificationSender.sendMessage(message: message) } } Adhering to DIP // Protocol defining the interface for sending messages protocol MessageSender { func sendMessage(message: String) } // High-level module depending on abstraction (MessageSender protocol) class MessageService { private let messageSender: MessageSender init(messageSender: MessageSender) { self.messageSender = messageSender } func sendMessage(message: String) { messageSender.sendMessage(message: message) } } // Concrete implementations of MessageSender protocol for different channels class EmailSender: MessageSender { func sendMessage(message: String) { print(\u0026#34;Sending email: \\(message)\u0026#34;) } } class SMSSender: MessageSender { func sendMessage(message: String) { print(\u0026#34;Sending SMS: \\(message)\u0026#34;) } } class PushNotificationSender: MessageSender { func sendMessage(message: String) { print(\u0026#34;Sending push notification: \\(message)\u0026#34;) } } // Example usage let emailSender = EmailSender() let smsSender = SMSSender() let pushNotificationSender = PushNotificationSender() let emailService = MessageService(messageSender: emailSender) let smsService = MessageService(messageSender: smsSender) let pushNotificationService = MessageService(messageSender: pushNotificationSender) emailService.sendMessage(message: \u0026#34;Hello via email\u0026#34;) smsService.sendMessage(message: \u0026#34;Hello via SMS\u0026#34;) pushNotificationService.sendMessage(message: \u0026#34;Hello via push notification\u0026#34;) Thank you for reading! üòä ","permalink":"http://localhost:1313/posts/the-dependency-inversion-principle/","summary":"What is a Dependency Inversion Principle? The Dependency Inversion Principle means that high-level modules should not depend on low-level modules.\nSource\nSource\nWhat problems does it solve? The Dependency Inversion Principle (DIP) helps solve:\nRigidity Fragility Immobility problems Real-world code example Violation of DIP // High-level module directly depending on low-level modules class MessageService { func sendMessageViaEmail(message: String) { let emailSender = EmailSender() emailSender.sendMessage(message: message) } func sendMessageViaSMS(message: String) { let smsSender = SMSSender() smsSender.","title":"The Dependency Inversion Principle"},{"content":"What is a Big O notation? The Big O notation helps identify algorithm efficiency. It can measure computation and memory growth with respect to input. Real-world code example O(n) ‚Äî Linear Time\nfunc containsValue(array: [Int], value: Int) -\u0026gt; Bool { for element in array { if element == value { return true } } return false } O(1) ‚Äî Constant Time\nfunc findFirstElement(array: [Int]) -\u0026gt; Int? { return array.first } Thank you for reading!\n","permalink":"http://localhost:1313/posts/big-o-notation/","summary":"What is a Big O notation? The Big O notation helps identify algorithm efficiency. It can measure computation and memory growth with respect to input. Real-world code example O(n) ‚Äî Linear Time\nfunc containsValue(array: [Int], value: Int) -\u0026gt; Bool { for element in array { if element == value { return true } } return false } O(1) ‚Äî Constant Time\nfunc findFirstElement(array: [Int]) -\u0026gt; Int? { return array.first } Thank you for reading!","title":"Big O notation"},{"content":"What is Combine? Combine Framework provides an API for processing async events over time such as user-input, network response, and other dynamic data.\nWhat is the purpose of Combine? The purpose of Combine is to simplify the management of async events and data streams.\nPublishers Publisher declares that a type can transit a sequence of values over time. A publisher delivers elements to one or more Subscriber instances.\nclass PostService { func fetchPosts() -\u0026gt; AnyPublisher\u0026lt;[Post], Error\u0026gt; { guard let url = URL(string: \u0026#34;https://jsonplaceholder.typicode.com/posts\u0026#34;) else { fatalError(\u0026#34;Invalid URL\u0026#34;) } return URLSession.shared.dataTaskPublisher(for: url) .map(\\.data) .decode(type: [Post].self, decoder: JSONDecoder()) .receive(on: DispatchQueue.main) .eraseToAnyPublisher() } } Subscribers Subscriber is a protocol that declares a type that can receive input from a publisher. A Subscriber instance receives a stream of elements from a Publisher.\nprivate var cancellable: AnyCancellable? let service = PostService() cancellable = service.fetchPosts() .sink(receiveCompletion: { completion in switch completion { case .finished: break case .failure(let error): print(error.localizedDescription) } }, receiveValue: { posts in print(\u0026#34;Received posts count:\u0026#34;, posts.count) }) AnyCancellable When you call a method like sink or assign on a publisher, it returns a type that conforms to the Cancellable protocol. Storing this return value in an instance of AnyCancellable keeps the subscription active. When the AnyCancellable instance is deallocated, its deinit method automatically cancels the subscription.\nvar cancellables = Set\u0026lt;AnyCancellable\u0026gt;() let publisher = Just(\u0026#34;Hello, Combine!\u0026#34;) publisher .sink { completion in print(\u0026#34;Completion: \\(completion)\u0026#34;) } receiveValue: { value in print(\u0026#34;Received value: \\(value)\u0026#34;) } .store(in: \u0026amp;cancellables) Operators Transforming Operators map: Transforms each value received from a publisher by applying a function. flatMap: Transforms each value received into a new publisher, then flattens the result into a single publisher stream. scan: Applies a closure over the previous result and the current value to produce a new value, useful for accumulating values. Filtering Operators filter: Emits only those values from a publisher that satisfy a given predicate. removeDuplicates: Suppresses duplicate consecutive values published by a publisher. first/last: Emits only the first or last value from a publisher that satisfies a predicate condition. Combining Operators combineLatest: Combines the latest value from two or more publishers and emits a combined value each time any of the publishers emit a value. merge: Combines multiple publishers of the same type into a single publisher stream, emitting values as they arrive. zip: Combines values from multiple publishers into tuples, emitting a tuple only when each of the publishers has emitted a new value. Error Handling Operators catch: Handles errors from a publisher by replacing the failed publisher with another publisher or a value. retry: Attempts to recreate a subscription to a failed publisher for a specified number of times. Utility Operators delay: Delays the emission of items from the publisher for a specified interval. subscribe(on:)/receive(on:): Specifies the dispatch queue for performing subscription work or receiving values. print: Prints log messages for all publisher events to the console, useful for debugging. Timing Operators debounce: Emits a value from a publisher only after a specified time interval has passed without receiving another value. throttle: Emits either the first or last value received in a specified time window. Collecting Operators collect: Collects received values and emits an array of those values either when the publisher completes or when a buffer size is reached. When to use Combine? I found great advice from Apple when it comes to Combine:\n‚ÄúA Combine publisher fills a role similar to, but distinct from, the AsyncSequence in the Swift standard library. A Publisher and an AsyncSequence both produce elements over time. However, the pull model in Combine uses a Subscriber to request elements from a publisher, while Swift concurrency uses the for-await-in syntax to iterate over elements published by an AsyncSequence. Both APIs offer methods to modify the sequence by mapping or filtering elements, while only Combine provides time-based operations like debounce(for:scheduler:options:) and throttle(for:scheduler:latest:), and combining operations like merge(with:) and combineLatest(_:_:). To bridge the two approaches, the property values exposes a publisher‚Äôs elements as an AsyncSequence, allowing you to iterate over them with for-await-in rather than attaching a Subscriber.‚Äù\nThank you for reading!\n","permalink":"http://localhost:1313/posts/combine-basics/","summary":"What is Combine? Combine Framework provides an API for processing async events over time such as user-input, network response, and other dynamic data.\nWhat is the purpose of Combine? The purpose of Combine is to simplify the management of async events and data streams.\nPublishers Publisher declares that a type can transit a sequence of values over time. A publisher delivers elements to one or more Subscriber instances.\nclass PostService { func fetchPosts() -\u0026gt; AnyPublisher\u0026lt;[Post], Error\u0026gt; { guard let url = URL(string: \u0026#34;https://jsonplaceholder.","title":"Combine ‚Äî Basics"},{"content":"When was it introduced? It was introduced in Swift 5.5 at WWDC 2021.\nYou can find the more comprehensive info about Modern Concurrency in Swift Concurrency Manifesto.\nWhat are actors? Actors eliminate shared mutable state and explicit synchronization through deep copying of all the data that passed to an actor to a message sent and preventing direct access to actor state. Actors are reference types.\nactor DatabaseManager { private var data: [String: String] = [:] func readData(key: String) -\u0026gt; String? { data[key] } func writeData(key: String, value: String) { data[key] = value } } What is an asynchronous function? The asynchronous function or asynchronous method can be suspended while it is partway through execution. It can pause in the middle when it‚Äôs waiting for something.\nfunc someAsyncOperation(index: Int) async throws -\u0026gt; String { try await Task.sleep(nanoseconds: 1_000_000_000) return \u0026#34;Operation \\(index) Completed\u0026#34; } func performAsyncOperations() async throws { for index in 1...1000 { Task.detached { print(\u0026#34;Start of operation \\(index)\u0026#34;) let result = try await someAsyncOperation(index: index) print(\u0026#34;End of operation \\(index) with result: \\(result)\u0026#34;) return result } } } Task { print(\u0026#34;Start of example\u0026#34;) try await performAsyncOperationsWithYield() print(\u0026#34;End of example\u0026#34;) } What are Asynchronous Sequences? Asynchronous Sequences enable you to stop an async task until the next item is prepared, giving room for other tasks to progress. Crafting your own Asynchronous Sequence involves adhering to the AsyncSequence protocol.\nstruct AsyncCounter: AsyncSequence { typealias Element = Int struct AsyncCounterIterator: AsyncIteratorProtocol { var count = 0 mutating func next() async -\u0026gt; Int? { defer { count += 1 } return count } } func makeAsyncIterator() -\u0026gt; AsyncCounterIterator { return AsyncCounterIterator() } } let asyncCounter = AsyncCounter() for await count in asyncCounter { print(\u0026#34;Count: \\(count)\u0026#34;) try await Task.sleep(nanoseconds: 1 * 1_000_000_000) } What are Tasks and TaskGroups? You can draw a parallel between Tasks and DispatchQueue`s because they have similar concepts. If you want to execute your code asynchronously you should put your code into async context. Tasks and Queues help you solve this problem.\nfunc fetchData() async throws -\u0026gt; String { try await Task.sleep(nanoseconds: 2 * 1_000_000_000) return \u0026#34;Data fetched successfully!\u0026#34; } Task { print(\u0026#34;Start fetching data...\u0026#34;) do { let result = try await fetchData() print(result) } catch { print(\u0026#34;Error: \\(error)\u0026#34;) } print(\u0026#34;Data fetching completed.\u0026#34;) } let customQueue = DispatchQueue(label: \u0026#34;com.example.myqueue\u0026#34;, attributes: .concurrent) func performTask() { customQueue.async { print(\u0026#34;Task is starting...\u0026#34;) Thread.sleep(forTimeInterval: 2) print(\u0026#34;Task completed.\u0026#34;) } } for _ in 1...3 { performTask() } TaskGroup allows you to explicitly add child tasks and give you more control over priority and cancellation.\nfunc fetchImages(urls: [URL]) async throws -\u0026gt; [UIImage] { try await withThrowingTaskGroup(of: UIImage.self) { group in var images: [UIImage] = [] for url in urls { group.addTask { try await downloadImage(from: url) } } for try await result in group { images.append(result) } return images } } func downloadImage(from url: URL) async throws -\u0026gt; UIImage { // Download and return the image } What is Task.yield()? If you have a long-running operation you can call the Task.yield() method to explicitly add suspension points. By doing that you are letting other tasks make progress.\nfunc performAsyncOperationsWithYield() async throws { for index in 1...1000 { Task.detached { print(\u0026#34;Start of operation \\(index)\u0026#34;) // Yield control to the scheduler await Task.yield() let result = try await someAsyncOperation(index: index) print(\u0026#34;End of operation \\(index) with result: \\(result)\u0026#34;) return result } } } What are Sendable Types? A type that can be shared from one concurrency context to another is known as a sendable type. In other words it guarantees that the operation that you perform is thread-safe.\nimport Foundation struct WeatherData: Sendable { var temperature: Double var condition: String var city: String } func fetchWeatherData(forCity city: String) async -\u0026gt; WeatherData { try? await Task.sleep(nanoseconds: 1_000_000_000) return WeatherData(temperature: 72.0, condition: \u0026#34;Sunny\u0026#34;, city: city) } import SwiftUI @MainActor class WeatherViewModel: ObservableObject { @Published var currentWeather: WeatherData? func updateWeather(forCity city: String) { Task { let weatherData = await fetchWeatherData(forCity: city) // Since WeatherData conforms to Sendable, this is safe self.currentWeather = weatherData } } } Thank you for reading!\n","permalink":"http://localhost:1313/posts/modern-concurrency/","summary":"When was it introduced? It was introduced in Swift 5.5 at WWDC 2021.\nYou can find the more comprehensive info about Modern Concurrency in Swift Concurrency Manifesto.\nWhat are actors? Actors eliminate shared mutable state and explicit synchronization through deep copying of all the data that passed to an actor to a message sent and preventing direct access to actor state. Actors are reference types.\nactor DatabaseManager { private var data: [String: String] = [:] func readData(key: String) -\u0026gt; String?","title":"Modern Concurrency"},{"content":"What is the Thread? A Thread is a small set of instructions that can be executed independently from the main program. Threads are often used to improve program performance by allowing multiple tasks to be executed at the same time. The Thread has its own stack, registers, and program counters.\nThreads share memory address space, and it is possible to communicate between Threads using shared memory space. How to use it? You can create a single Thread by the following example:\n// Create a new thread and start it let newThread = Thread { } newThread.start() What else can you do? You can:\ncancel exit sleep etc You can check the current Thread execution state: isExecuting isFinished isCancelled You can subclass Thread and override the main() method if you need it.\nCaveats The main problem with Threads is that you must manually manage relationships between them. It can cause testability, readability, and potentially Thread Explosion issues.\nWhat is Thread Explosion? Thread Explosion occurs when a system has too many running Threads simultaneously. It can cause performance issues such as memory overhead and cost of context switching (CPU cycles).\nTips You can delegate your work with Threads to Grand Central Dispatch (GCD).\nGCD provides an API that manages the number of Threads automatically.\nYou can also use async/await and Task functionality from Swift 5.5 that helps manage the number of Threads in poll-based factors like system load and the number of available CPUs. If you have a long-running operation, you can call the Task.yield() method and let other tasks in your program make progress on their work.\nThank you for reading!\n","permalink":"http://localhost:1313/posts/what-are-threads-in-swift/","summary":"What is the Thread? A Thread is a small set of instructions that can be executed independently from the main program. Threads are often used to improve program performance by allowing multiple tasks to be executed at the same time. The Thread has its own stack, registers, and program counters.\nThreads share memory address space, and it is possible to communicate between Threads using shared memory space. How to use it?","title":"What are Threads in Swift?"},{"content":"What is DispatchGroup? DispatchGroup provides a mechanism to track the completion group of tasks.\nHow DispatchGroup works? DispatchGroup has three main methods, enter, leave and notify, that allow you to control the completion of a specific task.\nlet dispatchGroup = DispatchGroup() dispatchGroup.enter() dispatchGroup.leave() dispatchGroup.notify(queue: .main) {} Let`s talk about each of these methods. enter ‚Äî manually indicate a block has entered group. leave ‚Äî manually indicate a block in the group has been completed. notify(queue: ) ‚Äî schedule a block to be submitted to a queue when all the blocks associated with a group have been completed. The queue parameter is the queue to which the supplied block will be submitted when the group is complete.\nHow to implement DispatchGroup? You can implement DispatchGroup following these steps:\nlet dispatchGroup = DispatchGroup() dispatchGroup.enter() fetchGitHubUser1 { print(\u0026#34;fetchGitHubUser1 task completed\u0026#34;) dispatchGroup.leave() } dispatchGroup.enter() fetchGitHubUser2 { print(\u0026#34;fetchGitHubUser2 task completed\u0026#34;) dispatchGroup.leave() } dispatchGroup.notify(queue: .main) { print(\u0026#34;All tasks completed\u0026#34;) } // prints fetchGitHubUser1 task started fetchGitHubUser2 task started fetchGitHubUser1 task completed fetchGitHubUser2 task completed All tasks completed Pros You can create a group of tasks and track when all tasks finish their work. You can specify a queue where you want to be notified about completed operations.\nCons You should manually manage enter and leave operations that increase complexity and the chance of error. You can accidentally forget to write the leave operation, which can cause unpredictable behavior.\n","permalink":"http://localhost:1313/posts/dispatchgroup-in-swift/","summary":"What is DispatchGroup? DispatchGroup provides a mechanism to track the completion group of tasks.\nHow DispatchGroup works? DispatchGroup has three main methods, enter, leave and notify, that allow you to control the completion of a specific task.\nlet dispatchGroup = DispatchGroup() dispatchGroup.enter() dispatchGroup.leave() dispatchGroup.notify(queue: .main) {} Let`s talk about each of these methods. enter ‚Äî manually indicate a block has entered group. leave ‚Äî manually indicate a block in the group has been completed.","title":"DispatchGroup in Swift"},{"content":"What is concurrency? The system can perform multiple tasks simultaneously. By tasks, I mean code or instructions. Modern computer chips have multiple cores that allow developers to create and run various tasks on multiple cores. Even if your chip has one core operating system it will provide context switching mechanism by enabling it to execute multiple tasks concurrently.\nMaterial about processes, threads I will skip explaining concepts about processes and threads because it is a vast topic, and it will take a lot of time to explain it. I attached links to the material to help you understand it more deeply. https://youtu.be/4rLW7zg21gI?si=49hq8Wrbpmeev41k https://youtu.be/r2__Rw8vu1M?si=b7b257Qu4Bty7OxA I will focus on implementation.\nThe old and modern way of implementing concurrency You can divide concurrency implementation into old or unstructured and modern or structured.\nBy old, I mean GCD (Grand Central Dispatch). By modern, I mean async/await, actor, and Task.\nIn this article, I will talk about the old way. GCD helps you keep your distance from manually managing threads and avoid unnecessary complexity, and it does it by providing API. One of these APIs is DispatchQueue.\nDispatchQueue By default, DispatchQueue is serial; all work on this queue will be executed sequentially. DispatchQueue has access to the main property and the global() method. The main property returns the serial queue associated with the main thread of the current process. The global() method returns a concurrent queue specified by quality-of-service level.\npublic class func global(qos: DispatchQoS.QoSClass = .default) -\u0026gt; DispatchQueue You can pass many parameters when you try to initialize a new queue.\npublic convenience init(label: String, qos: DispatchQoS = .unspecified, attributes: DispatchQueue.Attributes = [], autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency = .inherit, target: DispatchQueue? = nil) Let‚Äôs talk about three of them (label, qos, attributes). The first is label, which is used mainly for debugging and identification.\nlet queue = DispatchQueue(label: \u0026#34;com.example.myqueue\u0026#34;) The second one is qos (Quality Of Service) allows you to choose the priority in which you like to run your task. You can choose between background, utility, default, userInitiated, userIneractive, and unspecified priorities.\n/// qos_class_t public struct DispatchQoS : Equatable { public let qosClass: DispatchQoS.QoSClass public let relativePriority: Int @available(macOS 10.10, iOS 8.0, *) public static let background: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let utility: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let `default`: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let userInitiated: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let userInteractive: DispatchQoS public static let unspecified: DispatchQoS } userIneractive has the highest priority; it usually calls when you need to display UI almost immediately.\nbackground, on the other hand, has the lowest priority.\nHow to achieve concurrency with DispatchQueue API? You can use a serial queue with the following: sync functionality allows you to wait until the block you passed finishes its work.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serial\u0026#34;) serialQueue.sync {} async functionality will schedule your work and be executed later in time.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serial\u0026#34;) serialQueue.async {} Or you can use a concurrent queue with similar methods but running your task in parallel.\nlet concurrentQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.concurrent\u0026#34;, attributes: .concurrent) concurrentQueue.sync {} concurrentQueue.async {} The difference between serial queue and concurrent queue The difference between a serial and concurrent queue is that you should not wait until the concurrent operation finishes work in the async block.\nlet concurrentQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.concurrent\u0026#34;, attributes: .concurrent) concurrentQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } concurrentQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Concurrent Queue Task 6 is running on Concurrent Queue Task 2 is running on Concurrent Queue Task 7 is running on Concurrent Queue Task 3 is running on Concurrent Queue Task 8 is running on Concurrent Queue Task 4 is running on Concurrent Queue Task 9 is running on Concurrent Queue Task 5 is running on Concurrent Queue Task 10 is running on Concurrent Queue The serial queue executes tasks in order, and you should wait until the first async block finishes its work to start the second block.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serual\u0026#34;) serialQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } serialQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Serial Queue Task 2 is running on Serial Queue Task 3 is running on Serial Queue Task 4 is running on Serial Queue Task 5 is running on Serial Queue Task 6 is running on Serial Queue Task 7 is running on Serial Queue Task 8 is running on Serial Queue Task 9 is running on Serial Queue Task 10 is running on Serial Queue When you try to use the sync functionality, it behaves similarly on serial and concurrent queues by executing each task step by step and waiting till each block finishes its work.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serial\u0026#34;) serialQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } serialQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Serial Queue Task 2 is running on Serial Queue Task 3 is running on Serial Queue Task 4 is running on Serial Queue Task 5 is running on Serial Queue Task 6 is running on Serial Queue Task 7 is running on Serial Queue Task 8 is running on Serial Queue Task 9 is running on Serial Queue Task 10 is running on Serial Queue let concurrentQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.concurrent\u0026#34;, attributes: .concurrent) concurrentQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } concurrentQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Concurrent Queue Task 2 is running on Concurrent Queue Task 3 is running on Concurrent Queue Task 4 is running on Concurrent Queue Task 5 is running on Concurrent Queue Task 6 is running on Concurrent Queue Task 7 is running on Concurrent Queue Task 8 is running on Concurrent Queue Task 9 is running on Concurrent Queue Task 10 is running on Concurrent Queue ","permalink":"http://localhost:1313/posts/concurrency-in-swift/","summary":"What is concurrency? The system can perform multiple tasks simultaneously. By tasks, I mean code or instructions. Modern computer chips have multiple cores that allow developers to create and run various tasks on multiple cores. Even if your chip has one core operating system it will provide context switching mechanism by enabling it to execute multiple tasks concurrently.\nMaterial about processes, threads I will skip explaining concepts about processes and threads because it is a vast topic, and it will take a lot of time to explain it.","title":"Concurrency in Swift"},{"content":"What are value types? Value types play a central role in programming languages by grouping data values.\n`Value type‚Äù is a type of data copied when assigned to a new variable.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` How can you pass value types? You can pass value type by copying value.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` copiedStorage.data = \u0026#34;new data\u0026#34; // Changes `copiedStorage`, not `originalStorage` print(\u0026#34;\\(originalStorage.data), \\(copiedStorage.data)\u0026#34;) // prints \u0026#34;some data, new data\u0026#34; The effect of assignment, initialization, and argument passing creates an independent instance with a unique copy of its data.\nWhat types are value types? Value types can be struct, enum, tuple.\nWhat data types are value types? Strings, Arrays, Dictionaries, Numbers, Booleans, Floating-point numbers, and Integers are all value types.\nHow value types are stored in memory? The value types use Stack data structure for memory management.\nWhat is Copy-on-write mechanism? The copy-on-write mechanism is a resource-management technique used to optimize value types performance. It improves performance by avoiding unnecessary copies of value types. If resource is duplicated but not modified it‚Äôs unnecessary to create new resource.\nWhen to use value types? Choose value types if you don‚Äôt have shared mutable state.\n","permalink":"http://localhost:1313/posts/what-are-value-types-in-swift/","summary":"What are value types? Value types play a central role in programming languages by grouping data values.\n`Value type‚Äù is a type of data copied when assigned to a new variable.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` How can you pass value types? You can pass value type by copying value.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` copiedStorage.","title":"What are value types in Swift?"},{"content":"I was searching for tools that could help me find memory leaks faster and would be simple in implementation without affecting performance and memory size of application.\nI found a fantastic fit for this task LifetimeTracker developed by Krzysztof Zab≈Çocki.\nAll you need is to add LifetimeTracker package to the project, inherit from LifetimeTrackable protocol, and add two lines of code.\nclass Department: LifetimeTrackable {} trackLifetime method to init of instance that you are going to verify, and lifetimeConfiguration property where you set max number of valid instances.\nclass Department: LifetimeTrackable { static var lifetimeConfiguration = LifetimeConfiguration(maxCount: 1, groupName: \u0026#34;Department\u0026#34;) let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) trackLifetime() } var employee: Employee? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } The final step is to add LifetimeTracker.setup to didFinishLaunchingWithOptions to be able to see Dashboard with detected issues.\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { #if DEBUG LifetimeTracker.setup( onUpdate: LifetimeTrackerDashboardIntegration( visibility: .alwaysVisible, style: .bar, textColorForNoIssues: .systemGreen, textColorForLeakDetected: .systemRed ).refreshUI ) #else #endif return true } I hope this article will help you save time finding and debugging this tricky task :-).\n","permalink":"http://localhost:1313/posts/how-to-prevent-memory-leaks/","summary":"I was searching for tools that could help me find memory leaks faster and would be simple in implementation without affecting performance and memory size of application.\nI found a fantastic fit for this task LifetimeTracker developed by Krzysztof Zab≈Çocki.\nAll you need is to add LifetimeTracker package to the project, inherit from LifetimeTrackable protocol, and add two lines of code.\nclass Department: LifetimeTrackable {} trackLifetime method to init of instance that you are going to verify, and lifetimeConfiguration property where you set max number of valid instances.","title":"How to prevent memory leaks?"},{"content":"The common way to find memory leaks is by using Xcode Instruments. All you need is the following:\nOpen Xcode Instruments\nChoose Leaks option Select Simulator where you are going to test your application Select your installed application When you finish preparation, you can start immediate recoding and check application for leaks. To do that, you need to open Simulator and try some cases that could cause memory leaks.\nAfter you spend some time trying different scenarios, you can see that Instruments found Leaked Objects. Another way to find memory leaks is by using Debug Memory Graph in Xcode Debug Area. Inside Debug Memory Graph, you can find MemoryLeaks section. MemoryLeaks section displays what objects have strong reference cycles between themselves.\nAll tools above have opportunity to find and highlight potential issues and help you resolve them.\n","permalink":"http://localhost:1313/posts/how-to-find-memory-leaks/","summary":"The common way to find memory leaks is by using Xcode Instruments. All you need is the following:\nOpen Xcode Instruments\nChoose Leaks option Select Simulator where you are going to test your application Select your installed application When you finish preparation, you can start immediate recoding and check application for leaks. To do that, you need to open Simulator and try some cases that could cause memory leaks.\nAfter you spend some time trying different scenarios, you can see that Instruments found Leaked Objects.","title":"How to find memory leaks?"},{"content":"What is ARC? Swift uses Automatic Reference Counting (ARC) to track and manage your app‚Äôs memory usage. In most cases, this means that memory management ‚Äújust works‚Äù in Swift, and you don‚Äôt need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed. - Apple\nARC In Action In this example, we assign an instance to the reference1 property.\nnumber of references equals 1. class Storage { let data: Data init(data: Data) { self.data = data print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var reference1: Storage? var reference2: Storage? var reference3: Storage? reference1 = Storage(data: Data()) Now we can assign a reference to another two properties, reference2 and reference3. Whenever you assign a reference, you increase the counter.\nnumber of references equals 3. reference2 = reference1 reference3 = reference1 When you set reference2 and reference3 to nil, the number of references equals 1.\nreference2 = nil reference3 = nil Only when you set reference1 to nil object will be deinitialized.\nreference1 = nil Memory leaks Memory leaks appear when you have strong references between two instances that point to each other.\nIn this example, class Employee has optional department property, and class Department has optional employee property.\nclass Department { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } var employee: Employee? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } class Employee { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } var department: Department? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var employee: Employee? var department: Department? employee = Employee(name: \u0026#34;John Doe\u0026#34;) department = Department(name: \u0026#34;Research and development\u0026#34;) If we try to assign Department reference to employee property and Employee reference to department property, it creates a memory leak by strong references that point to each other.\nemployee!.department = department department!.employee = employee If you try to set employee and department properties to nil, then these two objects can‚Äôt be deallocated because of the existing strong reference relationship between both objects.\nemployee = nil department = nil To avoid this unpleasant situation, we can use weak, unowned references.\nWeak reference If you use a weak keyword before a property, you say that this property should not keep a strong reference. Weak property should always be mutable and optional because ARC set the property to nil after the instance was deallocated.\nIn this example, Employee instance has department property with weak keyword. It means when we set employee property to nil ARC sets department property to nil and deallocates Department instance.\nclass Department { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } var employee: Employee? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } class Employee { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } weak var department: Department? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var employee: Employee? var department: Department? employee = Employee(name: \u0026#34;John Doe\u0026#34;) department = Department(name: \u0026#34;Research and development\u0026#34;) employee!.department = department department!.employee = employee department = nil employee = nil Unowned reference Unowned reference can‚Äôt be optional, and it should always have value. If you try to access a deallocated property value, you will face a runtime error.\nIn this example, we have two instances: User and DiscountCard. DiscountCard has a relationship with the User that is marked as unowned to avoid a strong reference cycle.\nclass User { let name: String var discountCard: DiscountCard? init(name: String) { self.name = name } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } class DiscountCard { let number: UInt64 unowned let user: User init(number: UInt64, user: User) { self.number = number self.user = user } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var user: User? user = User(name: \u0026#34;John Doe\u0026#34;) When you create DiscountCard instance and assign it as reference to user property, it no longer holds strong reference.\nuser!.discountCard = DiscountCard(number: 1234_5678_9012_3456, user: user!) After we set user property to nil, it will deallocate User and DiscountCard instances.\nuser = nil Strong Reference Cycles for Closures Strong reference cycle for closure can occur if you assign closure to property of instance. In this case, you assign reference to that closure. The strong reference cycle appears because closures are reference types.\nclass MemoryStorage { let text: String let additionalText: String? lazy var copy: () -\u0026gt; String = { if let additionalText = self.additionalText { self.text + \u0026#34;\\n\u0026#34; + additionalText } else { self.text } } init(text: String, additionalText: String? = nil) { self.text = text self.additionalText = additionalText } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var memoryStorage: MemoryStorage? = MemoryStorage(text: \u0026#34;Thank you for registration\u0026#34;, additionalText: \u0026#34;John Doe\u0026#34;) print(memoryStorage!.copy()) memoryStorage = nil In this example, closure captures self.text property and create strong reference cycle by referencing to self.\nBreaking Strong Reference Cycle in Closure To break strong reference cycle, we need to add capture list with unowned keyword to copy closure.\nclass MemoryStorage { let text: String let additionalText: String? lazy var copy: () -\u0026gt; String = { [unowned self] in if let additionalText = self.additionalText { self.text + \u0026#34;\\n\u0026#34; + additionalText } else { self.text } } init(text: String, additionalText: String? = nil) { self.text = text self.additionalText = additionalText } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var memoryStorage: MemoryStorage? = MemoryStorage(text: \u0026#34;Thank you for registration\u0026#34;, additionalText: \u0026#34;John Doe\u0026#34;) print(memoryStorage!.copy()) memoryStorage = nil ","permalink":"http://localhost:1313/posts/arc-in-swift/","summary":"What is ARC? Swift uses Automatic Reference Counting (ARC) to track and manage your app‚Äôs memory usage. In most cases, this means that memory management ‚Äújust works‚Äù in Swift, and you don‚Äôt need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed. - Apple\nARC In Action In this example, we assign an instance to the reference1 property.","title":"ARC in Swift"},{"content":"Introduction In this article, I‚Äôm going to briefly explain what closure is.\nClosures is self-conitained blocks of funcionality that can be passed around and used in your code. ‚Äî Apple\nExpression:\n{ (params) -\u0026gt; return value in statements } @escaping When closure is marked as escaping, it will outlive or leave the scope you passed.\nfunc response(_ completionHandler: @escaping(Result) -\u0026gt; Void) { completionHandler(.success) } @nonescaping By default, closures are nonescaping, meaning closure will no longer exist in memory after complete execution in the scope you have passed it to.\nfunc filterImage(_ completionHandler: (Image) -\u0026gt; Void) { completionHandler(UIImage.filtered) } @autoclosure Autoclosures automatically create closure from the argument that you passed into a function.\nfunc animate(_ animation: @autoclosure @escaping () -\u0026gt; Void, duration: TimeInterval = 0.25) { UIView.animate(withDuration: duration, animations: animation) } Closure conceptualy looks like this first pointer points to the code that implements closure the second pointer pointed to the reference counted object.\nstruct Closure { var functionPointer: UnsafeRawPointer var closureContext: AnyObject? } ","permalink":"http://localhost:1313/posts/what-is-closure-in-swift-language/","summary":"Introduction In this article, I‚Äôm going to briefly explain what closure is.\nClosures is self-conitained blocks of funcionality that can be passed around and used in your code. ‚Äî Apple\nExpression:\n{ (params) -\u0026gt; return value in statements } @escaping When closure is marked as escaping, it will outlive or leave the scope you passed.\nfunc response(_ completionHandler: @escaping(Result) -\u0026gt; Void) { completionHandler(.success) } @nonescaping By default, closures are nonescaping, meaning closure will no longer exist in memory after complete execution in the scope you have passed it to.","title":"What is closure in Swift language?"},{"content":"Introduction In Swift, classes, closures, and actors all reference types.\n\u0026lsquo;Reference type‚Äô is instance that shares a single copy of data.\nAssigning a reference type to a constant or variable, or passing it into a function or method, it is always a reference to a shared instance that is assigned or passed in.\nExample You can pass your property value by sharing the same address in memory.\n// Reference type example class Storage { var data = ‚Äúdata-example‚Äù } var storage = Storage() print(\u0026#34;\\(storage.data)\u0026#34;) // prints \u0026#34;data-example\u0026#34; print(\u0026#34;storage address:\u0026#34;, Unmanaged.passUnretained(storage).toOpaque()) var copiedStorage = storage copiedStorage.data = ‚Äúnew-data‚Äù print(\u0026#34;\\(storage.data), \\(copiedStorage.data)\u0026#34;) // prints \u0026#34;new-data, new-data\u0026#34; print(\u0026#34;copiedStorage address:\u0026#34;, Unmanaged.passUnretained(copiedStorage).toOpaque()) As you can see, storage and copied storage property addresses are the same.\nSummary Copying data by reference refers to the same address in memory. This means that modifying data in one variable also affects another. It also means that multiple reference types may refer to the same object.\n","permalink":"http://localhost:1313/posts/what-is-reference-type-in-swift/","summary":"Introduction In Swift, classes, closures, and actors all reference types.\n\u0026lsquo;Reference type‚Äô is instance that shares a single copy of data.\nAssigning a reference type to a constant or variable, or passing it into a function or method, it is always a reference to a shared instance that is assigned or passed in.\nExample You can pass your property value by sharing the same address in memory.\n// Reference type example class Storage { var data = ‚Äúdata-example‚Äù } var storage = Storage() print(\u0026#34;\\(storage.","title":"What is ‚Äúreference type‚Äù in Swift?"},{"content":"Introduction The Composable Architecture (TCA) uses a unidirectional data flow (UDF). UDF is a design pattern where data and events move consistently and predictably. In UDF, data can only be transferred to other application parts in one way.\nIn TCA, the only way to mutate the state is by sending actions to a runtime store. The runtime store holds the entire app‚Äôs business logic and mutates the state inside.\nUDF can reduce data inconsistencies because of the single source of truth for the application.\nTCA is built around key components: Action State Reducer Effect Store Environment Code examples: Timer\nhttps://github.com/dmytrochumakov/TCA-Examples/tree/main/Timer/Timer/Timer Sources: https://github.com/pointfreeco/swift-composable-architecture https://www.youtube.com/watch?v=SfFDj6qT-xg\u0026ab_channel=SwiftandTips https://www.youtube.com/watch?v=XWZmgbylTpc\u0026ab_channel=SwiftHeroes https://www.youtube.com/watch?v=McmGb9sexMo\u0026ab_channel=SwiftandTips https://www.youtube.com/watch?v=McmGb9sexMo\u0026ab_channel=SwiftandTips https://markvillar.com/the-composable-architecture/ ","permalink":"http://localhost:1313/posts/lets-talk-about-composable-architecture/","summary":"Introduction The Composable Architecture (TCA) uses a unidirectional data flow (UDF). UDF is a design pattern where data and events move consistently and predictably. In UDF, data can only be transferred to other application parts in one way.\nIn TCA, the only way to mutate the state is by sending actions to a runtime store. The runtime store holds the entire app‚Äôs business logic and mutates the state inside.\nUDF can reduce data inconsistencies because of the single source of truth for the application.","title":"Let‚Äôs talk about Composable Architecture"},{"content":" Hi! I'm Dmytro Chumakov.\nHighly skilled iOS Developer with extensive experience in developing, and testing mobile application projects.\nProficient in Swift, Objective-C, and SwiftUI, with a strong foundation in modern software engineering practices.\nKnown for enhancing application performance, and automating repetitive tasks.\nMy Values Innovation: I consistently seek innovative solutions, leveraging modern technologies and creative thinking to stay ahead of the curve.\nEfficiency: My focus on streamlining processes and maximizing productivity underscores my commitment to efficiency in every aspect of my work.\nQuality: I am dedicated to delivering high-quality products, ensuring excellence through thorough testing, documentation, and performance optimization.\nUser-Centricity: My development approach prioritizes user needs and experience, crafting applications that prioritize safety, interaction, and functionality.\nContinuous Learning: I actively pursue ongoing learning and skill development, staying updated with the latest industry trends and technologies.\nCollaboration: I thrive in collaborative environments, leveraging leadership skills to drive teamwork and achieve collective success in project delivery.\nCommunity Engagement: I am passionate about sharing knowledge and contributing to the developer community through technical posts and videos, fostering growth and learning for others.\n","permalink":"http://localhost:1313/about/","summary":"Information about me.","title":"About Me"},{"content":" ","permalink":"http://localhost:1313/newsletter/","summary":"newsletter","title":"Newsletter"}]