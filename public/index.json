[{"content":"Introduction You can easily deliver an iOS app in two ways: through beta and release lanes.\nThe First Way - TestFlight By creating a beta lane inside the Fastfile. It utilizes:\nbuild_app: To easily build and sign your app (via gym). pilot: Makes it easier to manage your app on Apple’s TestFlight. lane :beta do build_app(scheme: \u0026#34;YourScheme\u0026#34;) pilot end To run Fastlane:\nfastlane beta Attention Before proceeding, you need to have the ipa or pkg file generated.\nThe Second Way - App Store Connect By creating a release lane inside the Fastfile. It utilizes:\ngym: To build and package iOS apps for you. deliver: To upload screenshots, metadata, and binaries to App Store Connect. lane :release do gym # Builds the app deliver # Uploads the app to App Store Connect end To run Fastlane:\nfastlane release If you haven\u0026rsquo;t installed Fastlane yet, here are the steps: Outline of the Process\nInstall Fastlane: You can do so using RubyGems, which is the Ruby package manager: brew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running: fastlane init ","permalink":"http://localhost:1313/posts/post-14/","summary":"Introduction You can easily deliver an iOS app in two ways: through beta and release lanes.\nThe First Way - TestFlight By creating a beta lane inside the Fastfile. It utilizes:\nbuild_app: To easily build and sign your app (via gym). pilot: Makes it easier to manage your app on Apple’s TestFlight. lane :beta do build_app(scheme: \u0026#34;YourScheme\u0026#34;) pilot end To run Fastlane:\nfastlane beta Attention Before proceeding, you need to have the ipa or pkg file generated.","title":"Delivering iOS app using Fastlane"},{"content":"Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to archive a project in the fastest way.\nOne of such ways is by using the xcodebuild archive command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild archive: Once you\u0026rsquo;re in the project directory, you can run xcodebuild archive with the appropriate parameters to build your project. Example: xcodebuild archive -scheme YourSchemeName -archivePath ~/Desktop/YourAppName.xcarchive Another way is by integrating fastlane into your workflow: Outline of the process Install Fastlane: If you haven\u0026rsquo;t already installed Fastlane, you can do so using RubyGems, which is the Ruby package manager:\nbrew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running:\nfastlane init Create a lane for archiving: Open your Fastfile located in the fastlane directory of your project, and add a new lane for archiving:\nlane :archive do gym( scheme: \u0026#34;YourSchemeName\u0026#34;, output_directory: \u0026#34;/path/to/your/archive/directory\u0026#34;, output_name: \u0026#34;YourAppName\u0026#34; ) end Run the archive lane: Once you\u0026rsquo;ve defined the archive lane, you can run it using the following command:\nfastlane archive ","permalink":"http://localhost:1313/posts/post-6/","summary":"Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to archive a project in the fastest way.\nOne of such ways is by using the xcodebuild archive command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project.","title":"Archiving Xcode project using the CLI"},{"content":"Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to test a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project. Example: xcodebuild -project YourProject.xcodeproj -scheme YourSchemeName test Another way is by integrating fastlane into your workflow: Outline of the process Install Fastlane: If you haven\u0026rsquo;t already installed Fastlane, you can do so using RubyGems, which is the Ruby package manager:\nbrew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running:\nfastlane init Define a Lane for Testing: Open your Fastfile and define a lane for running tests. Here\u0026rsquo;s a basic example:\nlane :run_tests do scan(scheme: \u0026#34;YourSchemeName\u0026#34;) end Run Tests Using Fastlane: You can now run your tests using the lane you defined. In the terminal, navigate to your project directory and run:\nfastlane run_tests Testing a project through a project generation tools If you are testing a project through a project generation tool like tuist you do not need anything that was mentioned above because it already has build-in commands:\ntuist test YourSchemeName ","permalink":"http://localhost:1313/posts/post-3/","summary":"Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to test a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project.","title":"Testing Xcode project using the CLI"},{"content":"Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to build a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project. Example: xcodebuild -project YourProjectName.xcodeproj -scheme YourSchemeName Another way is by integrating fastlane into your workflow: Outline of the process Install Fastlane: If you haven\u0026rsquo;t already installed Fastlane, you can do so using RubyGems, which is the Ruby package manager:\nbrew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running:\nfastlane init Build with Fastlane: Once Fastlane is set up, you can use it to build your Xcode project. Fastlane provides a lane named build_app for building your app. You can run this lane with the following command:\nfastlane build_app Building a project through a project generation tools If you are building a project through a project generation tool like tuist you do not need anything that was mentioned above because it already has build-in commands tuist build.\n","permalink":"http://localhost:1313/posts/post-2/","summary":"Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to build a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project.","title":"Building Xcode project using the CLI"},{"content":"In this article: What is a Visitor Pattern? What problems does it solve? Real-world code example What is a Visitor Pattern? The Visitor Pattern helps add new capabilities to a composite of objects.\nSource\nWhat problems does it solve? The Visitor Pattern helps solve following problems:\nSeparation of Concerns: The Visitor Pattern separates algorithms from the objects on which they operate. This allows for clean code organization by keeping algorithms and operations separate from the data structures they operate on. Extensibility: It allows you to add new operations to existing object structures without modifying those structures. This is especially useful when dealing with complex object hierarchies where adding new functionality directly to the classes would lead to code bloat and tight coupling. Traversal of Object Structures: It provides a way to traverse complex object structures while performing some action on each element of the structure. This is particularly useful in scenarios where you need to process every element of a data structure in a specific order or with a specific algorithm. Real-world code example // Element protocol representing the items on the menu protocol MenuItem { func accept(visitor: OrderVisitor) } // Concrete item types class Coffee: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } class Tea: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } class Pastry: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } // Visitor protocol defining the operations to be performed on menu items protocol OrderVisitor { func visit(_ item: Coffee) func visit(_ item: Tea) func visit(_ item: Pastry) } // Concrete visitor implementing operations on menu items class TotalCostVisitor: OrderVisitor { var totalCost = 0.0 func visit(_ item: Coffee) { totalCost += item.price } func visit(_ item: Tea) { totalCost += item.price } func visit(_ item: Pastry) { totalCost += item.price } } class ItemDetailsVisitor: OrderVisitor { var details = \u0026#34;\u0026#34; func visit(_ item: Coffee) { details += \u0026#34;Coffee: \\(item.name), Price: $\\(item.price)\\n\u0026#34; } func visit(_ item: Tea) { details += \u0026#34;Tea: \\(item.name), Price: $\\(item.price)\\n\u0026#34; } func visit(_ item: Pastry) { details += \u0026#34;Pastry: \\(item.name), Price: $\\(item.price)\\n\u0026#34; } } // Example usage let items: [MenuItem] = [Coffee(name: \u0026#34;Espresso\u0026#34;, price: 2.5), Tea(name: \u0026#34;Green Tea\u0026#34;, price: 2.0), Pastry(name: \u0026#34;Croissant\u0026#34;, price: 3.0)] let totalCostVisitor = TotalCostVisitor() for item in items { item.accept(visitor: totalCostVisitor) } print(\u0026#34;Total cost of the order: $\\(totalCostVisitor.totalCost)\u0026#34;) let itemDetailsVisitor = ItemDetailsVisitor() for item in items { item.accept(visitor: itemDetailsVisitor) } print(\u0026#34;Order details:\u0026#34;) print(itemDetailsVisitor.details) ","permalink":"http://localhost:1313/posts/post-1/","summary":"In this article: What is a Visitor Pattern? What problems does it solve? Real-world code example What is a Visitor Pattern? The Visitor Pattern helps add new capabilities to a composite of objects.\nSource\nWhat problems does it solve? The Visitor Pattern helps solve following problems:\nSeparation of Concerns: The Visitor Pattern separates algorithms from the objects on which they operate. This allows for clean code organization by keeping algorithms and operations separate from the data structures they operate on.","title":"The Visitor Pattern"},{"content":"What is DispatchGroup? DispatchGroup provides a mechanism to track the completion group of tasks.\nHow DispatchGroup works? DispatchGroup has three main methods, enter, leave and notify, that allow you to control the completion of a specific task.\nlet dispatchGroup = DispatchGroup() dispatchGroup.enter() dispatchGroup.leave() dispatchGroup.notify(queue: .main) {} Let`s talk about each of these methods. enter — manually indicate a block has entered group. leave — manually indicate a block in the group has been completed. notify(queue: ) — schedule a block to be submitted to a queue when all the blocks associated with a group have been completed. The queue parameter is the queue to which the supplied block will be submitted when the group is complete.\nHow to implement DispatchGroup? You can implement DispatchGroup following these steps:\nlet dispatchGroup = DispatchGroup() dispatchGroup.enter() fetchGitHubUser1 { print(\u0026#34;fetchGitHubUser1 task completed\u0026#34;) dispatchGroup.leave() } dispatchGroup.enter() fetchGitHubUser2 { print(\u0026#34;fetchGitHubUser2 task completed\u0026#34;) dispatchGroup.leave() } dispatchGroup.notify(queue: .main) { print(\u0026#34;All tasks completed\u0026#34;) } // prints fetchGitHubUser1 task started fetchGitHubUser2 task started fetchGitHubUser1 task completed fetchGitHubUser2 task completed All tasks completed Pros You can create a group of tasks and track when all tasks finish their work. You can specify a queue where you want to be notified about completed operations.\nCons You should manually manage enter and leave operations that increase complexity and the chance of error. You can accidentally forget to write the leave operation, which can cause unpredictable behavior.\n","permalink":"http://localhost:1313/posts/post-13/","summary":"What is DispatchGroup? DispatchGroup provides a mechanism to track the completion group of tasks.\nHow DispatchGroup works? DispatchGroup has three main methods, enter, leave and notify, that allow you to control the completion of a specific task.\nlet dispatchGroup = DispatchGroup() dispatchGroup.enter() dispatchGroup.leave() dispatchGroup.notify(queue: .main) {} Let`s talk about each of these methods. enter — manually indicate a block has entered group. leave — manually indicate a block in the group has been completed.","title":"DispatchGroup in Swift"},{"content":"What is concurrency? The system can perform multiple tasks simultaneously. By tasks, I mean code or instructions. Modern computer chips have multiple cores that allow developers to create and run various tasks on multiple cores. Even if your chip has one core operating system it will provide context switching mechanism by enabling it to execute multiple tasks concurrently.\nMaterial about processes, threads I will skip explaining concepts about processes and threads because it is a vast topic, and it will take a lot of time to explain it. I attached links to the material to help you understand it more deeply. https://youtu.be/4rLW7zg21gI?si=49hq8Wrbpmeev41k https://youtu.be/r2__Rw8vu1M?si=b7b257Qu4Bty7OxA I will focus on implementation.\nThe old and modern way of implementing concurrency You can divide concurrency implementation into old or unstructured and modern or structured.\nBy old, I mean GCD (Grand Central Dispatch). By modern, I mean async/await, actor, and Task.\nIn this article, I will talk about the old way. GCD helps you keep your distance from manually managing threads and avoid unnecessary complexity, and it does it by providing API. One of these APIs is DispatchQueue.\nDispatchQueue By default, DispatchQueue is serial; all work on this queue will be executed sequentially. DispatchQueue has access to the main property and the global() method. The main property returns the serial queue associated with the main thread of the current process. The global() method returns a concurrent queue specified by quality-of-service level.\npublic class func global(qos: DispatchQoS.QoSClass = .default) -\u0026gt; DispatchQueue You can pass many parameters when you try to initialize a new queue.\npublic convenience init(label: String, qos: DispatchQoS = .unspecified, attributes: DispatchQueue.Attributes = [], autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency = .inherit, target: DispatchQueue? = nil) Let’s talk about three of them (label, qos, attributes). The first is label, which is used mainly for debugging and identification.\nlet queue = DispatchQueue(label: \u0026#34;com.example.myqueue\u0026#34;) The second one is qos (Quality Of Service) allows you to choose the priority in which you like to run your task. You can choose between background, utility, default, userInitiated, userIneractive, and unspecified priorities.\n/// qos_class_t public struct DispatchQoS : Equatable { public let qosClass: DispatchQoS.QoSClass public let relativePriority: Int @available(macOS 10.10, iOS 8.0, *) public static let background: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let utility: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let `default`: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let userInitiated: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let userInteractive: DispatchQoS public static let unspecified: DispatchQoS } userIneractive has the highest priority; it usually calls when you need to display UI almost immediately.\nbackground, on the other hand, has the lowest priority.\nHow to achieve concurrency with DispatchQueue API? You can use a serial queue with the following: sync functionality allows you to wait until the block you passed finishes its work.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serial\u0026#34;) serialQueue.sync {} async functionality will schedule your work and be executed later in time.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serial\u0026#34;) serialQueue.async {} Or you can use a concurrent queue with similar methods but running your task in parallel.\nlet concurrentQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.concurrent\u0026#34;, attributes: .concurrent) concurrentQueue.sync {} concurrentQueue.async {} The difference between serial queue and concurrent queue The difference between a serial and concurrent queue is that you should not wait until the concurrent operation finishes work in the async block.\nlet concurrentQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.concurrent\u0026#34;, attributes: .concurrent) concurrentQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } concurrentQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Concurrent Queue Task 6 is running on Concurrent Queue Task 2 is running on Concurrent Queue Task 7 is running on Concurrent Queue Task 3 is running on Concurrent Queue Task 8 is running on Concurrent Queue Task 4 is running on Concurrent Queue Task 9 is running on Concurrent Queue Task 5 is running on Concurrent Queue Task 10 is running on Concurrent Queue The serial queue executes tasks in order, and you should wait until the first async block finishes its work to start the second block.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serual\u0026#34;) serialQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } serialQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Serial Queue Task 2 is running on Serial Queue Task 3 is running on Serial Queue Task 4 is running on Serial Queue Task 5 is running on Serial Queue Task 6 is running on Serial Queue Task 7 is running on Serial Queue Task 8 is running on Serial Queue Task 9 is running on Serial Queue Task 10 is running on Serial Queue When you try to use the sync functionality, it behaves similarly on serial and concurrent queues by executing each task step by step and waiting till each block finishes its work.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serial\u0026#34;) serialQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } serialQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Serial Queue Task 2 is running on Serial Queue Task 3 is running on Serial Queue Task 4 is running on Serial Queue Task 5 is running on Serial Queue Task 6 is running on Serial Queue Task 7 is running on Serial Queue Task 8 is running on Serial Queue Task 9 is running on Serial Queue Task 10 is running on Serial Queue let concurrentQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.concurrent\u0026#34;, attributes: .concurrent) concurrentQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } concurrentQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Concurrent Queue Task 2 is running on Concurrent Queue Task 3 is running on Concurrent Queue Task 4 is running on Concurrent Queue Task 5 is running on Concurrent Queue Task 6 is running on Concurrent Queue Task 7 is running on Concurrent Queue Task 8 is running on Concurrent Queue Task 9 is running on Concurrent Queue Task 10 is running on Concurrent Queue ","permalink":"http://localhost:1313/posts/post-12/","summary":"What is concurrency? The system can perform multiple tasks simultaneously. By tasks, I mean code or instructions. Modern computer chips have multiple cores that allow developers to create and run various tasks on multiple cores. Even if your chip has one core operating system it will provide context switching mechanism by enabling it to execute multiple tasks concurrently.\nMaterial about processes, threads I will skip explaining concepts about processes and threads because it is a vast topic, and it will take a lot of time to explain it.","title":"Concurrency in Swift"},{"content":"What are value types? Value types play a central role in programming languages by grouping data values.\n`Value type” is a type of data copied when assigned to a new variable.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` How can you pass value types? You can pass value type by copying value.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` copiedStorage.data = \u0026#34;new data\u0026#34; // Changes `copiedStorage`, not `originalStorage` print(\u0026#34;\\(originalStorage.data), \\(copiedStorage.data)\u0026#34;) // prints \u0026#34;some data, new data\u0026#34; The effect of assignment, initialization, and argument passing creates an independent instance with a unique copy of its data.\nWhat types are value types? Value types can be struct, enum, tuple.\nWhat data types are value types? Strings, Arrays, Dictionaries, Numbers, Booleans, Floating-point numbers, and Integers are all value types.\nHow value types are stored in memory? The value types use Stack data structure for memory management.\nWhat is Copy-on-write mechanism? The copy-on-write mechanism is a resource-management technique used to optimize value types performance. It improves performance by avoiding unnecessary copies of value types. If resource is duplicated but not modified it’s unnecessary to create new resource.\nWhen to use value types? Choose value types if you don’t have shared mutable state.\n","permalink":"http://localhost:1313/posts/post-8/","summary":"What are value types? Value types play a central role in programming languages by grouping data values.\n`Value type” is a type of data copied when assigned to a new variable.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` How can you pass value types? You can pass value type by copying value.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` copiedStorage.","title":"What are value types in Swift?"},{"content":"I was searching for tools that could help me find memory leaks faster and would be simple in implementation without affecting performance and memory size of application.\nI found a fantastic fit for this task LifetimeTracker developed by Krzysztof Zabłocki.\nAll you need is to add LifetimeTracker package to the project, inherit from LifetimeTrackable protocol, and add two lines of code.\nclass Department: LifetimeTrackable {} trackLifetime method to init of instance that you are going to verify, and lifetimeConfiguration property where you set max number of valid instances.\nclass Department: LifetimeTrackable { static var lifetimeConfiguration = LifetimeConfiguration(maxCount: 1, groupName: \u0026#34;Department\u0026#34;) let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) trackLifetime() } var employee: Employee? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } The final step is to add LifetimeTracker.setup to didFinishLaunchingWithOptions to be able to see Dashboard with detected issues.\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { #if DEBUG LifetimeTracker.setup( onUpdate: LifetimeTrackerDashboardIntegration( visibility: .alwaysVisible, style: .bar, textColorForNoIssues: .systemGreen, textColorForLeakDetected: .systemRed ).refreshUI ) #else #endif return true } I hope this article will help you save time finding and debugging this tricky task :-).\n","permalink":"http://localhost:1313/posts/post-9/","summary":"I was searching for tools that could help me find memory leaks faster and would be simple in implementation without affecting performance and memory size of application.\nI found a fantastic fit for this task LifetimeTracker developed by Krzysztof Zabłocki.\nAll you need is to add LifetimeTracker package to the project, inherit from LifetimeTrackable protocol, and add two lines of code.\nclass Department: LifetimeTrackable {} trackLifetime method to init of instance that you are going to verify, and lifetimeConfiguration property where you set max number of valid instances.","title":"How to prevent memory leaks?"},{"content":"The common way to find memory leaks is by using Xcode Instruments. All you need is the following:\nOpen Xcode Instruments\nChoose Leaks option Select Simulator where you are going to test your application Select your installed application When you finish preparation, you can start immediate recoding and check application for leaks. To do that, you need to open Simulator and try some cases that could cause memory leaks.\nAfter you spend some time trying different scenarios, you can see that Instruments found Leaked Objects. Another way to find memory leaks is by using Debug Memory Graph in Xcode Debug Area. Inside Debug Memory Graph, you can find MemoryLeaks section. MemoryLeaks section displays what objects have strong reference cycles between themselves.\nAll tools above have opportunity to find and highlight potential issues and help you resolve them.\n","permalink":"http://localhost:1313/posts/post-10/","summary":"The common way to find memory leaks is by using Xcode Instruments. All you need is the following:\nOpen Xcode Instruments\nChoose Leaks option Select Simulator where you are going to test your application Select your installed application When you finish preparation, you can start immediate recoding and check application for leaks. To do that, you need to open Simulator and try some cases that could cause memory leaks.\nAfter you spend some time trying different scenarios, you can see that Instruments found Leaked Objects.","title":"How to find memory leaks?"},{"content":"What is ARC? Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed. - Apple\nARC In Action In this example, we assign an instance to the reference1 property.\nnumber of references equals 1. class Storage { let data: Data init(data: Data) { self.data = data print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var reference1: Storage? var reference2: Storage? var reference3: Storage? reference1 = Storage(data: Data()) Now we can assign a reference to another two properties, reference2 and reference3. Whenever you assign a reference, you increase the counter.\nnumber of references equals 3. reference2 = reference1 reference3 = reference1 When you set reference2 and reference3 to nil, the number of references equals 1.\nreference2 = nil reference3 = nil Only when you set reference1 to nil object will be deinitialized.\nreference1 = nil Memory leaks Memory leaks appear when you have strong references between two instances that point to each other.\nIn this example, class Employee has optional department property, and class Department has optional employee property.\nclass Department { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } var employee: Employee? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } class Employee { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } var department: Department? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var employee: Employee? var department: Department? employee = Employee(name: \u0026#34;John Doe\u0026#34;) department = Department(name: \u0026#34;Research and development\u0026#34;) If we try to assign Department reference to employee property and Employee reference to department property, it creates a memory leak by strong references that point to each other.\nemployee!.department = department department!.employee = employee If you try to set employee and department properties to nil, then these two objects can’t be deallocated because of the existing strong reference relationship between both objects.\nemployee = nil department = nil To avoid this unpleasant situation, we can use weak, unowned references.\nWeak reference If you use a weak keyword before a property, you say that this property should not keep a strong reference. Weak property should always be mutable and optional because ARC set the property to nil after the instance was deallocated.\nIn this example, Employee instance has department property with weak keyword. It means when we set employee property to nil ARC sets department property to nil and deallocates Department instance.\nclass Department { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } var employee: Employee? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } class Employee { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } weak var department: Department? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var employee: Employee? var department: Department? employee = Employee(name: \u0026#34;John Doe\u0026#34;) department = Department(name: \u0026#34;Research and development\u0026#34;) employee!.department = department department!.employee = employee department = nil employee = nil Unowned reference Unowned reference can’t be optional, and it should always have value. If you try to access a deallocated property value, you will face a runtime error.\nIn this example, we have two instances: User and DiscountCard. DiscountCard has a relationship with the User that is marked as unowned to avoid a strong reference cycle.\nclass User { let name: String var discountCard: DiscountCard? init(name: String) { self.name = name } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } class DiscountCard { let number: UInt64 unowned let user: User init(number: UInt64, user: User) { self.number = number self.user = user } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var user: User? user = User(name: \u0026#34;John Doe\u0026#34;) When you create DiscountCard instance and assign it as reference to user property, it no longer holds strong reference.\nuser!.discountCard = DiscountCard(number: 1234_5678_9012_3456, user: user!) After we set user property to nil, it will deallocate User and DiscountCard instances.\nuser = nil Strong Reference Cycles for Closures Strong reference cycle for closure can occur if you assign closure to property of instance. In this case, you assign reference to that closure. The strong reference cycle appears because closures are reference types.\nclass MemoryStorage { let text: String let additionalText: String? lazy var copy: () -\u0026gt; String = { if let additionalText = self.additionalText { self.text + \u0026#34;\\n\u0026#34; + additionalText } else { self.text } } init(text: String, additionalText: String? = nil) { self.text = text self.additionalText = additionalText } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var memoryStorage: MemoryStorage? = MemoryStorage(text: \u0026#34;Thank you for registration\u0026#34;, additionalText: \u0026#34;John Doe\u0026#34;) print(memoryStorage!.copy()) memoryStorage = nil In this example, closure captures self.text property and create strong reference cycle by referencing to self.\nBreaking Strong Reference Cycle in Closure To break strong reference cycle, we need to add capture list with unowned keyword to copy closure.\nclass MemoryStorage { let text: String let additionalText: String? lazy var copy: () -\u0026gt; String = { [unowned self] in if let additionalText = self.additionalText { self.text + \u0026#34;\\n\u0026#34; + additionalText } else { self.text } } init(text: String, additionalText: String? = nil) { self.text = text self.additionalText = additionalText } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var memoryStorage: MemoryStorage? = MemoryStorage(text: \u0026#34;Thank you for registration\u0026#34;, additionalText: \u0026#34;John Doe\u0026#34;) print(memoryStorage!.copy()) memoryStorage = nil ","permalink":"http://localhost:1313/posts/post-11/","summary":"What is ARC? Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed. - Apple\nARC In Action In this example, we assign an instance to the reference1 property.","title":"ARC in Swift"},{"content":"Introduction In this article, I’m going to briefly explain what closure is.\nClosures is self-conitained blocks of funcionality that can be passed around and used in your code. — Apple\nExpression:\n{ (params) -\u0026gt; return value in statements } @escaping When closure is marked as escaping, it will outlive or leave the scope you passed.\nfunc response(_ completionHandler: @escaping(Result) -\u0026gt; Void) { completionHandler(.success) } @nonescaping By default, closures are nonescaping, meaning closure will no longer exist in memory after complete execution in the scope you have passed it to.\nfunc filterImage(_ completionHandler: (Image) -\u0026gt; Void) { completionHandler(UIImage.filtered) } @autoclosure Autoclosures automatically create closure from the argument that you passed into a function.\nfunc animate(_ animation: @autoclosure @escaping () -\u0026gt; Void, duration: TimeInterval = 0.25) { UIView.animate(withDuration: duration, animations: animation) } Closure conceptualy looks like this first pointer points to the code that implements closure the second pointer pointed to the reference counted object.\nstruct Closure { var functionPointer: UnsafeRawPointer var closureContext: AnyObject? } ","permalink":"http://localhost:1313/posts/post-7/","summary":"Introduction In this article, I’m going to briefly explain what closure is.\nClosures is self-conitained blocks of funcionality that can be passed around and used in your code. — Apple\nExpression:\n{ (params) -\u0026gt; return value in statements } @escaping When closure is marked as escaping, it will outlive or leave the scope you passed.\nfunc response(_ completionHandler: @escaping(Result) -\u0026gt; Void) { completionHandler(.success) } @nonescaping By default, closures are nonescaping, meaning closure will no longer exist in memory after complete execution in the scope you have passed it to.","title":"What is closure in Swift language?"},{"content":"Introduction In Swift, classes, closures, and actors all reference types.\n\u0026lsquo;Reference type’ is instance that shares a single copy of data.\nAssigning a reference type to a constant or variable, or passing it into a function or method, it is always a reference to a shared instance that is assigned or passed in.\nExample You can pass your property value by sharing the same address in memory.\n// Reference type example class Storage { var data = “data-example” } var storage = Storage() print(\u0026#34;\\(storage.data)\u0026#34;) // prints \u0026#34;data-example\u0026#34; print(\u0026#34;storage address:\u0026#34;, Unmanaged.passUnretained(storage).toOpaque()) var copiedStorage = storage copiedStorage.data = “new-data” print(\u0026#34;\\(storage.data), \\(copiedStorage.data)\u0026#34;) // prints \u0026#34;new-data, new-data\u0026#34; print(\u0026#34;copiedStorage address:\u0026#34;, Unmanaged.passUnretained(copiedStorage).toOpaque()) As you can see, storage and copied storage property addresses are the same.\nSummary Copying data by reference refers to the same address in memory. This means that modifying data in one variable also affects another. It also means that multiple reference types may refer to the same object.\n","permalink":"http://localhost:1313/posts/post-5/","summary":"Introduction In Swift, classes, closures, and actors all reference types.\n\u0026lsquo;Reference type’ is instance that shares a single copy of data.\nAssigning a reference type to a constant or variable, or passing it into a function or method, it is always a reference to a shared instance that is assigned or passed in.\nExample You can pass your property value by sharing the same address in memory.\n// Reference type example class Storage { var data = “data-example” } var storage = Storage() print(\u0026#34;\\(storage.","title":"What is “reference type” in Swift?"},{"content":"Introduction The Composable Architecture (TCA) uses a unidirectional data flow (UDF). UDF is a design pattern where data and events move consistently and predictably. In UDF, data can only be transferred to other application parts in one way.\nIn TCA, the only way to mutate the state is by sending actions to a runtime store. The runtime store holds the entire app’s business logic and mutates the state inside.\nUDF can reduce data inconsistencies because of the single source of truth for the application.\nTCA is built around key components: Action State Reducer Effect Store Environment Code examples: Timer\nhttps://github.com/dmytrochumakov/TCA-Examples/tree/main/Timer/Timer/Timer Sources: https://github.com/pointfreeco/swift-composable-architecture https://www.youtube.com/watch?v=SfFDj6qT-xg\u0026ab_channel=SwiftandTips https://www.youtube.com/watch?v=XWZmgbylTpc\u0026ab_channel=SwiftHeroes https://www.youtube.com/watch?v=McmGb9sexMo\u0026ab_channel=SwiftandTips https://www.youtube.com/watch?v=McmGb9sexMo\u0026ab_channel=SwiftandTips https://markvillar.com/the-composable-architecture/ ","permalink":"http://localhost:1313/posts/post-4/","summary":"Introduction The Composable Architecture (TCA) uses a unidirectional data flow (UDF). UDF is a design pattern where data and events move consistently and predictably. In UDF, data can only be transferred to other application parts in one way.\nIn TCA, the only way to mutate the state is by sending actions to a runtime store. The runtime store holds the entire app’s business logic and mutates the state inside.\nUDF can reduce data inconsistencies because of the single source of truth for the application.","title":"Let’s talk about Composable Architecture"},{"content":" Hi! I'm Dmytro Chumakov.\nHighly skilled iOS Developer with extensive experience in developing, and testing mobile application projects.\nProficient in Swift, Objective-C, and SwiftUI, with a strong foundation in modern software engineering practices.\nKnown for enhancing application performance, and automating repetitive tasks.\nMy Values Innovation: I consistently seek innovative solutions, leveraging modern technologies and creative thinking to stay ahead of the curve.\nEfficiency: My focus on streamlining processes and maximizing productivity underscores my commitment to efficiency in every aspect of my work.\nQuality: I am dedicated to delivering high-quality products, ensuring excellence through thorough testing, documentation, and performance optimization.\nUser-Centricity: My development approach prioritizes user needs and experience, crafting applications that prioritize safety, interaction, and functionality.\nContinuous Learning: I actively pursue ongoing learning and skill development, staying updated with the latest industry trends and technologies.\nCollaboration: I thrive in collaborative environments, leveraging leadership skills to drive teamwork and achieve collective success in project delivery.\nCommunity Engagement: I am passionate about sharing knowledge and contributing to the developer community through technical posts and videos, fostering growth and learning for others.\n","permalink":"http://localhost:1313/about/","summary":"Information about me.","title":"About Me"},{"content":" E-commerce Proficient in developing marketplace and utility management apps, capable of creating e-commerce platforms with features like product catalogs, user authentication, payment gateways, and order management systems.\nHealthcare Skilled in healthcare app development, with experience in building Glucose Tracker and COVID-19 tracking applications. Capable of developing apps for health metric monitoring, telemedicine, medication management, and wellness tracking.\nFinance Experienced in utility management and currency-related projects, able to create personal finance management apps, budgeting tools, and investment trackers.\nSocial Networking Well-versed in developing social features like buyer-seller chat, suitable for creating social networking apps, messaging platforms, and event planning applications.\nUtility and Productivity Expertise in utility management and macOS tools, ideal for developing task management apps, note-taking tools, and time tracking solutions.\nEducation Background in building Multi-User studying apps and technical resources, capable of contributing to e-learning platforms, and language learning apps.\nCross-Domain Integration Diverse experience enables integration of functionalities across domains, such as combining e-commerce with social networking or incorporating healthcare monitoring into productivity tools.\nOpen Source Contributions Experienced in open-source projects, capable of contributing by improving documentation, fixing bugs, adding features, or creating libraries/frameworks for iOS development.\nEmerging Technologies Stay updated with AR, VR, ML, and IoT trends, exploring projects that leverage these technologies for innovative app development.\n","permalink":"http://localhost:1313/cases/","summary":"E-commerce Proficient in developing marketplace and utility management apps, capable of creating e-commerce platforms with features like product catalogs, user authentication, payment gateways, and order management systems.\nHealthcare Skilled in healthcare app development, with experience in building Glucose Tracker and COVID-19 tracking applications. Capable of developing apps for health metric monitoring, telemedicine, medication management, and wellness tracking.\nFinance Experienced in utility management and currency-related projects, able to create personal finance management apps, budgeting tools, and investment trackers.","title":"Cases"},{"content":"iOS App Maintenance Service This service is designed to improve your app’s stability, leading to more 5-star ratings and increased user satisfaction.\nIs This Service Right for You? Here are a few questions for you:\nAre you tired of getting negative app reviews due to bugs and crashes? Feel frustrated by your app’s low search rank and disappointing download numbers? Always worried about your app’s sudden breakdowns post-iOS updates? Struggling to find a reliable developer when your app needs quick fixes? If you’ve answered “yes” to any of these questions, this service is your solution! The Transformations You’ll Get A Glitch-Free App: I’ll keep your app free from bugs and crashes, ensuring a smooth user experience and preventing negative reviews. Enhanced User Satisfaction: By delivering a glitch-free app, you’ll provide a seamless and enjoyable experience for your users, leading to higher - user satisfaction and retention rates. Higher App’s Rating: A flawless app leads to higher ratings and more 5-star reviews, attracting new users and loyal customers. Rise in App Store Rankings: A well-performing app climbs the search rankings, gaining visibility and organic downloads. Stay Ahead of iOS Updates: I’ll ensure your app stays compatible with iOS updates, eliminating the fear of it breaking after each new release. Expert Developer at Your Fingertips: I’m always ready to assist you, ensuring your app remains relevant and competitive in the ever-evolving market. Pick What You Need All packages come with a 30-day 110% Money-Back Guarantee.\nMost Popular Lite Essential care for apps\n$399 per month\nUnlimited bug fixes Unlimited crash fixes iOS compatibility updates Bi-weekly app releases Unlimited email support Most Popular Plus Ongoing app enhancement\n$799 per month\nAll services in Lite + Performance monitoring App reviews support Minor UI/UX improvement App content updates Most Popular Pro For constantly evolving apps\n$2499 per month\nAll services in Plus + Feature implementation Major UI/UX improvement Major feature updates Weekly consultation call Ready to Boost Your App’s Success? Ready to unlock your app’s true potential? Or do you have questions?\nSend me an email or schedule a call with me, and let’s make it happen together. I’m here to assist you every step of the way.\nGet in Touch Now! ","permalink":"http://localhost:1313/ios-app-maintenance-service/","summary":"iOS App Maintenance Service This service is designed to improve your app’s stability, leading to more 5-star ratings and increased user satisfaction.\nIs This Service Right for You? Here are a few questions for you:\nAre you tired of getting negative app reviews due to bugs and crashes? Feel frustrated by your app’s low search rank and disappointing download numbers? Always worried about your app’s sudden breakdowns post-iOS updates? Struggling to find a reliable developer when your app needs quick fixes?","title":"Services"},{"content":" Thank You Thank you for your interest in this course! Your enthusiasm means a lot to me. Currently, I'm in the testing phase for this idea. If there's significant interest from individuals like you, I'll move forward with creating the course. If you'd like to stay updated on its progress, please feel free to drop me an email. Your support is truly appreciated!\nIf you have any questions or want updates, please email me at dmytro.v.chumakov.work@gmail.com.\n","permalink":"http://localhost:1313/thank-you/","summary":"Thank You Thank you for your interest in this course! Your enthusiasm means a lot to me. Currently, I'm in the testing phase for this idea. If there's significant interest from individuals like you, I'll move forward with creating the course. If you'd like to stay updated on its progress, please feel free to drop me an email. Your support is truly appreciated!\nIf you have any questions or want updates, please email me at dmytro.","title":"Thank You"}]