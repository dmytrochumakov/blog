[{"content":"Introduction If you\u0026rsquo;re wondering how to test an Xcode project using GitHub Actions, here are a few steps:\nFirst, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.3.app/Contents/Developer - name: Install xcpretty run: gem install xcpretty - name: Test project run: xcodebuild -project /Users/runner/work/YourProjectName/YourProjectName/YourProjectName/YourProjectName.xcodeproj -scheme YourSchemeName -destination \u0026#39;platform=iOS Simulator,OS=17.4,name=iPhone 15 Pro\u0026#39; clean build test | xcpretty Caveats If you don\u0026rsquo;t specify the path to the Xcode project, you will receive an error like this: xcodebuild: error: ‘YourProjectName.xcodeproj' does not exist.\nYou can debug project directory by adding this line to your config:\n- name: Debug Directory Contents run: ls -la /Users/runner/work/YourProjectName/YourProjectName Thank you for reading!\n","permalink":"http://localhost:1313/posts/testing-xcode-project-using-github-actions/","summary":"Introduction If you\u0026rsquo;re wondering how to test an Xcode project using GitHub Actions, here are a few steps:\nFirst, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.","title":"Testing Xcode project using Github Actions"},{"content":"Introduction If you\u0026rsquo;re wondering how to build an Xcode project using GitHub Actions, here are a few steps:\nFirst, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.3.app/Contents/Developer - name: Install xcpretty run: gem install xcpretty - name: Build project run: xcodebuild -project /Users/runner/work/YourProjectName/YourProjectName/YourProjectName/YourProjectName.xcodeproj -scheme YourSchemeName -sdk iphonesimulator -destination \u0026#39;platform=iOS Simulator,name=iPhone 15 Pro\u0026#39; clean build | xcpretty Caveats If you don\u0026rsquo;t specify the path to the Xcode project, you will receive an error like this: xcodebuild: error: ‘YourProjectName.xcodeproj' does not exist.\nYou can debug project directory by adding this line to your config:\n- name: Debug Directory Contents run: ls -la /Users/runner/work/YourProjectName/YourProjectName Thank you for reading!\n","permalink":"http://localhost:1313/posts/post-15/","summary":"Introduction If you\u0026rsquo;re wondering how to build an Xcode project using GitHub Actions, here are a few steps:\nFirst, you need to create a .github/workflows folder with a CI.yml file inside your project directory. Next, you need to add configuration to the CI.yml file. name: CI on: push: branches: - main jobs: build: runs-on: macos-14 steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Xcode version run: sudo xcode-select -s /Applications/Xcode_15.","title":"Building Xcode project using Github Actions"},{"content":"Introduction You can easily deliver an iOS app in two ways: through beta and release lanes.\nThe First Way - TestFlight By creating a beta lane inside the Fastfile. It utilizes:\nbuild_app: To easily build and sign your app (via gym). pilot: Makes it easier to manage your app on Apple’s TestFlight. lane :beta do build_app(scheme: \u0026#34;YourScheme\u0026#34;) pilot end To run Fastlane:\nfastlane beta Attention Before proceeding, you need to have the ipa or pkg file generated.\nThe Second Way - App Store Connect By creating a release lane inside the Fastfile. It utilizes:\ngym: To build and package iOS apps for you. deliver: To upload screenshots, metadata, and binaries to App Store Connect. lane :release do gym # Builds the app deliver # Uploads the app to App Store Connect end To run Fastlane:\nfastlane release If you haven\u0026rsquo;t installed Fastlane yet, here are the steps: Outline of the Process\nInstall Fastlane: You can do so using RubyGems, which is the Ruby package manager: brew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running: fastlane init ","permalink":"http://localhost:1313/posts/post-14/","summary":"Introduction You can easily deliver an iOS app in two ways: through beta and release lanes.\nThe First Way - TestFlight By creating a beta lane inside the Fastfile. It utilizes:\nbuild_app: To easily build and sign your app (via gym). pilot: Makes it easier to manage your app on Apple’s TestFlight. lane :beta do build_app(scheme: \u0026#34;YourScheme\u0026#34;) pilot end To run Fastlane:\nfastlane beta Attention Before proceeding, you need to have the ipa or pkg file generated.","title":"Delivering iOS app using Fastlane"},{"content":"Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to archive a project in the fastest way.\nOne of such ways is by using the xcodebuild archive command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild archive: Once you\u0026rsquo;re in the project directory, you can run xcodebuild archive with the appropriate parameters to build your project. Example: xcodebuild archive -scheme YourSchemeName -archivePath ~/Desktop/YourAppName.xcarchive Another way is by integrating fastlane into your workflow: Outline of the process Install Fastlane: If you haven\u0026rsquo;t already installed Fastlane, you can do so using RubyGems, which is the Ruby package manager:\nbrew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running:\nfastlane init Create a lane for archiving: Open your Fastfile located in the fastlane directory of your project, and add a new lane for archiving:\nlane :archive do gym( scheme: \u0026#34;YourSchemeName\u0026#34;, output_directory: \u0026#34;/path/to/your/archive/directory\u0026#34;, output_name: \u0026#34;YourAppName\u0026#34; ) end Run the archive lane: Once you\u0026rsquo;ve defined the archive lane, you can run it using the following command:\nfastlane archive ","permalink":"http://localhost:1313/posts/post-6/","summary":"Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to archive a project in the fastest way.\nOne of such ways is by using the xcodebuild archive command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project.","title":"Archiving Xcode project using the CLI"},{"content":"Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to test a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project. Example: xcodebuild -project YourProject.xcodeproj -scheme YourSchemeName test Another way is by integrating fastlane into your workflow: Outline of the process Install Fastlane: If you haven\u0026rsquo;t already installed Fastlane, you can do so using RubyGems, which is the Ruby package manager:\nbrew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running:\nfastlane init Define a Lane for Testing: Open your Fastfile and define a lane for running tests. Here\u0026rsquo;s a basic example:\nlane :run_tests do scan(scheme: \u0026#34;YourSchemeName\u0026#34;) end Run Tests Using Fastlane: You can now run your tests using the lane you defined. In the terminal, navigate to your project directory and run:\nfastlane run_tests Testing a project through a project generation tools If you are testing a project through a project generation tool like tuist you do not need anything that was mentioned above because it already has build-in commands:\ntuist test YourSchemeName ","permalink":"http://localhost:1313/posts/post-3/","summary":"Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to test a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project.","title":"Testing Xcode project using the CLI"},{"content":"Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to build a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project. Example: xcodebuild -project YourProjectName.xcodeproj -scheme YourSchemeName Another way is by integrating fastlane into your workflow: Outline of the process Install Fastlane: If you haven\u0026rsquo;t already installed Fastlane, you can do so using RubyGems, which is the Ruby package manager:\nbrew install fastlane Navigate to Project Directory: Open Terminal and navigate to the directory containing your Xcode project. Initialize Fastlane (Optional): If you haven\u0026rsquo;t initialized Fastlane in your project yet, you can do so by running:\nfastlane init Build with Fastlane: Once Fastlane is set up, you can use it to build your Xcode project. Fastlane provides a lane named build_app for building your app. You can run this lane with the following command:\nfastlane build_app Building a project through a project generation tools If you are building a project through a project generation tool like tuist you do not need anything that was mentioned above because it already has build-in commands tuist build.\n","permalink":"http://localhost:1313/posts/post-2/","summary":"Introduction When you are working on different projects sometimes you need to use different IDE’s. You need to find a way to build a project in the fastest way.\nOne of such ways is by using the xcodebuild command Basic outline of the process Open Terminal: Open the Terminal application on your Mac. Navigate to Project Directory: Use the cd command to navigate to the directory containing your Xcode project. Run xcodebuild: Once you\u0026rsquo;re in the project directory, you can run xcodebuild with the appropriate parameters to build your project.","title":"Building Xcode project using the CLI"},{"content":"What is a Visitor Pattern? The Visitor Pattern helps add new capabilities to a composite of objects.\nSource\nWhat problems does it solve? The Visitor Pattern helps solve following problems:\nSeparation of Concerns: The Visitor Pattern separates algorithms from the objects on which they operate. This allows for clean code organization by keeping algorithms and operations separate from the data structures they operate on. Extensibility: It allows you to add new operations to existing object structures without modifying those structures. This is especially useful when dealing with complex object hierarchies where adding new functionality directly to the classes would lead to code bloat and tight coupling. Traversal of Object Structures: It provides a way to traverse complex object structures while performing some action on each element of the structure. This is particularly useful in scenarios where you need to process every element of a data structure in a specific order or with a specific algorithm. Real-world code example // Element protocol representing the items on the menu protocol MenuItem { func accept(visitor: OrderVisitor) } // Concrete item types class Coffee: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } class Tea: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } class Pastry: MenuItem { let name: String let price: Double init(name: String, price: Double) { self.name = name self.price = price } func accept(visitor: OrderVisitor) { visitor.visit(self) } } // Visitor protocol defining the operations to be performed on menu items protocol OrderVisitor { func visit(_ item: Coffee) func visit(_ item: Tea) func visit(_ item: Pastry) } // Concrete visitor implementing operations on menu items class TotalCostVisitor: OrderVisitor { var totalCost = 0.0 func visit(_ item: Coffee) { totalCost += item.price } func visit(_ item: Tea) { totalCost += item.price } func visit(_ item: Pastry) { totalCost += item.price } } class ItemDetailsVisitor: OrderVisitor { var details = \u0026#34;\u0026#34; func visit(_ item: Coffee) { details += \u0026#34;Coffee: \\(item.name), Price: $\\(item.price)\\n\u0026#34; } func visit(_ item: Tea) { details += \u0026#34;Tea: \\(item.name), Price: $\\(item.price)\\n\u0026#34; } func visit(_ item: Pastry) { details += \u0026#34;Pastry: \\(item.name), Price: $\\(item.price)\\n\u0026#34; } } // Example usage let items: [MenuItem] = [Coffee(name: \u0026#34;Espresso\u0026#34;, price: 2.5), Tea(name: \u0026#34;Green Tea\u0026#34;, price: 2.0), Pastry(name: \u0026#34;Croissant\u0026#34;, price: 3.0)] let totalCostVisitor = TotalCostVisitor() for item in items { item.accept(visitor: totalCostVisitor) } print(\u0026#34;Total cost of the order: $\\(totalCostVisitor.totalCost)\u0026#34;) let itemDetailsVisitor = ItemDetailsVisitor() for item in items { item.accept(visitor: itemDetailsVisitor) } print(\u0026#34;Order details:\u0026#34;) print(itemDetailsVisitor.details) ","permalink":"http://localhost:1313/posts/post-1/","summary":"What is a Visitor Pattern? The Visitor Pattern helps add new capabilities to a composite of objects.\nSource\nWhat problems does it solve? The Visitor Pattern helps solve following problems:\nSeparation of Concerns: The Visitor Pattern separates algorithms from the objects on which they operate. This allows for clean code organization by keeping algorithms and operations separate from the data structures they operate on. Extensibility: It allows you to add new operations to existing object structures without modifying those structures.","title":"The Visitor Pattern"},{"content":"What is a State Pattern? The State Pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.\nSource\nWhat problems does it solve? Complex conditional logic: When an object’s behavior depends on its internal state, it often leads to complex conditional statements. The State pattern simplifies this by encapsulating each state and its behavior in separate classes, making the code more readable and maintainable. State-specific behavior: Objects often need to change their behavior based on their state. The State pattern allows objects to delegate behavior to state objects, which can vary independently. This promotes better encapsulation and separation of concerns. Adding new states: When new states need to be added, the State pattern makes it easier to extend the functionality without modifying existing code. New states can be added by creating new state classes and integrating them into the existing context, without changing the context class itself. Real-world code example // Define the VendingMachine protocol protocol VendingMachineState { func insertCoin() func dispenseItem() } // Define concrete states class NoCoinState: VendingMachineState { private let vendingMachine: VendingMachine init(vendingMachine: VendingMachine) { self.vendingMachine = vendingMachine } func insertCoin() { print(\u0026#34;Coin inserted\u0026#34;) // Transition to the HasCoinState vendingMachine.changeState(newState: vendingMachine.hasCoinState) } func dispenseItem() { print(\u0026#34;Please insert a coin first\u0026#34;) } } class HasCoinState: VendingMachineState { private let vendingMachine: VendingMachine init(vendingMachine: VendingMachine) { self.vendingMachine = vendingMachine } func insertCoin() { print(\u0026#34;Coin already inserted\u0026#34;) } func dispenseItem() { if vendingMachine.inventoryCount \u0026gt; 0 { print(\u0026#34;Item dispensed\u0026#34;) vendingMachine.decreaseInventory() // Transition to the NoCoinState vendingMachine.changeState(newState: vendingMachine.noCoinState) } else { print(\u0026#34;Out of stock\u0026#34;) } } } // Define the VendingMachine class class VendingMachine { var inventoryCount: Int = 5 var currentState: VendingMachineState! var noCoinState: VendingMachineState! var hasCoinState: VendingMachineState! init() { noCoinState = NoCoinState(vendingMachine: self) hasCoinState = HasCoinState(vendingMachine: self) currentState = noCoinState } func changeState(newState: VendingMachineState) { currentState = newState } func insertCoin() { currentState.insertCoin() } func dispenseItem() { currentState.dispenseItem() } func decreaseInventory() { inventoryCount -= 1 } } // Usage let vendingMachine = VendingMachine() vendingMachine.dispenseItem() vendingMachine.insertCoin() vendingMachine.insertCoin() vendingMachine.dispenseItem() vendingMachine.dispenseItem() Thank you for reading!\n","permalink":"http://localhost:1313/posts/the-state-pattern/","summary":"What is a State Pattern? The State Pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.\nSource\nWhat problems does it solve? Complex conditional logic: When an object’s behavior depends on its internal state, it often leads to complex conditional statements. The State pattern simplifies this by encapsulating each state and its behavior in separate classes, making the code more readable and maintainable.","title":"The State Pattern"},{"content":"What is a Big O notation? The Big O notation helps identify algorithm efficiency. It can measure computation and memory growth with respect to input. Real-world code example O(n) — Linear Time\nfunc containsValue(array: [Int], value: Int) -\u0026gt; Bool { for element in array { if element == value { return true } } return false } O(1) — Constant Time\nfunc findFirstElement(array: [Int]) -\u0026gt; Int? { return array.first } Thank you for reading!\n","permalink":"http://localhost:1313/posts/big-o-notation/","summary":"What is a Big O notation? The Big O notation helps identify algorithm efficiency. It can measure computation and memory growth with respect to input. Real-world code example O(n) — Linear Time\nfunc containsValue(array: [Int], value: Int) -\u0026gt; Bool { for element in array { if element == value { return true } } return false } O(1) — Constant Time\nfunc findFirstElement(array: [Int]) -\u0026gt; Int? { return array.first } Thank you for reading!","title":"Big O notation"},{"content":"What is Combine? Combine Framework provides an API for processing async events over time such as user-input, network response, and other dynamic data.\nWhat is the purpose of Combine? The purpose of Combine is to simplify the management of async events and data streams.\nPublishers Publisher declares that a type can transit a sequence of values over time. A publisher delivers elements to one or more Subscriber instances.\nclass PostService { func fetchPosts() -\u0026gt; AnyPublisher\u0026lt;[Post], Error\u0026gt; { guard let url = URL(string: \u0026#34;https://jsonplaceholder.typicode.com/posts\u0026#34;) else { fatalError(\u0026#34;Invalid URL\u0026#34;) } return URLSession.shared.dataTaskPublisher(for: url) .map(\\.data) .decode(type: [Post].self, decoder: JSONDecoder()) .receive(on: DispatchQueue.main) .eraseToAnyPublisher() } } Subscribers Subscriber is a protocol that declares a type that can receive input from a publisher. A Subscriber instance receives a stream of elements from a Publisher.\nprivate var cancellable: AnyCancellable? let service = PostService() cancellable = service.fetchPosts() .sink(receiveCompletion: { completion in switch completion { case .finished: break case .failure(let error): print(error.localizedDescription) } }, receiveValue: { posts in print(\u0026#34;Received posts count:\u0026#34;, posts.count) }) AnyCancellable When you call a method like sink or assign on a publisher, it returns a type that conforms to the Cancellable protocol. Storing this return value in an instance of AnyCancellable keeps the subscription active. When the AnyCancellable instance is deallocated, its deinit method automatically cancels the subscription.\nvar cancellables = Set\u0026lt;AnyCancellable\u0026gt;() let publisher = Just(\u0026#34;Hello, Combine!\u0026#34;) publisher .sink { completion in print(\u0026#34;Completion: \\(completion)\u0026#34;) } receiveValue: { value in print(\u0026#34;Received value: \\(value)\u0026#34;) } .store(in: \u0026amp;cancellables) Operators Transforming Operators map: Transforms each value received from a publisher by applying a function. flatMap: Transforms each value received into a new publisher, then flattens the result into a single publisher stream. scan: Applies a closure over the previous result and the current value to produce a new value, useful for accumulating values. Filtering Operators filter: Emits only those values from a publisher that satisfy a given predicate. removeDuplicates: Suppresses duplicate consecutive values published by a publisher. first/last: Emits only the first or last value from a publisher that satisfies a predicate condition. Combining Operators combineLatest: Combines the latest value from two or more publishers and emits a combined value each time any of the publishers emit a value. merge: Combines multiple publishers of the same type into a single publisher stream, emitting values as they arrive. zip: Combines values from multiple publishers into tuples, emitting a tuple only when each of the publishers has emitted a new value. Error Handling Operators catch: Handles errors from a publisher by replacing the failed publisher with another publisher or a value. retry: Attempts to recreate a subscription to a failed publisher for a specified number of times. Utility Operators delay: Delays the emission of items from the publisher for a specified interval. subscribe(on:)/receive(on:): Specifies the dispatch queue for performing subscription work or receiving values. print: Prints log messages for all publisher events to the console, useful for debugging. Timing Operators debounce: Emits a value from a publisher only after a specified time interval has passed without receiving another value. throttle: Emits either the first or last value received in a specified time window. Collecting Operators collect: Collects received values and emits an array of those values either when the publisher completes or when a buffer size is reached. When to use Combine? I found great advice from Apple when it comes to Combine:\n“A Combine publisher fills a role similar to, but distinct from, the AsyncSequence in the Swift standard library. A Publisher and an AsyncSequence both produce elements over time. However, the pull model in Combine uses a Subscriber to request elements from a publisher, while Swift concurrency uses the for-await-in syntax to iterate over elements published by an AsyncSequence. Both APIs offer methods to modify the sequence by mapping or filtering elements, while only Combine provides time-based operations like debounce(for:scheduler:options:) and throttle(for:scheduler:latest:), and combining operations like merge(with:) and combineLatest(_:_:). To bridge the two approaches, the property values exposes a publisher’s elements as an AsyncSequence, allowing you to iterate over them with for-await-in rather than attaching a Subscriber.”\nThank you for reading!\n","permalink":"http://localhost:1313/posts/combine-basics/","summary":"What is Combine? Combine Framework provides an API for processing async events over time such as user-input, network response, and other dynamic data.\nWhat is the purpose of Combine? The purpose of Combine is to simplify the management of async events and data streams.\nPublishers Publisher declares that a type can transit a sequence of values over time. A publisher delivers elements to one or more Subscriber instances.\nclass PostService { func fetchPosts() -\u0026gt; AnyPublisher\u0026lt;[Post], Error\u0026gt; { guard let url = URL(string: \u0026#34;https://jsonplaceholder.","title":"Combine — Basics"},{"content":"When was it introduced? It was introduced in Swift 5.5 at WWDC 2021.\nYou can find the more comprehensive info about Modern Concurrency in Swift Concurrency Manifesto.\nWhat are actors? Actors eliminate shared mutable state and explicit synchronization through deep copying of all the data that passed to an actor to a message sent and preventing direct access to actor state. Actors are reference types.\nactor DatabaseManager { private var data: [String: String] = [:] func readData(key: String) -\u0026gt; String? { data[key] } func writeData(key: String, value: String) { data[key] = value } } What is an asynchronous function? The asynchronous function or asynchronous method can be suspended while it is partway through execution. It can pause in the middle when it’s waiting for something.\nfunc someAsyncOperation(index: Int) async throws -\u0026gt; String { try await Task.sleep(nanoseconds: 1_000_000_000) return \u0026#34;Operation \\(index) Completed\u0026#34; } func performAsyncOperations() async throws { for index in 1...1000 { Task.detached { print(\u0026#34;Start of operation \\(index)\u0026#34;) let result = try await someAsyncOperation(index: index) print(\u0026#34;End of operation \\(index) with result: \\(result)\u0026#34;) return result } } } Task { print(\u0026#34;Start of example\u0026#34;) try await performAsyncOperationsWithYield() print(\u0026#34;End of example\u0026#34;) } What are Asynchronous Sequences? Asynchronous Sequences enable you to stop an async task until the next item is prepared, giving room for other tasks to progress. Crafting your own Asynchronous Sequence involves adhering to the AsyncSequence protocol.\nstruct AsyncCounter: AsyncSequence { typealias Element = Int struct AsyncCounterIterator: AsyncIteratorProtocol { var count = 0 mutating func next() async -\u0026gt; Int? { defer { count += 1 } return count } } func makeAsyncIterator() -\u0026gt; AsyncCounterIterator { return AsyncCounterIterator() } } let asyncCounter = AsyncCounter() for await count in asyncCounter { print(\u0026#34;Count: \\(count)\u0026#34;) try await Task.sleep(nanoseconds: 1 * 1_000_000_000) } What are Tasks and TaskGroups? You can draw a parallel between Tasks and DispatchQueue`s because they have similar concepts. If you want to execute your code asynchronously you should put your code into async context. Tasks and Queues help you solve this problem.\nfunc fetchData() async throws -\u0026gt; String { try await Task.sleep(nanoseconds: 2 * 1_000_000_000) return \u0026#34;Data fetched successfully!\u0026#34; } Task { print(\u0026#34;Start fetching data...\u0026#34;) do { let result = try await fetchData() print(result) } catch { print(\u0026#34;Error: \\(error)\u0026#34;) } print(\u0026#34;Data fetching completed.\u0026#34;) } let customQueue = DispatchQueue(label: \u0026#34;com.example.myqueue\u0026#34;, attributes: .concurrent) func performTask() { customQueue.async { print(\u0026#34;Task is starting...\u0026#34;) Thread.sleep(forTimeInterval: 2) print(\u0026#34;Task completed.\u0026#34;) } } for _ in 1...3 { performTask() } TaskGroup allows you to explicitly add child tasks and give you more control over priority and cancellation.\nfunc fetchImages(urls: [URL]) async throws -\u0026gt; [UIImage] { try await withThrowingTaskGroup(of: UIImage.self) { group in var images: [UIImage] = [] for url in urls { group.addTask { try await downloadImage(from: url) } } for try await result in group { images.append(result) } return images } } func downloadImage(from url: URL) async throws -\u0026gt; UIImage { // Download and return the image } What is Task.yield()? If you have a long-running operation you can call the Task.yield() method to explicitly add suspension points. By doing that you are letting other tasks make progress.\nfunc performAsyncOperationsWithYield() async throws { for index in 1...1000 { Task.detached { print(\u0026#34;Start of operation \\(index)\u0026#34;) // Yield control to the scheduler await Task.yield() let result = try await someAsyncOperation(index: index) print(\u0026#34;End of operation \\(index) with result: \\(result)\u0026#34;) return result } } } What are Sendable Types? A type that can be shared from one concurrency context to another is known as a sendable type. In other words it guarantees that the operation that you perform is thread-safe.\nimport Foundation struct WeatherData: Sendable { var temperature: Double var condition: String var city: String } func fetchWeatherData(forCity city: String) async -\u0026gt; WeatherData { try? await Task.sleep(nanoseconds: 1_000_000_000) return WeatherData(temperature: 72.0, condition: \u0026#34;Sunny\u0026#34;, city: city) } import SwiftUI @MainActor class WeatherViewModel: ObservableObject { @Published var currentWeather: WeatherData? func updateWeather(forCity city: String) { Task { let weatherData = await fetchWeatherData(forCity: city) // Since WeatherData conforms to Sendable, this is safe self.currentWeather = weatherData } } } Thank you for reading!\n","permalink":"http://localhost:1313/posts/modern-concurrency/","summary":"When was it introduced? It was introduced in Swift 5.5 at WWDC 2021.\nYou can find the more comprehensive info about Modern Concurrency in Swift Concurrency Manifesto.\nWhat are actors? Actors eliminate shared mutable state and explicit synchronization through deep copying of all the data that passed to an actor to a message sent and preventing direct access to actor state. Actors are reference types.\nactor DatabaseManager { private var data: [String: String] = [:] func readData(key: String) -\u0026gt; String?","title":"Modern Concurrency"},{"content":"What is the Thread? A Thread is a small set of instructions that can be executed independently from the main program. Threads are often used to improve program performance by allowing multiple tasks to be executed at the same time. The Thread has its own stack, registers, and program counters.\nThreads share memory address space, and it is possible to communicate between Threads using shared memory space. How to use it? You can create a single Thread by the following example:\n// Create a new thread and start it let newThread = Thread { } newThread.start() What else can you do? You can:\ncancel exit sleep etc You can check the current Thread execution state: isExecuting isFinished isCancelled You can subclass Thread and override the main() method if you need it.\nCaveats The main problem with Threads is that you must manually manage relationships between them. It can cause testability, readability, and potentially Thread Explosion issues.\nWhat is Thread Explosion? Thread Explosion occurs when a system has too many running Threads simultaneously. It can cause performance issues such as memory overhead and cost of context switching (CPU cycles).\nTips You can delegate your work with Threads to Grand Central Dispatch (GCD).\nGCD provides an API that manages the number of Threads automatically.\nYou can also use async/await and Task functionality from Swift 5.5 that helps manage the number of Threads in poll-based factors like system load and the number of available CPUs. If you have a long-running operation, you can call the Task.yield() method and let other tasks in your program make progress on their work.\nThank you for reading!\n","permalink":"http://localhost:1313/posts/what-are-threads-in-swift/","summary":"What is the Thread? A Thread is a small set of instructions that can be executed independently from the main program. Threads are often used to improve program performance by allowing multiple tasks to be executed at the same time. The Thread has its own stack, registers, and program counters.\nThreads share memory address space, and it is possible to communicate between Threads using shared memory space. How to use it?","title":"What are Threads in Swift?"},{"content":"What is DispatchGroup? DispatchGroup provides a mechanism to track the completion group of tasks.\nHow DispatchGroup works? DispatchGroup has three main methods, enter, leave and notify, that allow you to control the completion of a specific task.\nlet dispatchGroup = DispatchGroup() dispatchGroup.enter() dispatchGroup.leave() dispatchGroup.notify(queue: .main) {} Let`s talk about each of these methods. enter — manually indicate a block has entered group. leave — manually indicate a block in the group has been completed. notify(queue: ) — schedule a block to be submitted to a queue when all the blocks associated with a group have been completed. The queue parameter is the queue to which the supplied block will be submitted when the group is complete.\nHow to implement DispatchGroup? You can implement DispatchGroup following these steps:\nlet dispatchGroup = DispatchGroup() dispatchGroup.enter() fetchGitHubUser1 { print(\u0026#34;fetchGitHubUser1 task completed\u0026#34;) dispatchGroup.leave() } dispatchGroup.enter() fetchGitHubUser2 { print(\u0026#34;fetchGitHubUser2 task completed\u0026#34;) dispatchGroup.leave() } dispatchGroup.notify(queue: .main) { print(\u0026#34;All tasks completed\u0026#34;) } // prints fetchGitHubUser1 task started fetchGitHubUser2 task started fetchGitHubUser1 task completed fetchGitHubUser2 task completed All tasks completed Pros You can create a group of tasks and track when all tasks finish their work. You can specify a queue where you want to be notified about completed operations.\nCons You should manually manage enter and leave operations that increase complexity and the chance of error. You can accidentally forget to write the leave operation, which can cause unpredictable behavior.\n","permalink":"http://localhost:1313/posts/post-13/","summary":"What is DispatchGroup? DispatchGroup provides a mechanism to track the completion group of tasks.\nHow DispatchGroup works? DispatchGroup has three main methods, enter, leave and notify, that allow you to control the completion of a specific task.\nlet dispatchGroup = DispatchGroup() dispatchGroup.enter() dispatchGroup.leave() dispatchGroup.notify(queue: .main) {} Let`s talk about each of these methods. enter — manually indicate a block has entered group. leave — manually indicate a block in the group has been completed.","title":"DispatchGroup in Swift"},{"content":"What is concurrency? The system can perform multiple tasks simultaneously. By tasks, I mean code or instructions. Modern computer chips have multiple cores that allow developers to create and run various tasks on multiple cores. Even if your chip has one core operating system it will provide context switching mechanism by enabling it to execute multiple tasks concurrently.\nMaterial about processes, threads I will skip explaining concepts about processes and threads because it is a vast topic, and it will take a lot of time to explain it. I attached links to the material to help you understand it more deeply. https://youtu.be/4rLW7zg21gI?si=49hq8Wrbpmeev41k https://youtu.be/r2__Rw8vu1M?si=b7b257Qu4Bty7OxA I will focus on implementation.\nThe old and modern way of implementing concurrency You can divide concurrency implementation into old or unstructured and modern or structured.\nBy old, I mean GCD (Grand Central Dispatch). By modern, I mean async/await, actor, and Task.\nIn this article, I will talk about the old way. GCD helps you keep your distance from manually managing threads and avoid unnecessary complexity, and it does it by providing API. One of these APIs is DispatchQueue.\nDispatchQueue By default, DispatchQueue is serial; all work on this queue will be executed sequentially. DispatchQueue has access to the main property and the global() method. The main property returns the serial queue associated with the main thread of the current process. The global() method returns a concurrent queue specified by quality-of-service level.\npublic class func global(qos: DispatchQoS.QoSClass = .default) -\u0026gt; DispatchQueue You can pass many parameters when you try to initialize a new queue.\npublic convenience init(label: String, qos: DispatchQoS = .unspecified, attributes: DispatchQueue.Attributes = [], autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency = .inherit, target: DispatchQueue? = nil) Let’s talk about three of them (label, qos, attributes). The first is label, which is used mainly for debugging and identification.\nlet queue = DispatchQueue(label: \u0026#34;com.example.myqueue\u0026#34;) The second one is qos (Quality Of Service) allows you to choose the priority in which you like to run your task. You can choose between background, utility, default, userInitiated, userIneractive, and unspecified priorities.\n/// qos_class_t public struct DispatchQoS : Equatable { public let qosClass: DispatchQoS.QoSClass public let relativePriority: Int @available(macOS 10.10, iOS 8.0, *) public static let background: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let utility: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let `default`: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let userInitiated: DispatchQoS @available(macOS 10.10, iOS 8.0, *) public static let userInteractive: DispatchQoS public static let unspecified: DispatchQoS } userIneractive has the highest priority; it usually calls when you need to display UI almost immediately.\nbackground, on the other hand, has the lowest priority.\nHow to achieve concurrency with DispatchQueue API? You can use a serial queue with the following: sync functionality allows you to wait until the block you passed finishes its work.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serial\u0026#34;) serialQueue.sync {} async functionality will schedule your work and be executed later in time.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serial\u0026#34;) serialQueue.async {} Or you can use a concurrent queue with similar methods but running your task in parallel.\nlet concurrentQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.concurrent\u0026#34;, attributes: .concurrent) concurrentQueue.sync {} concurrentQueue.async {} The difference between serial queue and concurrent queue The difference between a serial and concurrent queue is that you should not wait until the concurrent operation finishes work in the async block.\nlet concurrentQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.concurrent\u0026#34;, attributes: .concurrent) concurrentQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } concurrentQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Concurrent Queue Task 6 is running on Concurrent Queue Task 2 is running on Concurrent Queue Task 7 is running on Concurrent Queue Task 3 is running on Concurrent Queue Task 8 is running on Concurrent Queue Task 4 is running on Concurrent Queue Task 9 is running on Concurrent Queue Task 5 is running on Concurrent Queue Task 10 is running on Concurrent Queue The serial queue executes tasks in order, and you should wait until the first async block finishes its work to start the second block.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serual\u0026#34;) serialQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } serialQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Serial Queue Task 2 is running on Serial Queue Task 3 is running on Serial Queue Task 4 is running on Serial Queue Task 5 is running on Serial Queue Task 6 is running on Serial Queue Task 7 is running on Serial Queue Task 8 is running on Serial Queue Task 9 is running on Serial Queue Task 10 is running on Serial Queue When you try to use the sync functionality, it behaves similarly on serial and concurrent queues by executing each task step by step and waiting till each block finishes its work.\nlet serialQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.serial\u0026#34;) serialQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } serialQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Serial Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Serial Queue Task 2 is running on Serial Queue Task 3 is running on Serial Queue Task 4 is running on Serial Queue Task 5 is running on Serial Queue Task 6 is running on Serial Queue Task 7 is running on Serial Queue Task 8 is running on Serial Queue Task 9 is running on Serial Queue Task 10 is running on Serial Queue let concurrentQueue = DispatchQueue(label: \u0026#34;com.example.myqueue.concurrent\u0026#34;, attributes: .concurrent) concurrentQueue.sync { for i in 1...5 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } concurrentQueue.sync { for i in 6...10 { print(\u0026#34;Task \\(i) is running on Concurrent Queue\u0026#34;) sleep(1) // Simulate some work } } // prints Task 1 is running on Concurrent Queue Task 2 is running on Concurrent Queue Task 3 is running on Concurrent Queue Task 4 is running on Concurrent Queue Task 5 is running on Concurrent Queue Task 6 is running on Concurrent Queue Task 7 is running on Concurrent Queue Task 8 is running on Concurrent Queue Task 9 is running on Concurrent Queue Task 10 is running on Concurrent Queue ","permalink":"http://localhost:1313/posts/post-12/","summary":"What is concurrency? The system can perform multiple tasks simultaneously. By tasks, I mean code or instructions. Modern computer chips have multiple cores that allow developers to create and run various tasks on multiple cores. Even if your chip has one core operating system it will provide context switching mechanism by enabling it to execute multiple tasks concurrently.\nMaterial about processes, threads I will skip explaining concepts about processes and threads because it is a vast topic, and it will take a lot of time to explain it.","title":"Concurrency in Swift"},{"content":"What are value types? Value types play a central role in programming languages by grouping data values.\n`Value type” is a type of data copied when assigned to a new variable.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` How can you pass value types? You can pass value type by copying value.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` copiedStorage.data = \u0026#34;new data\u0026#34; // Changes `copiedStorage`, not `originalStorage` print(\u0026#34;\\(originalStorage.data), \\(copiedStorage.data)\u0026#34;) // prints \u0026#34;some data, new data\u0026#34; The effect of assignment, initialization, and argument passing creates an independent instance with a unique copy of its data.\nWhat types are value types? Value types can be struct, enum, tuple.\nWhat data types are value types? Strings, Arrays, Dictionaries, Numbers, Booleans, Floating-point numbers, and Integers are all value types.\nHow value types are stored in memory? The value types use Stack data structure for memory management.\nWhat is Copy-on-write mechanism? The copy-on-write mechanism is a resource-management technique used to optimize value types performance. It improves performance by avoiding unnecessary copies of value types. If resource is duplicated but not modified it’s unnecessary to create new resource.\nWhen to use value types? Choose value types if you don’t have shared mutable state.\n","permalink":"http://localhost:1313/posts/post-8/","summary":"What are value types? Value types play a central role in programming languages by grouping data values.\n`Value type” is a type of data copied when assigned to a new variable.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` How can you pass value types? You can pass value type by copying value.\nstruct Storage { var data: String = \u0026#34;some data\u0026#34; } let originalStorage = Storage() var copiedStorage = originalStorage // `originalStorage` is copied to `copiedStorage` copiedStorage.","title":"What are value types in Swift?"},{"content":"I was searching for tools that could help me find memory leaks faster and would be simple in implementation without affecting performance and memory size of application.\nI found a fantastic fit for this task LifetimeTracker developed by Krzysztof Zabłocki.\nAll you need is to add LifetimeTracker package to the project, inherit from LifetimeTrackable protocol, and add two lines of code.\nclass Department: LifetimeTrackable {} trackLifetime method to init of instance that you are going to verify, and lifetimeConfiguration property where you set max number of valid instances.\nclass Department: LifetimeTrackable { static var lifetimeConfiguration = LifetimeConfiguration(maxCount: 1, groupName: \u0026#34;Department\u0026#34;) let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) trackLifetime() } var employee: Employee? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } The final step is to add LifetimeTracker.setup to didFinishLaunchingWithOptions to be able to see Dashboard with detected issues.\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { #if DEBUG LifetimeTracker.setup( onUpdate: LifetimeTrackerDashboardIntegration( visibility: .alwaysVisible, style: .bar, textColorForNoIssues: .systemGreen, textColorForLeakDetected: .systemRed ).refreshUI ) #else #endif return true } I hope this article will help you save time finding and debugging this tricky task :-).\n","permalink":"http://localhost:1313/posts/post-9/","summary":"I was searching for tools that could help me find memory leaks faster and would be simple in implementation without affecting performance and memory size of application.\nI found a fantastic fit for this task LifetimeTracker developed by Krzysztof Zabłocki.\nAll you need is to add LifetimeTracker package to the project, inherit from LifetimeTrackable protocol, and add two lines of code.\nclass Department: LifetimeTrackable {} trackLifetime method to init of instance that you are going to verify, and lifetimeConfiguration property where you set max number of valid instances.","title":"How to prevent memory leaks?"},{"content":"The common way to find memory leaks is by using Xcode Instruments. All you need is the following:\nOpen Xcode Instruments\nChoose Leaks option Select Simulator where you are going to test your application Select your installed application When you finish preparation, you can start immediate recoding and check application for leaks. To do that, you need to open Simulator and try some cases that could cause memory leaks.\nAfter you spend some time trying different scenarios, you can see that Instruments found Leaked Objects. Another way to find memory leaks is by using Debug Memory Graph in Xcode Debug Area. Inside Debug Memory Graph, you can find MemoryLeaks section. MemoryLeaks section displays what objects have strong reference cycles between themselves.\nAll tools above have opportunity to find and highlight potential issues and help you resolve them.\n","permalink":"http://localhost:1313/posts/post-10/","summary":"The common way to find memory leaks is by using Xcode Instruments. All you need is the following:\nOpen Xcode Instruments\nChoose Leaks option Select Simulator where you are going to test your application Select your installed application When you finish preparation, you can start immediate recoding and check application for leaks. To do that, you need to open Simulator and try some cases that could cause memory leaks.\nAfter you spend some time trying different scenarios, you can see that Instruments found Leaked Objects.","title":"How to find memory leaks?"},{"content":"What is ARC? Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed. - Apple\nARC In Action In this example, we assign an instance to the reference1 property.\nnumber of references equals 1. class Storage { let data: Data init(data: Data) { self.data = data print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var reference1: Storage? var reference2: Storage? var reference3: Storage? reference1 = Storage(data: Data()) Now we can assign a reference to another two properties, reference2 and reference3. Whenever you assign a reference, you increase the counter.\nnumber of references equals 3. reference2 = reference1 reference3 = reference1 When you set reference2 and reference3 to nil, the number of references equals 1.\nreference2 = nil reference3 = nil Only when you set reference1 to nil object will be deinitialized.\nreference1 = nil Memory leaks Memory leaks appear when you have strong references between two instances that point to each other.\nIn this example, class Employee has optional department property, and class Department has optional employee property.\nclass Department { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } var employee: Employee? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } class Employee { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } var department: Department? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var employee: Employee? var department: Department? employee = Employee(name: \u0026#34;John Doe\u0026#34;) department = Department(name: \u0026#34;Research and development\u0026#34;) If we try to assign Department reference to employee property and Employee reference to department property, it creates a memory leak by strong references that point to each other.\nemployee!.department = department department!.employee = employee If you try to set employee and department properties to nil, then these two objects can’t be deallocated because of the existing strong reference relationship between both objects.\nemployee = nil department = nil To avoid this unpleasant situation, we can use weak, unowned references.\nWeak reference If you use a weak keyword before a property, you say that this property should not keep a strong reference. Weak property should always be mutable and optional because ARC set the property to nil after the instance was deallocated.\nIn this example, Employee instance has department property with weak keyword. It means when we set employee property to nil ARC sets department property to nil and deallocates Department instance.\nclass Department { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } var employee: Employee? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } class Employee { let name: String init(name: String) { self.name = name print(\u0026#34;\\(Self.self) is being initialized\u0026#34;) } weak var department: Department? deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var employee: Employee? var department: Department? employee = Employee(name: \u0026#34;John Doe\u0026#34;) department = Department(name: \u0026#34;Research and development\u0026#34;) employee!.department = department department!.employee = employee department = nil employee = nil Unowned reference Unowned reference can’t be optional, and it should always have value. If you try to access a deallocated property value, you will face a runtime error.\nIn this example, we have two instances: User and DiscountCard. DiscountCard has a relationship with the User that is marked as unowned to avoid a strong reference cycle.\nclass User { let name: String var discountCard: DiscountCard? init(name: String) { self.name = name } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } class DiscountCard { let number: UInt64 unowned let user: User init(number: UInt64, user: User) { self.number = number self.user = user } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var user: User? user = User(name: \u0026#34;John Doe\u0026#34;) When you create DiscountCard instance and assign it as reference to user property, it no longer holds strong reference.\nuser!.discountCard = DiscountCard(number: 1234_5678_9012_3456, user: user!) After we set user property to nil, it will deallocate User and DiscountCard instances.\nuser = nil Strong Reference Cycles for Closures Strong reference cycle for closure can occur if you assign closure to property of instance. In this case, you assign reference to that closure. The strong reference cycle appears because closures are reference types.\nclass MemoryStorage { let text: String let additionalText: String? lazy var copy: () -\u0026gt; String = { if let additionalText = self.additionalText { self.text + \u0026#34;\\n\u0026#34; + additionalText } else { self.text } } init(text: String, additionalText: String? = nil) { self.text = text self.additionalText = additionalText } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var memoryStorage: MemoryStorage? = MemoryStorage(text: \u0026#34;Thank you for registration\u0026#34;, additionalText: \u0026#34;John Doe\u0026#34;) print(memoryStorage!.copy()) memoryStorage = nil In this example, closure captures self.text property and create strong reference cycle by referencing to self.\nBreaking Strong Reference Cycle in Closure To break strong reference cycle, we need to add capture list with unowned keyword to copy closure.\nclass MemoryStorage { let text: String let additionalText: String? lazy var copy: () -\u0026gt; String = { [unowned self] in if let additionalText = self.additionalText { self.text + \u0026#34;\\n\u0026#34; + additionalText } else { self.text } } init(text: String, additionalText: String? = nil) { self.text = text self.additionalText = additionalText } deinit { print(\u0026#34;\\(Self.self) is being deinitialized\u0026#34;) } } var memoryStorage: MemoryStorage? = MemoryStorage(text: \u0026#34;Thank you for registration\u0026#34;, additionalText: \u0026#34;John Doe\u0026#34;) print(memoryStorage!.copy()) memoryStorage = nil ","permalink":"http://localhost:1313/posts/post-11/","summary":"What is ARC? Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed. - Apple\nARC In Action In this example, we assign an instance to the reference1 property.","title":"ARC in Swift"},{"content":"Introduction In this article, I’m going to briefly explain what closure is.\nClosures is self-conitained blocks of funcionality that can be passed around and used in your code. — Apple\nExpression:\n{ (params) -\u0026gt; return value in statements } @escaping When closure is marked as escaping, it will outlive or leave the scope you passed.\nfunc response(_ completionHandler: @escaping(Result) -\u0026gt; Void) { completionHandler(.success) } @nonescaping By default, closures are nonescaping, meaning closure will no longer exist in memory after complete execution in the scope you have passed it to.\nfunc filterImage(_ completionHandler: (Image) -\u0026gt; Void) { completionHandler(UIImage.filtered) } @autoclosure Autoclosures automatically create closure from the argument that you passed into a function.\nfunc animate(_ animation: @autoclosure @escaping () -\u0026gt; Void, duration: TimeInterval = 0.25) { UIView.animate(withDuration: duration, animations: animation) } Closure conceptualy looks like this first pointer points to the code that implements closure the second pointer pointed to the reference counted object.\nstruct Closure { var functionPointer: UnsafeRawPointer var closureContext: AnyObject? } ","permalink":"http://localhost:1313/posts/post-7/","summary":"Introduction In this article, I’m going to briefly explain what closure is.\nClosures is self-conitained blocks of funcionality that can be passed around and used in your code. — Apple\nExpression:\n{ (params) -\u0026gt; return value in statements } @escaping When closure is marked as escaping, it will outlive or leave the scope you passed.\nfunc response(_ completionHandler: @escaping(Result) -\u0026gt; Void) { completionHandler(.success) } @nonescaping By default, closures are nonescaping, meaning closure will no longer exist in memory after complete execution in the scope you have passed it to.","title":"What is closure in Swift language?"},{"content":"Introduction In Swift, classes, closures, and actors all reference types.\n\u0026lsquo;Reference type’ is instance that shares a single copy of data.\nAssigning a reference type to a constant or variable, or passing it into a function or method, it is always a reference to a shared instance that is assigned or passed in.\nExample You can pass your property value by sharing the same address in memory.\n// Reference type example class Storage { var data = “data-example” } var storage = Storage() print(\u0026#34;\\(storage.data)\u0026#34;) // prints \u0026#34;data-example\u0026#34; print(\u0026#34;storage address:\u0026#34;, Unmanaged.passUnretained(storage).toOpaque()) var copiedStorage = storage copiedStorage.data = “new-data” print(\u0026#34;\\(storage.data), \\(copiedStorage.data)\u0026#34;) // prints \u0026#34;new-data, new-data\u0026#34; print(\u0026#34;copiedStorage address:\u0026#34;, Unmanaged.passUnretained(copiedStorage).toOpaque()) As you can see, storage and copied storage property addresses are the same.\nSummary Copying data by reference refers to the same address in memory. This means that modifying data in one variable also affects another. It also means that multiple reference types may refer to the same object.\n","permalink":"http://localhost:1313/posts/post-5/","summary":"Introduction In Swift, classes, closures, and actors all reference types.\n\u0026lsquo;Reference type’ is instance that shares a single copy of data.\nAssigning a reference type to a constant or variable, or passing it into a function or method, it is always a reference to a shared instance that is assigned or passed in.\nExample You can pass your property value by sharing the same address in memory.\n// Reference type example class Storage { var data = “data-example” } var storage = Storage() print(\u0026#34;\\(storage.","title":"What is “reference type” in Swift?"},{"content":"Introduction The Composable Architecture (TCA) uses a unidirectional data flow (UDF). UDF is a design pattern where data and events move consistently and predictably. In UDF, data can only be transferred to other application parts in one way.\nIn TCA, the only way to mutate the state is by sending actions to a runtime store. The runtime store holds the entire app’s business logic and mutates the state inside.\nUDF can reduce data inconsistencies because of the single source of truth for the application.\nTCA is built around key components: Action State Reducer Effect Store Environment Code examples: Timer\nhttps://github.com/dmytrochumakov/TCA-Examples/tree/main/Timer/Timer/Timer Sources: https://github.com/pointfreeco/swift-composable-architecture https://www.youtube.com/watch?v=SfFDj6qT-xg\u0026ab_channel=SwiftandTips https://www.youtube.com/watch?v=XWZmgbylTpc\u0026ab_channel=SwiftHeroes https://www.youtube.com/watch?v=McmGb9sexMo\u0026ab_channel=SwiftandTips https://www.youtube.com/watch?v=McmGb9sexMo\u0026ab_channel=SwiftandTips https://markvillar.com/the-composable-architecture/ ","permalink":"http://localhost:1313/posts/post-4/","summary":"Introduction The Composable Architecture (TCA) uses a unidirectional data flow (UDF). UDF is a design pattern where data and events move consistently and predictably. In UDF, data can only be transferred to other application parts in one way.\nIn TCA, the only way to mutate the state is by sending actions to a runtime store. The runtime store holds the entire app’s business logic and mutates the state inside.\nUDF can reduce data inconsistencies because of the single source of truth for the application.","title":"Let’s talk about Composable Architecture"},{"content":" Hi! I'm Dmytro Chumakov.\nHighly skilled iOS Developer with extensive experience in developing, and testing mobile application projects.\nProficient in Swift, Objective-C, and SwiftUI, with a strong foundation in modern software engineering practices.\nKnown for enhancing application performance, and automating repetitive tasks.\nMy Values Innovation: I consistently seek innovative solutions, leveraging modern technologies and creative thinking to stay ahead of the curve.\nEfficiency: My focus on streamlining processes and maximizing productivity underscores my commitment to efficiency in every aspect of my work.\nQuality: I am dedicated to delivering high-quality products, ensuring excellence through thorough testing, documentation, and performance optimization.\nUser-Centricity: My development approach prioritizes user needs and experience, crafting applications that prioritize safety, interaction, and functionality.\nContinuous Learning: I actively pursue ongoing learning and skill development, staying updated with the latest industry trends and technologies.\nCollaboration: I thrive in collaborative environments, leveraging leadership skills to drive teamwork and achieve collective success in project delivery.\nCommunity Engagement: I am passionate about sharing knowledge and contributing to the developer community through technical posts and videos, fostering growth and learning for others.\n","permalink":"http://localhost:1313/about/","summary":"Information about me.","title":"About Me"},{"content":" E-commerce Proficient in developing marketplace and utility management apps, capable of creating e-commerce platforms with features like product catalogs, user authentication, payment gateways, and order management systems.\nHealthcare Skilled in healthcare app development, with experience in building Glucose Tracker and COVID-19 tracking applications. Capable of developing apps for health metric monitoring, telemedicine, medication management, and wellness tracking.\nFinance Experienced in utility management and currency-related projects, able to create personal finance management apps, budgeting tools, and investment trackers.\nSocial Networking Well-versed in developing social features like buyer-seller chat, suitable for creating social networking apps, messaging platforms, and event planning applications.\nUtility and Productivity Expertise in utility management and macOS tools, ideal for developing task management apps, note-taking tools, and time tracking solutions.\nEducation Background in building Multi-User studying apps and technical resources, capable of contributing to e-learning platforms, and language learning apps.\nCross-Domain Integration Diverse experience enables integration of functionalities across domains, such as combining e-commerce with social networking or incorporating healthcare monitoring into productivity tools.\nOpen Source Contributions Experienced in open-source projects, capable of contributing by improving documentation, fixing bugs, adding features, or creating libraries/frameworks for iOS development.\nEmerging Technologies Stay updated with AR, VR, ML, and IoT trends, exploring projects that leverage these technologies for innovative app development.\n","permalink":"http://localhost:1313/cases/","summary":"E-commerce Proficient in developing marketplace and utility management apps, capable of creating e-commerce platforms with features like product catalogs, user authentication, payment gateways, and order management systems.\nHealthcare Skilled in healthcare app development, with experience in building Glucose Tracker and COVID-19 tracking applications. Capable of developing apps for health metric monitoring, telemedicine, medication management, and wellness tracking.\nFinance Experienced in utility management and currency-related projects, able to create personal finance management apps, budgeting tools, and investment trackers.","title":"Cases"},{"content":"iOS App Maintenance Service This service is designed to improve your app’s stability, leading to more 5-star ratings and increased user satisfaction.\nIs This Service Right for You? Here are a few questions for you:\nAre you tired of getting negative app reviews due to bugs and crashes? Feel frustrated by your app’s low search rank and disappointing download numbers? Always worried about your app’s sudden breakdowns post-iOS updates? Struggling to find a reliable developer when your app needs quick fixes? If you’ve answered “yes” to any of these questions, this service is your solution! The Transformations You’ll Get A Glitch-Free App: I’ll keep your app free from bugs and crashes, ensuring a smooth user experience and preventing negative reviews. Enhanced User Satisfaction: By delivering a glitch-free app, you’ll provide a seamless and enjoyable experience for your users, leading to higher - user satisfaction and retention rates. Higher App’s Rating: A flawless app leads to higher ratings and more 5-star reviews, attracting new users and loyal customers. Rise in App Store Rankings: A well-performing app climbs the search rankings, gaining visibility and organic downloads. Stay Ahead of iOS Updates: I’ll ensure your app stays compatible with iOS updates, eliminating the fear of it breaking after each new release. Expert Developer at Your Fingertips: I’m always ready to assist you, ensuring your app remains relevant and competitive in the ever-evolving market. Pick What You Need All packages come with a 30-day 110% Money-Back Guarantee.\nMost Popular Lite Essential care for apps\n$399 per month\nUnlimited bug fixes Unlimited crash fixes iOS compatibility updates Bi-weekly app releases Unlimited email support Most Popular Plus Ongoing app enhancement\n$799 per month\nAll services in Lite + Performance monitoring App reviews support Minor UI/UX improvement App content updates Most Popular Pro For constantly evolving apps\n$2499 per month\nAll services in Plus + Feature implementation Major UI/UX improvement Major feature updates Weekly consultation call Ready to Boost Your App’s Success? Ready to unlock your app’s true potential? Or do you have questions?\nSend me an email or schedule a call with me, and let’s make it happen together. I’m here to assist you every step of the way.\nGet in Touch Now! ","permalink":"http://localhost:1313/ios-app-maintenance-service/","summary":"iOS App Maintenance Service This service is designed to improve your app’s stability, leading to more 5-star ratings and increased user satisfaction.\nIs This Service Right for You? Here are a few questions for you:\nAre you tired of getting negative app reviews due to bugs and crashes? Feel frustrated by your app’s low search rank and disappointing download numbers? Always worried about your app’s sudden breakdowns post-iOS updates? Struggling to find a reliable developer when your app needs quick fixes?","title":"Services"},{"content":" Thank You Thank you for your interest in this course! Your enthusiasm means a lot to me. Currently, I'm in the testing phase for this idea. If there's significant interest from individuals like you, I'll move forward with creating the course. If you'd like to stay updated on its progress, please feel free to drop me an email. Your support is truly appreciated!\nIf you have any questions or want updates, please email me at dmytro.v.chumakov.work@gmail.com.\n","permalink":"http://localhost:1313/thank-you/","summary":"Thank You Thank you for your interest in this course! Your enthusiasm means a lot to me. Currently, I'm in the testing phase for this idea. If there's significant interest from individuals like you, I'll move forward with creating the course. If you'd like to stay updated on its progress, please feel free to drop me an email. Your support is truly appreciated!\nIf you have any questions or want updates, please email me at dmytro.","title":"Thank You"}]